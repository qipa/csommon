// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MapDataV1Data.proto

#ifndef PROTOBUF_MapDataV1Data_2eproto__INCLUDED
#define PROTOBUF_MapDataV1Data_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "PublicStruct.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MapDataV1Data_2eproto();
void protobuf_AssignDesc_MapDataV1Data_2eproto();
void protobuf_ShutdownFile_MapDataV1Data_2eproto();

class MapDataUselessV1;
class MapDataLayerInfoV1;
class MapDataInfoV1;
class MapDataVector2V1;
class MapDataSpawnInfoV1;
class MapDataDefeatInfoV1;
class MapDataPerfectInfoV1;
class MapDataPortalInfoV1;
class MapDataTrapInfoV1;
class MapDataNpcInfoV1;
class MapDataMonsterInfoV1;
class MapDataNodeInfoV1;
class MapDataTerritorialInfoV1;
class MapDataNodeMonsterInfoV1;
class MapDataBaseConfigV1;
class MapDataGatherInfoV1;
class MapDataContourLineInfoV1;
class MapDataEventInfoV1;

// ===================================================================

class MapDataUselessV1 : public ::google::protobuf::Message {
 public:
  MapDataUselessV1();
  virtual ~MapDataUselessV1();

  MapDataUselessV1(const MapDataUselessV1& from);

  inline MapDataUselessV1& operator=(const MapDataUselessV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataUselessV1& default_instance();

  void Swap(MapDataUselessV1* other);

  // implements Message ----------------------------------------------

  MapDataUselessV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataUselessV1& from);
  void MergeFrom(const MapDataUselessV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 X1 = 1 [default = -1];
  inline bool has_x1() const;
  inline void clear_x1();
  static const int kX1FieldNumber = 1;
  inline ::google::protobuf::int32 x1() const;
  inline void set_x1(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MapDataUselessV1)
 private:
  inline void set_has_x1();
  inline void clear_has_x1();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x1_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MapDataV1Data_2eproto();
  friend void protobuf_AssignDesc_MapDataV1Data_2eproto();
  friend void protobuf_ShutdownFile_MapDataV1Data_2eproto();

  void InitAsDefaultInstance();
  static MapDataUselessV1* default_instance_;
};
// -------------------------------------------------------------------

class MapDataLayerInfoV1 : public ::google::protobuf::Message {
 public:
  MapDataLayerInfoV1();
  virtual ~MapDataLayerInfoV1();

  MapDataLayerInfoV1(const MapDataLayerInfoV1& from);

  inline MapDataLayerInfoV1& operator=(const MapDataLayerInfoV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataLayerInfoV1& default_instance();

  void Swap(MapDataLayerInfoV1* other);

  // implements Message ----------------------------------------------

  MapDataLayerInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataLayerInfoV1& from);
  void MergeFrom(const MapDataLayerInfoV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MapDataVector2V1 WalkArea = 2;
  inline int walkarea_size() const;
  inline void clear_walkarea();
  static const int kWalkAreaFieldNumber = 2;
  inline const ::MapDataVector2V1& walkarea(int index) const;
  inline ::MapDataVector2V1* mutable_walkarea(int index);
  inline ::MapDataVector2V1* add_walkarea();
  inline const ::google::protobuf::RepeatedPtrField< ::MapDataVector2V1 >&
      walkarea() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapDataVector2V1 >*
      mutable_walkarea();

  // repeated .MapDataVector2V1 LostArea = 3;
  inline int lostarea_size() const;
  inline void clear_lostarea();
  static const int kLostAreaFieldNumber = 3;
  inline const ::MapDataVector2V1& lostarea(int index) const;
  inline ::MapDataVector2V1* mutable_lostarea(int index);
  inline ::MapDataVector2V1* add_lostarea();
  inline const ::google::protobuf::RepeatedPtrField< ::MapDataVector2V1 >&
      lostarea() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapDataVector2V1 >*
      mutable_lostarea();

  // optional float ClientHight = 4 [default = 0];
  inline bool has_clienthight() const;
  inline void clear_clienthight();
  static const int kClientHightFieldNumber = 4;
  inline float clienthight() const;
  inline void set_clienthight(float value);

  // optional float X = 5 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 5;
  inline float x() const;
  inline void set_x(float value);

  // optional float Z = 6 [default = 0];
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 6;
  inline float z() const;
  inline void set_z(float value);

  // optional float Y = 7 [default = 0];
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 7;
  inline float y() const;
  inline void set_y(float value);

  // optional float MinHeightLimit = 9 [default = 0];
  inline bool has_minheightlimit() const;
  inline void clear_minheightlimit();
  static const int kMinHeightLimitFieldNumber = 9;
  inline float minheightlimit() const;
  inline void set_minheightlimit(float value);

  // optional float MaxHeightLimit = 10 [default = 0];
  inline bool has_maxheightlimit() const;
  inline void clear_maxheightlimit();
  static const int kMaxHeightLimitFieldNumber = 10;
  inline float maxheightlimit() const;
  inline void set_maxheightlimit(float value);

  // @@protoc_insertion_point(class_scope:MapDataLayerInfoV1)
 private:
  inline void set_has_clienthight();
  inline void clear_has_clienthight();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_minheightlimit();
  inline void clear_has_minheightlimit();
  inline void set_has_maxheightlimit();
  inline void clear_has_maxheightlimit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::MapDataVector2V1 > walkarea_;
  ::google::protobuf::RepeatedPtrField< ::MapDataVector2V1 > lostarea_;
  float clienthight_;
  float x_;
  float z_;
  float y_;
  float minheightlimit_;
  float maxheightlimit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_MapDataV1Data_2eproto();
  friend void protobuf_AssignDesc_MapDataV1Data_2eproto();
  friend void protobuf_ShutdownFile_MapDataV1Data_2eproto();

  void InitAsDefaultInstance();
  static MapDataLayerInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class MapDataInfoV1 : public ::google::protobuf::Message {
 public:
  MapDataInfoV1();
  virtual ~MapDataInfoV1();

  MapDataInfoV1(const MapDataInfoV1& from);

  inline MapDataInfoV1& operator=(const MapDataInfoV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataInfoV1& default_instance();

  void Swap(MapDataInfoV1* other);

  // implements Message ----------------------------------------------

  MapDataInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataInfoV1& from);
  void MergeFrom(const MapDataInfoV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .MapDataLayerInfoV1 LayerArr = 1;
  inline int layerarr_size() const;
  inline void clear_layerarr();
  static const int kLayerArrFieldNumber = 1;
  inline const ::MapDataLayerInfoV1& layerarr(int index) const;
  inline ::MapDataLayerInfoV1* mutable_layerarr(int index);
  inline ::MapDataLayerInfoV1* add_layerarr();
  inline const ::google::protobuf::RepeatedPtrField< ::MapDataLayerInfoV1 >&
      layerarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapDataLayerInfoV1 >*
      mutable_layerarr();

  // repeated .MapDataSpawnInfoV1 SpawnArr = 2;
  inline int spawnarr_size() const;
  inline void clear_spawnarr();
  static const int kSpawnArrFieldNumber = 2;
  inline const ::MapDataSpawnInfoV1& spawnarr(int index) const;
  inline ::MapDataSpawnInfoV1* mutable_spawnarr(int index);
  inline ::MapDataSpawnInfoV1* add_spawnarr();
  inline const ::google::protobuf::RepeatedPtrField< ::MapDataSpawnInfoV1 >&
      spawnarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapDataSpawnInfoV1 >*
      mutable_spawnarr();

  // optional .MapDataDefeatInfoV1 Defeat = 3;
  inline bool has_defeat() const;
  inline void clear_defeat();
  static const int kDefeatFieldNumber = 3;
  inline const ::MapDataDefeatInfoV1& defeat() const;
  inline ::MapDataDefeatInfoV1* mutable_defeat();
  inline ::MapDataDefeatInfoV1* release_defeat();
  inline void set_allocated_defeat(::MapDataDefeatInfoV1* defeat);

  // repeated .MapDataPerfectInfoV1 PerfectArr = 4;
  inline int perfectarr_size() const;
  inline void clear_perfectarr();
  static const int kPerfectArrFieldNumber = 4;
  inline const ::MapDataPerfectInfoV1& perfectarr(int index) const;
  inline ::MapDataPerfectInfoV1* mutable_perfectarr(int index);
  inline ::MapDataPerfectInfoV1* add_perfectarr();
  inline const ::google::protobuf::RepeatedPtrField< ::MapDataPerfectInfoV1 >&
      perfectarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapDataPerfectInfoV1 >*
      mutable_perfectarr();

  // repeated .MapDataPortalInfoV1 PortalArr = 5;
  inline int portalarr_size() const;
  inline void clear_portalarr();
  static const int kPortalArrFieldNumber = 5;
  inline const ::MapDataPortalInfoV1& portalarr(int index) const;
  inline ::MapDataPortalInfoV1* mutable_portalarr(int index);
  inline ::MapDataPortalInfoV1* add_portalarr();
  inline const ::google::protobuf::RepeatedPtrField< ::MapDataPortalInfoV1 >&
      portalarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapDataPortalInfoV1 >*
      mutable_portalarr();

  // repeated .MapDataTrapInfoV1 TrapArr = 6;
  inline int traparr_size() const;
  inline void clear_traparr();
  static const int kTrapArrFieldNumber = 6;
  inline const ::MapDataTrapInfoV1& traparr(int index) const;
  inline ::MapDataTrapInfoV1* mutable_traparr(int index);
  inline ::MapDataTrapInfoV1* add_traparr();
  inline const ::google::protobuf::RepeatedPtrField< ::MapDataTrapInfoV1 >&
      traparr() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapDataTrapInfoV1 >*
      mutable_traparr();

  // repeated .MapDataNpcInfoV1 NpcArr = 7;
  inline int npcarr_size() const;
  inline void clear_npcarr();
  static const int kNpcArrFieldNumber = 7;
  inline const ::MapDataNpcInfoV1& npcarr(int index) const;
  inline ::MapDataNpcInfoV1* mutable_npcarr(int index);
  inline ::MapDataNpcInfoV1* add_npcarr();
  inline const ::google::protobuf::RepeatedPtrField< ::MapDataNpcInfoV1 >&
      npcarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapDataNpcInfoV1 >*
      mutable_npcarr();

  // repeated .MapDataNodeInfoV1 NodeArr = 8;
  inline int nodearr_size() const;
  inline void clear_nodearr();
  static const int kNodeArrFieldNumber = 8;
  inline const ::MapDataNodeInfoV1& nodearr(int index) const;
  inline ::MapDataNodeInfoV1* mutable_nodearr(int index);
  inline ::MapDataNodeInfoV1* add_nodearr();
  inline const ::google::protobuf::RepeatedPtrField< ::MapDataNodeInfoV1 >&
      nodearr() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapDataNodeInfoV1 >*
      mutable_nodearr();

  // optional string Name = 9;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 9;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .MapDataTerritorialInfoV1 StormBaseArr = 10;
  inline int stormbasearr_size() const;
  inline void clear_stormbasearr();
  static const int kStormBaseArrFieldNumber = 10;
  inline const ::MapDataTerritorialInfoV1& stormbasearr(int index) const;
  inline ::MapDataTerritorialInfoV1* mutable_stormbasearr(int index);
  inline ::MapDataTerritorialInfoV1* add_stormbasearr();
  inline const ::google::protobuf::RepeatedPtrField< ::MapDataTerritorialInfoV1 >&
      stormbasearr() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapDataTerritorialInfoV1 >*
      mutable_stormbasearr();

  // optional .MapDataTerritorialInfoV1 StormFlag = 11;
  inline bool has_stormflag() const;
  inline void clear_stormflag();
  static const int kStormFlagFieldNumber = 11;
  inline const ::MapDataTerritorialInfoV1& stormflag() const;
  inline ::MapDataTerritorialInfoV1* mutable_stormflag();
  inline ::MapDataTerritorialInfoV1* release_stormflag();
  inline void set_allocated_stormflag(::MapDataTerritorialInfoV1* stormflag);

  // optional .MapDataBaseConfigV1 BaseConfig = 12;
  inline bool has_baseconfig() const;
  inline void clear_baseconfig();
  static const int kBaseConfigFieldNumber = 12;
  inline const ::MapDataBaseConfigV1& baseconfig() const;
  inline ::MapDataBaseConfigV1* mutable_baseconfig();
  inline ::MapDataBaseConfigV1* release_baseconfig();
  inline void set_allocated_baseconfig(::MapDataBaseConfigV1* baseconfig);

  // repeated .MapDataGatherInfoV1 GatherArr = 13;
  inline int gatherarr_size() const;
  inline void clear_gatherarr();
  static const int kGatherArrFieldNumber = 13;
  inline const ::MapDataGatherInfoV1& gatherarr(int index) const;
  inline ::MapDataGatherInfoV1* mutable_gatherarr(int index);
  inline ::MapDataGatherInfoV1* add_gatherarr();
  inline const ::google::protobuf::RepeatedPtrField< ::MapDataGatherInfoV1 >&
      gatherarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapDataGatherInfoV1 >*
      mutable_gatherarr();

  // repeated .MapDataEventInfoV1 EventArr = 14;
  inline int eventarr_size() const;
  inline void clear_eventarr();
  static const int kEventArrFieldNumber = 14;
  inline const ::MapDataEventInfoV1& eventarr(int index) const;
  inline ::MapDataEventInfoV1* mutable_eventarr(int index);
  inline ::MapDataEventInfoV1* add_eventarr();
  inline const ::google::protobuf::RepeatedPtrField< ::MapDataEventInfoV1 >&
      eventarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapDataEventInfoV1 >*
      mutable_eventarr();

  // @@protoc_insertion_point(class_scope:MapDataInfoV1)
 private:
  inline void set_has_defeat();
  inline void clear_has_defeat();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_stormflag();
  inline void clear_has_stormflag();
  inline void set_has_baseconfig();
  inline void clear_has_baseconfig();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::MapDataLayerInfoV1 > layerarr_;
  ::google::protobuf::RepeatedPtrField< ::MapDataSpawnInfoV1 > spawnarr_;
  ::MapDataDefeatInfoV1* defeat_;
  ::google::protobuf::RepeatedPtrField< ::MapDataPerfectInfoV1 > perfectarr_;
  ::google::protobuf::RepeatedPtrField< ::MapDataPortalInfoV1 > portalarr_;
  ::google::protobuf::RepeatedPtrField< ::MapDataTrapInfoV1 > traparr_;
  ::google::protobuf::RepeatedPtrField< ::MapDataNpcInfoV1 > npcarr_;
  ::google::protobuf::RepeatedPtrField< ::MapDataNodeInfoV1 > nodearr_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::MapDataTerritorialInfoV1 > stormbasearr_;
  ::MapDataTerritorialInfoV1* stormflag_;
  ::MapDataBaseConfigV1* baseconfig_;
  ::google::protobuf::RepeatedPtrField< ::MapDataGatherInfoV1 > gatherarr_;
  ::google::protobuf::RepeatedPtrField< ::MapDataEventInfoV1 > eventarr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_MapDataV1Data_2eproto();
  friend void protobuf_AssignDesc_MapDataV1Data_2eproto();
  friend void protobuf_ShutdownFile_MapDataV1Data_2eproto();

  void InitAsDefaultInstance();
  static MapDataInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class MapDataVector2V1 : public ::google::protobuf::Message {
 public:
  MapDataVector2V1();
  virtual ~MapDataVector2V1();

  MapDataVector2V1(const MapDataVector2V1& from);

  inline MapDataVector2V1& operator=(const MapDataVector2V1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataVector2V1& default_instance();

  void Swap(MapDataVector2V1* other);

  // implements Message ----------------------------------------------

  MapDataVector2V1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataVector2V1& from);
  void MergeFrom(const MapDataVector2V1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float X1 = 1 [default = 0];
  inline bool has_x1() const;
  inline void clear_x1();
  static const int kX1FieldNumber = 1;
  inline float x1() const;
  inline void set_x1(float value);

  // optional float X2 = 2 [default = 0];
  inline bool has_x2() const;
  inline void clear_x2();
  static const int kX2FieldNumber = 2;
  inline float x2() const;
  inline void set_x2(float value);

  // optional float Z1 = 4 [default = 0];
  inline bool has_z1() const;
  inline void clear_z1();
  static const int kZ1FieldNumber = 4;
  inline float z1() const;
  inline void set_z1(float value);

  // optional float Z2 = 5 [default = 0];
  inline bool has_z2() const;
  inline void clear_z2();
  static const int kZ2FieldNumber = 5;
  inline float z2() const;
  inline void set_z2(float value);

  // optional float OrgAngle = 7 [default = 0];
  inline bool has_organgle() const;
  inline void clear_organgle();
  static const int kOrgAngleFieldNumber = 7;
  inline float organgle() const;
  inline void set_organgle(float value);

  // optional float FinAngle = 8 [default = 0];
  inline bool has_finangle() const;
  inline void clear_finangle();
  static const int kFinAngleFieldNumber = 8;
  inline float finangle() const;
  inline void set_finangle(float value);

  // optional float Radius = 11 [default = 0];
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 11;
  inline float radius() const;
  inline void set_radius(float value);

  // repeated .MapDataContourLineInfoV1 ContourLineArr = 12;
  inline int contourlinearr_size() const;
  inline void clear_contourlinearr();
  static const int kContourLineArrFieldNumber = 12;
  inline const ::MapDataContourLineInfoV1& contourlinearr(int index) const;
  inline ::MapDataContourLineInfoV1* mutable_contourlinearr(int index);
  inline ::MapDataContourLineInfoV1* add_contourlinearr();
  inline const ::google::protobuf::RepeatedPtrField< ::MapDataContourLineInfoV1 >&
      contourlinearr() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapDataContourLineInfoV1 >*
      mutable_contourlinearr();

  // @@protoc_insertion_point(class_scope:MapDataVector2V1)
 private:
  inline void set_has_x1();
  inline void clear_has_x1();
  inline void set_has_x2();
  inline void clear_has_x2();
  inline void set_has_z1();
  inline void clear_has_z1();
  inline void set_has_z2();
  inline void clear_has_z2();
  inline void set_has_organgle();
  inline void clear_has_organgle();
  inline void set_has_finangle();
  inline void clear_has_finangle();
  inline void set_has_radius();
  inline void clear_has_radius();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x1_;
  float x2_;
  float z1_;
  float z2_;
  float organgle_;
  float finangle_;
  ::google::protobuf::RepeatedPtrField< ::MapDataContourLineInfoV1 > contourlinearr_;
  float radius_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_MapDataV1Data_2eproto();
  friend void protobuf_AssignDesc_MapDataV1Data_2eproto();
  friend void protobuf_ShutdownFile_MapDataV1Data_2eproto();

  void InitAsDefaultInstance();
  static MapDataVector2V1* default_instance_;
};
// -------------------------------------------------------------------

class MapDataSpawnInfoV1 : public ::google::protobuf::Message {
 public:
  MapDataSpawnInfoV1();
  virtual ~MapDataSpawnInfoV1();

  MapDataSpawnInfoV1(const MapDataSpawnInfoV1& from);

  inline MapDataSpawnInfoV1& operator=(const MapDataSpawnInfoV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataSpawnInfoV1& default_instance();

  void Swap(MapDataSpawnInfoV1* other);

  // implements Message ----------------------------------------------

  MapDataSpawnInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataSpawnInfoV1& from);
  void MergeFrom(const MapDataSpawnInfoV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float X = 1 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional sint32 Layer = 2 [default = 0];
  inline bool has_layer() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 2;
  inline ::google::protobuf::int32 layer() const;
  inline void set_layer(::google::protobuf::int32 value);

  // optional sint32 SpawnDirection = 3 [default = 1];
  inline bool has_spawndirection() const;
  inline void clear_spawndirection();
  static const int kSpawnDirectionFieldNumber = 3;
  inline ::google::protobuf::int32 spawndirection() const;
  inline void set_spawndirection(::google::protobuf::int32 value);

  // optional float Z = 4 [default = 0];
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 4;
  inline float z() const;
  inline void set_z(float value);

  // optional float Radius = 5 [default = 0];
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 5;
  inline float radius() const;
  inline void set_radius(float value);

  // optional float Angle = 6 [default = 0];
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 6;
  inline float angle() const;
  inline void set_angle(float value);

  // @@protoc_insertion_point(class_scope:MapDataSpawnInfoV1)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_layer();
  inline void clear_has_layer();
  inline void set_has_spawndirection();
  inline void clear_has_spawndirection();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_angle();
  inline void clear_has_angle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  ::google::protobuf::int32 layer_;
  ::google::protobuf::int32 spawndirection_;
  float z_;
  float radius_;
  float angle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_MapDataV1Data_2eproto();
  friend void protobuf_AssignDesc_MapDataV1Data_2eproto();
  friend void protobuf_ShutdownFile_MapDataV1Data_2eproto();

  void InitAsDefaultInstance();
  static MapDataSpawnInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class MapDataDefeatInfoV1 : public ::google::protobuf::Message {
 public:
  MapDataDefeatInfoV1();
  virtual ~MapDataDefeatInfoV1();

  MapDataDefeatInfoV1(const MapDataDefeatInfoV1& from);

  inline MapDataDefeatInfoV1& operator=(const MapDataDefeatInfoV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataDefeatInfoV1& default_instance();

  void Swap(MapDataDefeatInfoV1* other);

  // implements Message ----------------------------------------------

  MapDataDefeatInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataDefeatInfoV1& from);
  void MergeFrom(const MapDataDefeatInfoV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Condition = 1 [default = 0];
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 1;
  inline ::google::protobuf::int32 condition() const;
  inline void set_condition(::google::protobuf::int32 value);

  // optional float TimeLimit = 4 [default = 0];
  inline bool has_timelimit() const;
  inline void clear_timelimit();
  static const int kTimeLimitFieldNumber = 4;
  inline float timelimit() const;
  inline void set_timelimit(float value);

  // @@protoc_insertion_point(class_scope:MapDataDefeatInfoV1)
 private:
  inline void set_has_condition();
  inline void clear_has_condition();
  inline void set_has_timelimit();
  inline void clear_has_timelimit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 condition_;
  float timelimit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MapDataV1Data_2eproto();
  friend void protobuf_AssignDesc_MapDataV1Data_2eproto();
  friend void protobuf_ShutdownFile_MapDataV1Data_2eproto();

  void InitAsDefaultInstance();
  static MapDataDefeatInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class MapDataPerfectInfoV1 : public ::google::protobuf::Message {
 public:
  MapDataPerfectInfoV1();
  virtual ~MapDataPerfectInfoV1();

  MapDataPerfectInfoV1(const MapDataPerfectInfoV1& from);

  inline MapDataPerfectInfoV1& operator=(const MapDataPerfectInfoV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataPerfectInfoV1& default_instance();

  void Swap(MapDataPerfectInfoV1* other);

  // implements Message ----------------------------------------------

  MapDataPerfectInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataPerfectInfoV1& from);
  void MergeFrom(const MapDataPerfectInfoV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Condition = 1 [default = -1];
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 1;
  inline ::google::protobuf::int32 condition() const;
  inline void set_condition(::google::protobuf::int32 value);

  // optional sint32 DeathCountNum = 2 [default = 0];
  inline bool has_deathcountnum() const;
  inline void clear_deathcountnum();
  static const int kDeathCountNumFieldNumber = 2;
  inline ::google::protobuf::int32 deathcountnum() const;
  inline void set_deathcountnum(::google::protobuf::int32 value);

  // optional sint32 KillEnemyID = 3 [default = 0];
  inline bool has_killenemyid() const;
  inline void clear_killenemyid();
  static const int kKillEnemyIDFieldNumber = 3;
  inline ::google::protobuf::int32 killenemyid() const;
  inline void set_killenemyid(::google::protobuf::int32 value);

  // optional sint32 KillEnemyCount = 4 [default = 0];
  inline bool has_killenemycount() const;
  inline void clear_killenemycount();
  static const int kKillEnemyCountFieldNumber = 4;
  inline ::google::protobuf::int32 killenemycount() const;
  inline void set_killenemycount(::google::protobuf::int32 value);

  // optional sint32 HpPercent = 5 [default = 0];
  inline bool has_hppercent() const;
  inline void clear_hppercent();
  static const int kHpPercentFieldNumber = 5;
  inline ::google::protobuf::int32 hppercent() const;
  inline void set_hppercent(::google::protobuf::int32 value);

  // optional float TimeLimit = 6 [default = 0];
  inline bool has_timelimit() const;
  inline void clear_timelimit();
  static const int kTimeLimitFieldNumber = 6;
  inline float timelimit() const;
  inline void set_timelimit(float value);

  // @@protoc_insertion_point(class_scope:MapDataPerfectInfoV1)
 private:
  inline void set_has_condition();
  inline void clear_has_condition();
  inline void set_has_deathcountnum();
  inline void clear_has_deathcountnum();
  inline void set_has_killenemyid();
  inline void clear_has_killenemyid();
  inline void set_has_killenemycount();
  inline void clear_has_killenemycount();
  inline void set_has_hppercent();
  inline void clear_has_hppercent();
  inline void set_has_timelimit();
  inline void clear_has_timelimit();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 condition_;
  ::google::protobuf::int32 deathcountnum_;
  ::google::protobuf::int32 killenemyid_;
  ::google::protobuf::int32 killenemycount_;
  ::google::protobuf::int32 hppercent_;
  float timelimit_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_MapDataV1Data_2eproto();
  friend void protobuf_AssignDesc_MapDataV1Data_2eproto();
  friend void protobuf_ShutdownFile_MapDataV1Data_2eproto();

  void InitAsDefaultInstance();
  static MapDataPerfectInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class MapDataPortalInfoV1 : public ::google::protobuf::Message {
 public:
  MapDataPortalInfoV1();
  virtual ~MapDataPortalInfoV1();

  MapDataPortalInfoV1(const MapDataPortalInfoV1& from);

  inline MapDataPortalInfoV1& operator=(const MapDataPortalInfoV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataPortalInfoV1& default_instance();

  void Swap(MapDataPortalInfoV1* other);

  // implements Message ----------------------------------------------

  MapDataPortalInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataPortalInfoV1& from);
  void MergeFrom(const MapDataPortalInfoV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float SourceX = 1 [default = 0];
  inline bool has_sourcex() const;
  inline void clear_sourcex();
  static const int kSourceXFieldNumber = 1;
  inline float sourcex() const;
  inline void set_sourcex(float value);

  // optional sint32 SourceLayer = 2 [default = 0];
  inline bool has_sourcelayer() const;
  inline void clear_sourcelayer();
  static const int kSourceLayerFieldNumber = 2;
  inline ::google::protobuf::int32 sourcelayer() const;
  inline void set_sourcelayer(::google::protobuf::int32 value);

  // optional float TargetX = 3 [default = -1];
  inline bool has_targetx() const;
  inline void clear_targetx();
  static const int kTargetXFieldNumber = 3;
  inline float targetx() const;
  inline void set_targetx(float value);

  // optional sint32 TargetLayer = 4 [default = -1];
  inline bool has_targetlayer() const;
  inline void clear_targetlayer();
  static const int kTargetLayerFieldNumber = 4;
  inline ::google::protobuf::int32 targetlayer() const;
  inline void set_targetlayer(::google::protobuf::int32 value);

  // optional sint32 UseCount = 5 [default = 1];
  inline bool has_usecount() const;
  inline void clear_usecount();
  static const int kUseCountFieldNumber = 5;
  inline ::google::protobuf::int32 usecount() const;
  inline void set_usecount(::google::protobuf::int32 value);

  // optional bool Channel = 6 [default = false];
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 6;
  inline bool channel() const;
  inline void set_channel(bool value);

  // optional sint32 PortalType = 7 [default = 0];
  inline bool has_portaltype() const;
  inline void clear_portaltype();
  static const int kPortalTypeFieldNumber = 7;
  inline ::google::protobuf::int32 portaltype() const;
  inline void set_portaltype(::google::protobuf::int32 value);

  // optional sint32 TargetDungeonId = 8 [default = 0];
  inline bool has_targetdungeonid() const;
  inline void clear_targetdungeonid();
  static const int kTargetDungeonIdFieldNumber = 8;
  inline ::google::protobuf::int32 targetdungeonid() const;
  inline void set_targetdungeonid(::google::protobuf::int32 value);

  // optional sint32 TargetSpawnIndex = 9 [default = 0];
  inline bool has_targetspawnindex() const;
  inline void clear_targetspawnindex();
  static const int kTargetSpawnIndexFieldNumber = 9;
  inline ::google::protobuf::int32 targetspawnindex() const;
  inline void set_targetspawnindex(::google::protobuf::int32 value);

  // optional sint32 TargetDirection = 10 [default = 0];
  inline bool has_targetdirection() const;
  inline void clear_targetdirection();
  static const int kTargetDirectionFieldNumber = 10;
  inline ::google::protobuf::int32 targetdirection() const;
  inline void set_targetdirection(::google::protobuf::int32 value);

  // optional float SourceZ = 11 [default = 0];
  inline bool has_sourcez() const;
  inline void clear_sourcez();
  static const int kSourceZFieldNumber = 11;
  inline float sourcez() const;
  inline void set_sourcez(float value);

  // optional float TargetZ = 12 [default = 0];
  inline bool has_targetz() const;
  inline void clear_targetz();
  static const int kTargetZFieldNumber = 12;
  inline float targetz() const;
  inline void set_targetz(float value);

  // optional float SourceAngle = 13 [default = 0];
  inline bool has_sourceangle() const;
  inline void clear_sourceangle();
  static const int kSourceAngleFieldNumber = 13;
  inline float sourceangle() const;
  inline void set_sourceangle(float value);

  // optional float TargetAngle = 14 [default = 0];
  inline bool has_targetangle() const;
  inline void clear_targetangle();
  static const int kTargetAngleFieldNumber = 14;
  inline float targetangle() const;
  inline void set_targetangle(float value);

  // optional float SourceRadius = 15 [default = 0];
  inline bool has_sourceradius() const;
  inline void clear_sourceradius();
  static const int kSourceRadiusFieldNumber = 15;
  inline float sourceradius() const;
  inline void set_sourceradius(float value);

  // optional float TargetRadius = 16 [default = 0];
  inline bool has_targetradius() const;
  inline void clear_targetradius();
  static const int kTargetRadiusFieldNumber = 16;
  inline float targetradius() const;
  inline void set_targetradius(float value);

  // @@protoc_insertion_point(class_scope:MapDataPortalInfoV1)
 private:
  inline void set_has_sourcex();
  inline void clear_has_sourcex();
  inline void set_has_sourcelayer();
  inline void clear_has_sourcelayer();
  inline void set_has_targetx();
  inline void clear_has_targetx();
  inline void set_has_targetlayer();
  inline void clear_has_targetlayer();
  inline void set_has_usecount();
  inline void clear_has_usecount();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_portaltype();
  inline void clear_has_portaltype();
  inline void set_has_targetdungeonid();
  inline void clear_has_targetdungeonid();
  inline void set_has_targetspawnindex();
  inline void clear_has_targetspawnindex();
  inline void set_has_targetdirection();
  inline void clear_has_targetdirection();
  inline void set_has_sourcez();
  inline void clear_has_sourcez();
  inline void set_has_targetz();
  inline void clear_has_targetz();
  inline void set_has_sourceangle();
  inline void clear_has_sourceangle();
  inline void set_has_targetangle();
  inline void clear_has_targetangle();
  inline void set_has_sourceradius();
  inline void clear_has_sourceradius();
  inline void set_has_targetradius();
  inline void clear_has_targetradius();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float sourcex_;
  ::google::protobuf::int32 sourcelayer_;
  float targetx_;
  ::google::protobuf::int32 targetlayer_;
  ::google::protobuf::int32 usecount_;
  bool channel_;
  ::google::protobuf::int32 portaltype_;
  ::google::protobuf::int32 targetdungeonid_;
  ::google::protobuf::int32 targetspawnindex_;
  ::google::protobuf::int32 targetdirection_;
  float sourcez_;
  float targetz_;
  float sourceangle_;
  float targetangle_;
  float sourceradius_;
  float targetradius_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(16 + 31) / 32];

  friend void  protobuf_AddDesc_MapDataV1Data_2eproto();
  friend void protobuf_AssignDesc_MapDataV1Data_2eproto();
  friend void protobuf_ShutdownFile_MapDataV1Data_2eproto();

  void InitAsDefaultInstance();
  static MapDataPortalInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class MapDataTrapInfoV1 : public ::google::protobuf::Message {
 public:
  MapDataTrapInfoV1();
  virtual ~MapDataTrapInfoV1();

  MapDataTrapInfoV1(const MapDataTrapInfoV1& from);

  inline MapDataTrapInfoV1& operator=(const MapDataTrapInfoV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataTrapInfoV1& default_instance();

  void Swap(MapDataTrapInfoV1* other);

  // implements Message ----------------------------------------------

  MapDataTrapInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataTrapInfoV1& from);
  void MergeFrom(const MapDataTrapInfoV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 TrapID = 1 [default = 0];
  inline bool has_trapid() const;
  inline void clear_trapid();
  static const int kTrapIDFieldNumber = 1;
  inline ::google::protobuf::int32 trapid() const;
  inline void set_trapid(::google::protobuf::int32 value);

  // optional float X = 2 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline float x() const;
  inline void set_x(float value);

  // optional float Y = 4 [default = 0];
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 4;
  inline float y() const;
  inline void set_y(float value);

  // optional sint32 Direction = 5 [default = 1];
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 5;
  inline ::google::protobuf::int32 direction() const;
  inline void set_direction(::google::protobuf::int32 value);

  // optional float Z = 6 [default = 0];
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 6;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:MapDataTrapInfoV1)
 private:
  inline void set_has_trapid();
  inline void clear_has_trapid();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 trapid_;
  float x_;
  float y_;
  ::google::protobuf::int32 direction_;
  float z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_MapDataV1Data_2eproto();
  friend void protobuf_AssignDesc_MapDataV1Data_2eproto();
  friend void protobuf_ShutdownFile_MapDataV1Data_2eproto();

  void InitAsDefaultInstance();
  static MapDataTrapInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class MapDataNpcInfoV1 : public ::google::protobuf::Message {
 public:
  MapDataNpcInfoV1();
  virtual ~MapDataNpcInfoV1();

  MapDataNpcInfoV1(const MapDataNpcInfoV1& from);

  inline MapDataNpcInfoV1& operator=(const MapDataNpcInfoV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataNpcInfoV1& default_instance();

  void Swap(MapDataNpcInfoV1* other);

  // implements Message ----------------------------------------------

  MapDataNpcInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataNpcInfoV1& from);
  void MergeFrom(const MapDataNpcInfoV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 NpcID = 1 [default = 0];
  inline bool has_npcid() const;
  inline void clear_npcid();
  static const int kNpcIDFieldNumber = 1;
  inline ::google::protobuf::int32 npcid() const;
  inline void set_npcid(::google::protobuf::int32 value);

  // optional float X = 2 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline float x() const;
  inline void set_x(float value);

  // optional sint32 Layer = 3 [default = 0];
  inline bool has_layer() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 3;
  inline ::google::protobuf::int32 layer() const;
  inline void set_layer(::google::protobuf::int32 value);

  // optional float Z = 4 [default = 0];
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 4;
  inline float z() const;
  inline void set_z(float value);

  // optional sint32 Direction = 5 [default = 1];
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 5;
  inline ::google::protobuf::int32 direction() const;
  inline void set_direction(::google::protobuf::int32 value);

  // optional float Angle = 6 [default = 0];
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 6;
  inline float angle() const;
  inline void set_angle(float value);

  // optional float Radius = 7 [default = 0];
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 7;
  inline float radius() const;
  inline void set_radius(float value);

  // @@protoc_insertion_point(class_scope:MapDataNpcInfoV1)
 private:
  inline void set_has_npcid();
  inline void clear_has_npcid();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_layer();
  inline void clear_has_layer();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_radius();
  inline void clear_has_radius();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 npcid_;
  float x_;
  ::google::protobuf::int32 layer_;
  float z_;
  ::google::protobuf::int32 direction_;
  float angle_;
  float radius_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_MapDataV1Data_2eproto();
  friend void protobuf_AssignDesc_MapDataV1Data_2eproto();
  friend void protobuf_ShutdownFile_MapDataV1Data_2eproto();

  void InitAsDefaultInstance();
  static MapDataNpcInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class MapDataMonsterInfoV1 : public ::google::protobuf::Message {
 public:
  MapDataMonsterInfoV1();
  virtual ~MapDataMonsterInfoV1();

  MapDataMonsterInfoV1(const MapDataMonsterInfoV1& from);

  inline MapDataMonsterInfoV1& operator=(const MapDataMonsterInfoV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataMonsterInfoV1& default_instance();

  void Swap(MapDataMonsterInfoV1* other);

  // implements Message ----------------------------------------------

  MapDataMonsterInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataMonsterInfoV1& from);
  void MergeFrom(const MapDataMonsterInfoV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 MonsterID = 1 [default = 0];
  inline bool has_monsterid() const;
  inline void clear_monsterid();
  static const int kMonsterIDFieldNumber = 1;
  inline ::google::protobuf::int32 monsterid() const;
  inline void set_monsterid(::google::protobuf::int32 value);

  // optional float X = 2 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline float x() const;
  inline void set_x(float value);

  // optional sint32 Layer = 3 [default = 0];
  inline bool has_layer() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 3;
  inline ::google::protobuf::int32 layer() const;
  inline void set_layer(::google::protobuf::int32 value);

  // optional sint32 RepeatCount = 4 [default = 1];
  inline bool has_repeatcount() const;
  inline void clear_repeatcount();
  static const int kRepeatCountFieldNumber = 4;
  inline ::google::protobuf::int32 repeatcount() const;
  inline void set_repeatcount(::google::protobuf::int32 value);

  // optional sint32 SpawmTriggerType = 5 [default = 0];
  inline bool has_spawmtriggertype() const;
  inline void clear_spawmtriggertype();
  static const int kSpawmTriggerTypeFieldNumber = 5;
  inline ::google::protobuf::int32 spawmtriggertype() const;
  inline void set_spawmtriggertype(::google::protobuf::int32 value);

  // optional sint32 RespawmTriggerType = 6 [default = 0];
  inline bool has_respawmtriggertype() const;
  inline void clear_respawmtriggertype();
  static const int kRespawmTriggerTypeFieldNumber = 6;
  inline ::google::protobuf::int32 respawmtriggertype() const;
  inline void set_respawmtriggertype(::google::protobuf::int32 value);

  // optional float PatrolX1 = 11 [default = -1];
  inline bool has_patrolx1() const;
  inline void clear_patrolx1();
  static const int kPatrolX1FieldNumber = 11;
  inline float patrolx1() const;
  inline void set_patrolx1(float value);

  // optional float PatrolX2 = 13 [default = -1];
  inline bool has_patrolx2() const;
  inline void clear_patrolx2();
  static const int kPatrolX2FieldNumber = 13;
  inline float patrolx2() const;
  inline void set_patrolx2(float value);

  // optional float SpawnNodeTime = 14 [default = 0];
  inline bool has_spawnnodetime() const;
  inline void clear_spawnnodetime();
  static const int kSpawnNodeTimeFieldNumber = 14;
  inline float spawnnodetime() const;
  inline void set_spawnnodetime(float value);

  // optional sint32 SpawnKillEnemyID = 15 [default = 0];
  inline bool has_spawnkillenemyid() const;
  inline void clear_spawnkillenemyid();
  static const int kSpawnKillEnemyIDFieldNumber = 15;
  inline ::google::protobuf::int32 spawnkillenemyid() const;
  inline void set_spawnkillenemyid(::google::protobuf::int32 value);

  // optional sint32 SpawnKillEnemyCount = 16 [default = 0];
  inline bool has_spawnkillenemycount() const;
  inline void clear_spawnkillenemycount();
  static const int kSpawnKillEnemyCountFieldNumber = 16;
  inline ::google::protobuf::int32 spawnkillenemycount() const;
  inline void set_spawnkillenemycount(::google::protobuf::int32 value);

  // optional float SpawnAfterDeathTime = 17 [default = 0];
  inline bool has_spawnafterdeathtime() const;
  inline void clear_spawnafterdeathtime();
  static const int kSpawnAfterDeathTimeFieldNumber = 17;
  inline float spawnafterdeathtime() const;
  inline void set_spawnafterdeathtime(float value);

  // optional float RespawnNodeTime = 18 [default = 0];
  inline bool has_respawnnodetime() const;
  inline void clear_respawnnodetime();
  static const int kRespawnNodeTimeFieldNumber = 18;
  inline float respawnnodetime() const;
  inline void set_respawnnodetime(float value);

  // optional sint32 RespawnKillEnemyID = 19 [default = 0];
  inline bool has_respawnkillenemyid() const;
  inline void clear_respawnkillenemyid();
  static const int kRespawnKillEnemyIDFieldNumber = 19;
  inline ::google::protobuf::int32 respawnkillenemyid() const;
  inline void set_respawnkillenemyid(::google::protobuf::int32 value);

  // optional sint32 RespawnKillEnemyCount = 20 [default = 0];
  inline bool has_respawnkillenemycount() const;
  inline void clear_respawnkillenemycount();
  static const int kRespawnKillEnemyCountFieldNumber = 20;
  inline ::google::protobuf::int32 respawnkillenemycount() const;
  inline void set_respawnkillenemycount(::google::protobuf::int32 value);

  // optional float RespawnAfterDeathTime = 21 [default = 0];
  inline bool has_respawnafterdeathtime() const;
  inline void clear_respawnafterdeathtime();
  static const int kRespawnAfterDeathTimeFieldNumber = 21;
  inline float respawnafterdeathtime() const;
  inline void set_respawnafterdeathtime(float value);

  // optional sint32 CreateMonsterType = 22 [default = 0];
  inline bool has_createmonstertype() const;
  inline void clear_createmonstertype();
  static const int kCreateMonsterTypeFieldNumber = 22;
  inline ::google::protobuf::int32 createmonstertype() const;
  inline void set_createmonstertype(::google::protobuf::int32 value);

  // repeated .MapDataNodeMonsterInfoV1 NodeMonsterInfoArr = 24;
  inline int nodemonsterinfoarr_size() const;
  inline void clear_nodemonsterinfoarr();
  static const int kNodeMonsterInfoArrFieldNumber = 24;
  inline const ::MapDataNodeMonsterInfoV1& nodemonsterinfoarr(int index) const;
  inline ::MapDataNodeMonsterInfoV1* mutable_nodemonsterinfoarr(int index);
  inline ::MapDataNodeMonsterInfoV1* add_nodemonsterinfoarr();
  inline const ::google::protobuf::RepeatedPtrField< ::MapDataNodeMonsterInfoV1 >&
      nodemonsterinfoarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapDataNodeMonsterInfoV1 >*
      mutable_nodemonsterinfoarr();

  // optional float Z = 25 [default = 0];
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 25;
  inline float z() const;
  inline void set_z(float value);

  // optional sint32 Direction = 26 [default = 1];
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 26;
  inline ::google::protobuf::int32 direction() const;
  inline void set_direction(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MapDataMonsterInfoV1)
 private:
  inline void set_has_monsterid();
  inline void clear_has_monsterid();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_layer();
  inline void clear_has_layer();
  inline void set_has_repeatcount();
  inline void clear_has_repeatcount();
  inline void set_has_spawmtriggertype();
  inline void clear_has_spawmtriggertype();
  inline void set_has_respawmtriggertype();
  inline void clear_has_respawmtriggertype();
  inline void set_has_patrolx1();
  inline void clear_has_patrolx1();
  inline void set_has_patrolx2();
  inline void clear_has_patrolx2();
  inline void set_has_spawnnodetime();
  inline void clear_has_spawnnodetime();
  inline void set_has_spawnkillenemyid();
  inline void clear_has_spawnkillenemyid();
  inline void set_has_spawnkillenemycount();
  inline void clear_has_spawnkillenemycount();
  inline void set_has_spawnafterdeathtime();
  inline void clear_has_spawnafterdeathtime();
  inline void set_has_respawnnodetime();
  inline void clear_has_respawnnodetime();
  inline void set_has_respawnkillenemyid();
  inline void clear_has_respawnkillenemyid();
  inline void set_has_respawnkillenemycount();
  inline void clear_has_respawnkillenemycount();
  inline void set_has_respawnafterdeathtime();
  inline void clear_has_respawnafterdeathtime();
  inline void set_has_createmonstertype();
  inline void clear_has_createmonstertype();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_direction();
  inline void clear_has_direction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 monsterid_;
  float x_;
  ::google::protobuf::int32 layer_;
  ::google::protobuf::int32 repeatcount_;
  ::google::protobuf::int32 spawmtriggertype_;
  ::google::protobuf::int32 respawmtriggertype_;
  float patrolx1_;
  float patrolx2_;
  float spawnnodetime_;
  ::google::protobuf::int32 spawnkillenemyid_;
  ::google::protobuf::int32 spawnkillenemycount_;
  float spawnafterdeathtime_;
  float respawnnodetime_;
  ::google::protobuf::int32 respawnkillenemyid_;
  ::google::protobuf::int32 respawnkillenemycount_;
  float respawnafterdeathtime_;
  ::google::protobuf::RepeatedPtrField< ::MapDataNodeMonsterInfoV1 > nodemonsterinfoarr_;
  ::google::protobuf::int32 createmonstertype_;
  float z_;
  ::google::protobuf::int32 direction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(20 + 31) / 32];

  friend void  protobuf_AddDesc_MapDataV1Data_2eproto();
  friend void protobuf_AssignDesc_MapDataV1Data_2eproto();
  friend void protobuf_ShutdownFile_MapDataV1Data_2eproto();

  void InitAsDefaultInstance();
  static MapDataMonsterInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class MapDataNodeInfoV1 : public ::google::protobuf::Message {
 public:
  MapDataNodeInfoV1();
  virtual ~MapDataNodeInfoV1();

  MapDataNodeInfoV1(const MapDataNodeInfoV1& from);

  inline MapDataNodeInfoV1& operator=(const MapDataNodeInfoV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataNodeInfoV1& default_instance();

  void Swap(MapDataNodeInfoV1* other);

  // implements Message ----------------------------------------------

  MapDataNodeInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataNodeInfoV1& from);
  void MergeFrom(const MapDataNodeInfoV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float X = 1 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional sint32 Layer = 2 [default = 0];
  inline bool has_layer() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 2;
  inline ::google::protobuf::int32 layer() const;
  inline void set_layer(::google::protobuf::int32 value);

  // optional sint32 PassCondition = 3 [default = 0];
  inline bool has_passcondition() const;
  inline void clear_passcondition();
  static const int kPassConditionFieldNumber = 3;
  inline ::google::protobuf::int32 passcondition() const;
  inline void set_passcondition(::google::protobuf::int32 value);

  // optional sint32 KillEnemyID = 4 [default = 0];
  inline bool has_killenemyid() const;
  inline void clear_killenemyid();
  static const int kKillEnemyIDFieldNumber = 4;
  inline ::google::protobuf::int32 killenemyid() const;
  inline void set_killenemyid(::google::protobuf::int32 value);

  // optional sint32 KillEnemyCount = 5 [default = 0];
  inline bool has_killenemycount() const;
  inline void clear_killenemycount();
  static const int kKillEnemyCountFieldNumber = 5;
  inline ::google::protobuf::int32 killenemycount() const;
  inline void set_killenemycount(::google::protobuf::int32 value);

  // repeated .MapDataMonsterInfoV1 MonsterArr = 6;
  inline int monsterarr_size() const;
  inline void clear_monsterarr();
  static const int kMonsterArrFieldNumber = 6;
  inline const ::MapDataMonsterInfoV1& monsterarr(int index) const;
  inline ::MapDataMonsterInfoV1* mutable_monsterarr(int index);
  inline ::MapDataMonsterInfoV1* add_monsterarr();
  inline const ::google::protobuf::RepeatedPtrField< ::MapDataMonsterInfoV1 >&
      monsterarr() const;
  inline ::google::protobuf::RepeatedPtrField< ::MapDataMonsterInfoV1 >*
      mutable_monsterarr();

  // optional float TimeLimit = 7 [default = 0];
  inline bool has_timelimit() const;
  inline void clear_timelimit();
  static const int kTimeLimitFieldNumber = 7;
  inline float timelimit() const;
  inline void set_timelimit(float value);

  // optional sint32 NodeType = 8 [default = 0];
  inline bool has_nodetype() const;
  inline void clear_nodetype();
  static const int kNodeTypeFieldNumber = 8;
  inline ::google::protobuf::int32 nodetype() const;
  inline void set_nodetype(::google::protobuf::int32 value);

  // optional sint32 NodeArrowDisplayType = 9 [default = 0];
  inline bool has_nodearrowdisplaytype() const;
  inline void clear_nodearrowdisplaytype();
  static const int kNodeArrowDisplayTypeFieldNumber = 9;
  inline ::google::protobuf::int32 nodearrowdisplaytype() const;
  inline void set_nodearrowdisplaytype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MapDataNodeInfoV1)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_layer();
  inline void clear_has_layer();
  inline void set_has_passcondition();
  inline void clear_has_passcondition();
  inline void set_has_killenemyid();
  inline void clear_has_killenemyid();
  inline void set_has_killenemycount();
  inline void clear_has_killenemycount();
  inline void set_has_timelimit();
  inline void clear_has_timelimit();
  inline void set_has_nodetype();
  inline void clear_has_nodetype();
  inline void set_has_nodearrowdisplaytype();
  inline void clear_has_nodearrowdisplaytype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  ::google::protobuf::int32 layer_;
  ::google::protobuf::int32 passcondition_;
  ::google::protobuf::int32 killenemyid_;
  ::google::protobuf::RepeatedPtrField< ::MapDataMonsterInfoV1 > monsterarr_;
  ::google::protobuf::int32 killenemycount_;
  float timelimit_;
  ::google::protobuf::int32 nodetype_;
  ::google::protobuf::int32 nodearrowdisplaytype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_MapDataV1Data_2eproto();
  friend void protobuf_AssignDesc_MapDataV1Data_2eproto();
  friend void protobuf_ShutdownFile_MapDataV1Data_2eproto();

  void InitAsDefaultInstance();
  static MapDataNodeInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class MapDataTerritorialInfoV1 : public ::google::protobuf::Message {
 public:
  MapDataTerritorialInfoV1();
  virtual ~MapDataTerritorialInfoV1();

  MapDataTerritorialInfoV1(const MapDataTerritorialInfoV1& from);

  inline MapDataTerritorialInfoV1& operator=(const MapDataTerritorialInfoV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataTerritorialInfoV1& default_instance();

  void Swap(MapDataTerritorialInfoV1* other);

  // implements Message ----------------------------------------------

  MapDataTerritorialInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataTerritorialInfoV1& from);
  void MergeFrom(const MapDataTerritorialInfoV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 Layer = 1 [default = 0];
  inline bool has_layer() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 1;
  inline ::google::protobuf::int32 layer() const;
  inline void set_layer(::google::protobuf::int32 value);

  // optional .MapDataVector2V1 Area = 2;
  inline bool has_area() const;
  inline void clear_area();
  static const int kAreaFieldNumber = 2;
  inline const ::MapDataVector2V1& area() const;
  inline ::MapDataVector2V1* mutable_area();
  inline ::MapDataVector2V1* release_area();
  inline void set_allocated_area(::MapDataVector2V1* area);

  // optional float X = 3 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 3;
  inline float x() const;
  inline void set_x(float value);

  // optional sint32 ID = 4 [default = 0];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIDFieldNumber = 4;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string ModelName = 5;
  inline bool has_modelname() const;
  inline void clear_modelname();
  static const int kModelNameFieldNumber = 5;
  inline const ::std::string& modelname() const;
  inline void set_modelname(const ::std::string& value);
  inline void set_modelname(const char* value);
  inline void set_modelname(const char* value, size_t size);
  inline ::std::string* mutable_modelname();
  inline ::std::string* release_modelname();
  inline void set_allocated_modelname(::std::string* modelname);

  // @@protoc_insertion_point(class_scope:MapDataTerritorialInfoV1)
 private:
  inline void set_has_layer();
  inline void clear_has_layer();
  inline void set_has_area();
  inline void clear_has_area();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_modelname();
  inline void clear_has_modelname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::MapDataVector2V1* area_;
  ::google::protobuf::int32 layer_;
  float x_;
  ::std::string* modelname_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_MapDataV1Data_2eproto();
  friend void protobuf_AssignDesc_MapDataV1Data_2eproto();
  friend void protobuf_ShutdownFile_MapDataV1Data_2eproto();

  void InitAsDefaultInstance();
  static MapDataTerritorialInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class MapDataNodeMonsterInfoV1 : public ::google::protobuf::Message {
 public:
  MapDataNodeMonsterInfoV1();
  virtual ~MapDataNodeMonsterInfoV1();

  MapDataNodeMonsterInfoV1(const MapDataNodeMonsterInfoV1& from);

  inline MapDataNodeMonsterInfoV1& operator=(const MapDataNodeMonsterInfoV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataNodeMonsterInfoV1& default_instance();

  void Swap(MapDataNodeMonsterInfoV1* other);

  // implements Message ----------------------------------------------

  MapDataNodeMonsterInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataNodeMonsterInfoV1& from);
  void MergeFrom(const MapDataNodeMonsterInfoV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 MonsterId = 1 [default = -1];
  inline bool has_monsterid() const;
  inline void clear_monsterid();
  static const int kMonsterIdFieldNumber = 1;
  inline ::google::protobuf::int32 monsterid() const;
  inline void set_monsterid(::google::protobuf::int32 value);

  // optional sint32 RandomWeight = 2 [default = -1];
  inline bool has_randomweight() const;
  inline void clear_randomweight();
  static const int kRandomWeightFieldNumber = 2;
  inline ::google::protobuf::int32 randomweight() const;
  inline void set_randomweight(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MapDataNodeMonsterInfoV1)
 private:
  inline void set_has_monsterid();
  inline void clear_has_monsterid();
  inline void set_has_randomweight();
  inline void clear_has_randomweight();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 monsterid_;
  ::google::protobuf::int32 randomweight_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MapDataV1Data_2eproto();
  friend void protobuf_AssignDesc_MapDataV1Data_2eproto();
  friend void protobuf_ShutdownFile_MapDataV1Data_2eproto();

  void InitAsDefaultInstance();
  static MapDataNodeMonsterInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class MapDataBaseConfigV1 : public ::google::protobuf::Message {
 public:
  MapDataBaseConfigV1();
  virtual ~MapDataBaseConfigV1();

  MapDataBaseConfigV1(const MapDataBaseConfigV1& from);

  inline MapDataBaseConfigV1& operator=(const MapDataBaseConfigV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataBaseConfigV1& default_instance();

  void Swap(MapDataBaseConfigV1* other);

  // implements Message ----------------------------------------------

  MapDataBaseConfigV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataBaseConfigV1& from);
  void MergeFrom(const MapDataBaseConfigV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 MapType = 1 [default = 0];
  inline bool has_maptype() const;
  inline void clear_maptype();
  static const int kMapTypeFieldNumber = 1;
  inline ::google::protobuf::int32 maptype() const;
  inline void set_maptype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MapDataBaseConfigV1)
 private:
  inline void set_has_maptype();
  inline void clear_has_maptype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 maptype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MapDataV1Data_2eproto();
  friend void protobuf_AssignDesc_MapDataV1Data_2eproto();
  friend void protobuf_ShutdownFile_MapDataV1Data_2eproto();

  void InitAsDefaultInstance();
  static MapDataBaseConfigV1* default_instance_;
};
// -------------------------------------------------------------------

class MapDataGatherInfoV1 : public ::google::protobuf::Message {
 public:
  MapDataGatherInfoV1();
  virtual ~MapDataGatherInfoV1();

  MapDataGatherInfoV1(const MapDataGatherInfoV1& from);

  inline MapDataGatherInfoV1& operator=(const MapDataGatherInfoV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataGatherInfoV1& default_instance();

  void Swap(MapDataGatherInfoV1* other);

  // implements Message ----------------------------------------------

  MapDataGatherInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataGatherInfoV1& from);
  void MergeFrom(const MapDataGatherInfoV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 GatherId = 1 [default = 0];
  inline bool has_gatherid() const;
  inline void clear_gatherid();
  static const int kGatherIdFieldNumber = 1;
  inline ::google::protobuf::int32 gatherid() const;
  inline void set_gatherid(::google::protobuf::int32 value);

  // optional float X = 2 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 2;
  inline float x() const;
  inline void set_x(float value);

  // optional sint32 Layer = 3 [default = 0];
  inline bool has_layer() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 3;
  inline ::google::protobuf::int32 layer() const;
  inline void set_layer(::google::protobuf::int32 value);

  // optional float Z = 4 [default = 0];
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 4;
  inline float z() const;
  inline void set_z(float value);

  // optional sint32 Direction = 5 [default = 1];
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 5;
  inline ::google::protobuf::int32 direction() const;
  inline void set_direction(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MapDataGatherInfoV1)
 private:
  inline void set_has_gatherid();
  inline void clear_has_gatherid();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_layer();
  inline void clear_has_layer();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_direction();
  inline void clear_has_direction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 gatherid_;
  float x_;
  ::google::protobuf::int32 layer_;
  float z_;
  ::google::protobuf::int32 direction_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_MapDataV1Data_2eproto();
  friend void protobuf_AssignDesc_MapDataV1Data_2eproto();
  friend void protobuf_ShutdownFile_MapDataV1Data_2eproto();

  void InitAsDefaultInstance();
  static MapDataGatherInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class MapDataContourLineInfoV1 : public ::google::protobuf::Message {
 public:
  MapDataContourLineInfoV1();
  virtual ~MapDataContourLineInfoV1();

  MapDataContourLineInfoV1(const MapDataContourLineInfoV1& from);

  inline MapDataContourLineInfoV1& operator=(const MapDataContourLineInfoV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataContourLineInfoV1& default_instance();

  void Swap(MapDataContourLineInfoV1* other);

  // implements Message ----------------------------------------------

  MapDataContourLineInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataContourLineInfoV1& from);
  void MergeFrom(const MapDataContourLineInfoV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float Y = 1 [default = -1];
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 1;
  inline float y() const;
  inline void set_y(float value);

  // @@protoc_insertion_point(class_scope:MapDataContourLineInfoV1)
 private:
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MapDataV1Data_2eproto();
  friend void protobuf_AssignDesc_MapDataV1Data_2eproto();
  friend void protobuf_ShutdownFile_MapDataV1Data_2eproto();

  void InitAsDefaultInstance();
  static MapDataContourLineInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class MapDataEventInfoV1 : public ::google::protobuf::Message {
 public:
  MapDataEventInfoV1();
  virtual ~MapDataEventInfoV1();

  MapDataEventInfoV1(const MapDataEventInfoV1& from);

  inline MapDataEventInfoV1& operator=(const MapDataEventInfoV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MapDataEventInfoV1& default_instance();

  void Swap(MapDataEventInfoV1* other);

  // implements Message ----------------------------------------------

  MapDataEventInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MapDataEventInfoV1& from);
  void MergeFrom(const MapDataEventInfoV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float X1 = 1 [default = 0];
  inline bool has_x1() const;
  inline void clear_x1();
  static const int kX1FieldNumber = 1;
  inline float x1() const;
  inline void set_x1(float value);

  // optional float Z1 = 2 [default = 0];
  inline bool has_z1() const;
  inline void clear_z1();
  static const int kZ1FieldNumber = 2;
  inline float z1() const;
  inline void set_z1(float value);

  // optional float X2 = 3 [default = 0];
  inline bool has_x2() const;
  inline void clear_x2();
  static const int kX2FieldNumber = 3;
  inline float x2() const;
  inline void set_x2(float value);

  // optional float Z2 = 4 [default = 0];
  inline bool has_z2() const;
  inline void clear_z2();
  static const int kZ2FieldNumber = 4;
  inline float z2() const;
  inline void set_z2(float value);

  // optional sint32 Type = 5 [default = 0];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional sint32 EventId = 6 [default = 0];
  inline bool has_eventid() const;
  inline void clear_eventid();
  static const int kEventIdFieldNumber = 6;
  inline ::google::protobuf::int32 eventid() const;
  inline void set_eventid(::google::protobuf::int32 value);

  // optional sint32 Layer = 7 [default = 0];
  inline bool has_layer() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 7;
  inline ::google::protobuf::int32 layer() const;
  inline void set_layer(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:MapDataEventInfoV1)
 private:
  inline void set_has_x1();
  inline void clear_has_x1();
  inline void set_has_z1();
  inline void clear_has_z1();
  inline void set_has_x2();
  inline void clear_has_x2();
  inline void set_has_z2();
  inline void clear_has_z2();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_eventid();
  inline void clear_has_eventid();
  inline void set_has_layer();
  inline void clear_has_layer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x1_;
  float z1_;
  float x2_;
  float z2_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 eventid_;
  ::google::protobuf::int32 layer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_MapDataV1Data_2eproto();
  friend void protobuf_AssignDesc_MapDataV1Data_2eproto();
  friend void protobuf_ShutdownFile_MapDataV1Data_2eproto();

  void InitAsDefaultInstance();
  static MapDataEventInfoV1* default_instance_;
};
// ===================================================================


// ===================================================================

// MapDataUselessV1

// optional sint32 X1 = 1 [default = -1];
inline bool MapDataUselessV1::has_x1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapDataUselessV1::set_has_x1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapDataUselessV1::clear_has_x1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapDataUselessV1::clear_x1() {
  x1_ = -1;
  clear_has_x1();
}
inline ::google::protobuf::int32 MapDataUselessV1::x1() const {
  return x1_;
}
inline void MapDataUselessV1::set_x1(::google::protobuf::int32 value) {
  set_has_x1();
  x1_ = value;
}

// -------------------------------------------------------------------

// MapDataLayerInfoV1

// repeated .MapDataVector2V1 WalkArea = 2;
inline int MapDataLayerInfoV1::walkarea_size() const {
  return walkarea_.size();
}
inline void MapDataLayerInfoV1::clear_walkarea() {
  walkarea_.Clear();
}
inline const ::MapDataVector2V1& MapDataLayerInfoV1::walkarea(int index) const {
  return walkarea_.Get(index);
}
inline ::MapDataVector2V1* MapDataLayerInfoV1::mutable_walkarea(int index) {
  return walkarea_.Mutable(index);
}
inline ::MapDataVector2V1* MapDataLayerInfoV1::add_walkarea() {
  return walkarea_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapDataVector2V1 >&
MapDataLayerInfoV1::walkarea() const {
  return walkarea_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapDataVector2V1 >*
MapDataLayerInfoV1::mutable_walkarea() {
  return &walkarea_;
}

// repeated .MapDataVector2V1 LostArea = 3;
inline int MapDataLayerInfoV1::lostarea_size() const {
  return lostarea_.size();
}
inline void MapDataLayerInfoV1::clear_lostarea() {
  lostarea_.Clear();
}
inline const ::MapDataVector2V1& MapDataLayerInfoV1::lostarea(int index) const {
  return lostarea_.Get(index);
}
inline ::MapDataVector2V1* MapDataLayerInfoV1::mutable_lostarea(int index) {
  return lostarea_.Mutable(index);
}
inline ::MapDataVector2V1* MapDataLayerInfoV1::add_lostarea() {
  return lostarea_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapDataVector2V1 >&
MapDataLayerInfoV1::lostarea() const {
  return lostarea_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapDataVector2V1 >*
MapDataLayerInfoV1::mutable_lostarea() {
  return &lostarea_;
}

// optional float ClientHight = 4 [default = 0];
inline bool MapDataLayerInfoV1::has_clienthight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapDataLayerInfoV1::set_has_clienthight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapDataLayerInfoV1::clear_has_clienthight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapDataLayerInfoV1::clear_clienthight() {
  clienthight_ = 0;
  clear_has_clienthight();
}
inline float MapDataLayerInfoV1::clienthight() const {
  return clienthight_;
}
inline void MapDataLayerInfoV1::set_clienthight(float value) {
  set_has_clienthight();
  clienthight_ = value;
}

// optional float X = 5 [default = 0];
inline bool MapDataLayerInfoV1::has_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapDataLayerInfoV1::set_has_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapDataLayerInfoV1::clear_has_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapDataLayerInfoV1::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float MapDataLayerInfoV1::x() const {
  return x_;
}
inline void MapDataLayerInfoV1::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float Z = 6 [default = 0];
inline bool MapDataLayerInfoV1::has_z() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapDataLayerInfoV1::set_has_z() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapDataLayerInfoV1::clear_has_z() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapDataLayerInfoV1::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float MapDataLayerInfoV1::z() const {
  return z_;
}
inline void MapDataLayerInfoV1::set_z(float value) {
  set_has_z();
  z_ = value;
}

// optional float Y = 7 [default = 0];
inline bool MapDataLayerInfoV1::has_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapDataLayerInfoV1::set_has_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapDataLayerInfoV1::clear_has_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MapDataLayerInfoV1::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float MapDataLayerInfoV1::y() const {
  return y_;
}
inline void MapDataLayerInfoV1::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional float MinHeightLimit = 9 [default = 0];
inline bool MapDataLayerInfoV1::has_minheightlimit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MapDataLayerInfoV1::set_has_minheightlimit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MapDataLayerInfoV1::clear_has_minheightlimit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MapDataLayerInfoV1::clear_minheightlimit() {
  minheightlimit_ = 0;
  clear_has_minheightlimit();
}
inline float MapDataLayerInfoV1::minheightlimit() const {
  return minheightlimit_;
}
inline void MapDataLayerInfoV1::set_minheightlimit(float value) {
  set_has_minheightlimit();
  minheightlimit_ = value;
}

// optional float MaxHeightLimit = 10 [default = 0];
inline bool MapDataLayerInfoV1::has_maxheightlimit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MapDataLayerInfoV1::set_has_maxheightlimit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MapDataLayerInfoV1::clear_has_maxheightlimit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MapDataLayerInfoV1::clear_maxheightlimit() {
  maxheightlimit_ = 0;
  clear_has_maxheightlimit();
}
inline float MapDataLayerInfoV1::maxheightlimit() const {
  return maxheightlimit_;
}
inline void MapDataLayerInfoV1::set_maxheightlimit(float value) {
  set_has_maxheightlimit();
  maxheightlimit_ = value;
}

// -------------------------------------------------------------------

// MapDataInfoV1

// repeated .MapDataLayerInfoV1 LayerArr = 1;
inline int MapDataInfoV1::layerarr_size() const {
  return layerarr_.size();
}
inline void MapDataInfoV1::clear_layerarr() {
  layerarr_.Clear();
}
inline const ::MapDataLayerInfoV1& MapDataInfoV1::layerarr(int index) const {
  return layerarr_.Get(index);
}
inline ::MapDataLayerInfoV1* MapDataInfoV1::mutable_layerarr(int index) {
  return layerarr_.Mutable(index);
}
inline ::MapDataLayerInfoV1* MapDataInfoV1::add_layerarr() {
  return layerarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapDataLayerInfoV1 >&
MapDataInfoV1::layerarr() const {
  return layerarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapDataLayerInfoV1 >*
MapDataInfoV1::mutable_layerarr() {
  return &layerarr_;
}

// repeated .MapDataSpawnInfoV1 SpawnArr = 2;
inline int MapDataInfoV1::spawnarr_size() const {
  return spawnarr_.size();
}
inline void MapDataInfoV1::clear_spawnarr() {
  spawnarr_.Clear();
}
inline const ::MapDataSpawnInfoV1& MapDataInfoV1::spawnarr(int index) const {
  return spawnarr_.Get(index);
}
inline ::MapDataSpawnInfoV1* MapDataInfoV1::mutable_spawnarr(int index) {
  return spawnarr_.Mutable(index);
}
inline ::MapDataSpawnInfoV1* MapDataInfoV1::add_spawnarr() {
  return spawnarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapDataSpawnInfoV1 >&
MapDataInfoV1::spawnarr() const {
  return spawnarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapDataSpawnInfoV1 >*
MapDataInfoV1::mutable_spawnarr() {
  return &spawnarr_;
}

// optional .MapDataDefeatInfoV1 Defeat = 3;
inline bool MapDataInfoV1::has_defeat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapDataInfoV1::set_has_defeat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapDataInfoV1::clear_has_defeat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapDataInfoV1::clear_defeat() {
  if (defeat_ != NULL) defeat_->::MapDataDefeatInfoV1::Clear();
  clear_has_defeat();
}
inline const ::MapDataDefeatInfoV1& MapDataInfoV1::defeat() const {
  return defeat_ != NULL ? *defeat_ : *default_instance_->defeat_;
}
inline ::MapDataDefeatInfoV1* MapDataInfoV1::mutable_defeat() {
  set_has_defeat();
  if (defeat_ == NULL) defeat_ = new ::MapDataDefeatInfoV1;
  return defeat_;
}
inline ::MapDataDefeatInfoV1* MapDataInfoV1::release_defeat() {
  clear_has_defeat();
  ::MapDataDefeatInfoV1* temp = defeat_;
  defeat_ = NULL;
  return temp;
}
inline void MapDataInfoV1::set_allocated_defeat(::MapDataDefeatInfoV1* defeat) {
  delete defeat_;
  defeat_ = defeat;
  if (defeat) {
    set_has_defeat();
  } else {
    clear_has_defeat();
  }
}

// repeated .MapDataPerfectInfoV1 PerfectArr = 4;
inline int MapDataInfoV1::perfectarr_size() const {
  return perfectarr_.size();
}
inline void MapDataInfoV1::clear_perfectarr() {
  perfectarr_.Clear();
}
inline const ::MapDataPerfectInfoV1& MapDataInfoV1::perfectarr(int index) const {
  return perfectarr_.Get(index);
}
inline ::MapDataPerfectInfoV1* MapDataInfoV1::mutable_perfectarr(int index) {
  return perfectarr_.Mutable(index);
}
inline ::MapDataPerfectInfoV1* MapDataInfoV1::add_perfectarr() {
  return perfectarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapDataPerfectInfoV1 >&
MapDataInfoV1::perfectarr() const {
  return perfectarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapDataPerfectInfoV1 >*
MapDataInfoV1::mutable_perfectarr() {
  return &perfectarr_;
}

// repeated .MapDataPortalInfoV1 PortalArr = 5;
inline int MapDataInfoV1::portalarr_size() const {
  return portalarr_.size();
}
inline void MapDataInfoV1::clear_portalarr() {
  portalarr_.Clear();
}
inline const ::MapDataPortalInfoV1& MapDataInfoV1::portalarr(int index) const {
  return portalarr_.Get(index);
}
inline ::MapDataPortalInfoV1* MapDataInfoV1::mutable_portalarr(int index) {
  return portalarr_.Mutable(index);
}
inline ::MapDataPortalInfoV1* MapDataInfoV1::add_portalarr() {
  return portalarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapDataPortalInfoV1 >&
MapDataInfoV1::portalarr() const {
  return portalarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapDataPortalInfoV1 >*
MapDataInfoV1::mutable_portalarr() {
  return &portalarr_;
}

// repeated .MapDataTrapInfoV1 TrapArr = 6;
inline int MapDataInfoV1::traparr_size() const {
  return traparr_.size();
}
inline void MapDataInfoV1::clear_traparr() {
  traparr_.Clear();
}
inline const ::MapDataTrapInfoV1& MapDataInfoV1::traparr(int index) const {
  return traparr_.Get(index);
}
inline ::MapDataTrapInfoV1* MapDataInfoV1::mutable_traparr(int index) {
  return traparr_.Mutable(index);
}
inline ::MapDataTrapInfoV1* MapDataInfoV1::add_traparr() {
  return traparr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapDataTrapInfoV1 >&
MapDataInfoV1::traparr() const {
  return traparr_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapDataTrapInfoV1 >*
MapDataInfoV1::mutable_traparr() {
  return &traparr_;
}

// repeated .MapDataNpcInfoV1 NpcArr = 7;
inline int MapDataInfoV1::npcarr_size() const {
  return npcarr_.size();
}
inline void MapDataInfoV1::clear_npcarr() {
  npcarr_.Clear();
}
inline const ::MapDataNpcInfoV1& MapDataInfoV1::npcarr(int index) const {
  return npcarr_.Get(index);
}
inline ::MapDataNpcInfoV1* MapDataInfoV1::mutable_npcarr(int index) {
  return npcarr_.Mutable(index);
}
inline ::MapDataNpcInfoV1* MapDataInfoV1::add_npcarr() {
  return npcarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapDataNpcInfoV1 >&
MapDataInfoV1::npcarr() const {
  return npcarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapDataNpcInfoV1 >*
MapDataInfoV1::mutable_npcarr() {
  return &npcarr_;
}

// repeated .MapDataNodeInfoV1 NodeArr = 8;
inline int MapDataInfoV1::nodearr_size() const {
  return nodearr_.size();
}
inline void MapDataInfoV1::clear_nodearr() {
  nodearr_.Clear();
}
inline const ::MapDataNodeInfoV1& MapDataInfoV1::nodearr(int index) const {
  return nodearr_.Get(index);
}
inline ::MapDataNodeInfoV1* MapDataInfoV1::mutable_nodearr(int index) {
  return nodearr_.Mutable(index);
}
inline ::MapDataNodeInfoV1* MapDataInfoV1::add_nodearr() {
  return nodearr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapDataNodeInfoV1 >&
MapDataInfoV1::nodearr() const {
  return nodearr_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapDataNodeInfoV1 >*
MapDataInfoV1::mutable_nodearr() {
  return &nodearr_;
}

// optional string Name = 9;
inline bool MapDataInfoV1::has_name() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MapDataInfoV1::set_has_name() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MapDataInfoV1::clear_has_name() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MapDataInfoV1::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MapDataInfoV1::name() const {
  return *name_;
}
inline void MapDataInfoV1::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MapDataInfoV1::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MapDataInfoV1::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapDataInfoV1::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MapDataInfoV1::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapDataInfoV1::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .MapDataTerritorialInfoV1 StormBaseArr = 10;
inline int MapDataInfoV1::stormbasearr_size() const {
  return stormbasearr_.size();
}
inline void MapDataInfoV1::clear_stormbasearr() {
  stormbasearr_.Clear();
}
inline const ::MapDataTerritorialInfoV1& MapDataInfoV1::stormbasearr(int index) const {
  return stormbasearr_.Get(index);
}
inline ::MapDataTerritorialInfoV1* MapDataInfoV1::mutable_stormbasearr(int index) {
  return stormbasearr_.Mutable(index);
}
inline ::MapDataTerritorialInfoV1* MapDataInfoV1::add_stormbasearr() {
  return stormbasearr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapDataTerritorialInfoV1 >&
MapDataInfoV1::stormbasearr() const {
  return stormbasearr_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapDataTerritorialInfoV1 >*
MapDataInfoV1::mutable_stormbasearr() {
  return &stormbasearr_;
}

// optional .MapDataTerritorialInfoV1 StormFlag = 11;
inline bool MapDataInfoV1::has_stormflag() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MapDataInfoV1::set_has_stormflag() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MapDataInfoV1::clear_has_stormflag() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MapDataInfoV1::clear_stormflag() {
  if (stormflag_ != NULL) stormflag_->::MapDataTerritorialInfoV1::Clear();
  clear_has_stormflag();
}
inline const ::MapDataTerritorialInfoV1& MapDataInfoV1::stormflag() const {
  return stormflag_ != NULL ? *stormflag_ : *default_instance_->stormflag_;
}
inline ::MapDataTerritorialInfoV1* MapDataInfoV1::mutable_stormflag() {
  set_has_stormflag();
  if (stormflag_ == NULL) stormflag_ = new ::MapDataTerritorialInfoV1;
  return stormflag_;
}
inline ::MapDataTerritorialInfoV1* MapDataInfoV1::release_stormflag() {
  clear_has_stormflag();
  ::MapDataTerritorialInfoV1* temp = stormflag_;
  stormflag_ = NULL;
  return temp;
}
inline void MapDataInfoV1::set_allocated_stormflag(::MapDataTerritorialInfoV1* stormflag) {
  delete stormflag_;
  stormflag_ = stormflag;
  if (stormflag) {
    set_has_stormflag();
  } else {
    clear_has_stormflag();
  }
}

// optional .MapDataBaseConfigV1 BaseConfig = 12;
inline bool MapDataInfoV1::has_baseconfig() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MapDataInfoV1::set_has_baseconfig() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MapDataInfoV1::clear_has_baseconfig() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MapDataInfoV1::clear_baseconfig() {
  if (baseconfig_ != NULL) baseconfig_->::MapDataBaseConfigV1::Clear();
  clear_has_baseconfig();
}
inline const ::MapDataBaseConfigV1& MapDataInfoV1::baseconfig() const {
  return baseconfig_ != NULL ? *baseconfig_ : *default_instance_->baseconfig_;
}
inline ::MapDataBaseConfigV1* MapDataInfoV1::mutable_baseconfig() {
  set_has_baseconfig();
  if (baseconfig_ == NULL) baseconfig_ = new ::MapDataBaseConfigV1;
  return baseconfig_;
}
inline ::MapDataBaseConfigV1* MapDataInfoV1::release_baseconfig() {
  clear_has_baseconfig();
  ::MapDataBaseConfigV1* temp = baseconfig_;
  baseconfig_ = NULL;
  return temp;
}
inline void MapDataInfoV1::set_allocated_baseconfig(::MapDataBaseConfigV1* baseconfig) {
  delete baseconfig_;
  baseconfig_ = baseconfig;
  if (baseconfig) {
    set_has_baseconfig();
  } else {
    clear_has_baseconfig();
  }
}

// repeated .MapDataGatherInfoV1 GatherArr = 13;
inline int MapDataInfoV1::gatherarr_size() const {
  return gatherarr_.size();
}
inline void MapDataInfoV1::clear_gatherarr() {
  gatherarr_.Clear();
}
inline const ::MapDataGatherInfoV1& MapDataInfoV1::gatherarr(int index) const {
  return gatherarr_.Get(index);
}
inline ::MapDataGatherInfoV1* MapDataInfoV1::mutable_gatherarr(int index) {
  return gatherarr_.Mutable(index);
}
inline ::MapDataGatherInfoV1* MapDataInfoV1::add_gatherarr() {
  return gatherarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapDataGatherInfoV1 >&
MapDataInfoV1::gatherarr() const {
  return gatherarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapDataGatherInfoV1 >*
MapDataInfoV1::mutable_gatherarr() {
  return &gatherarr_;
}

// repeated .MapDataEventInfoV1 EventArr = 14;
inline int MapDataInfoV1::eventarr_size() const {
  return eventarr_.size();
}
inline void MapDataInfoV1::clear_eventarr() {
  eventarr_.Clear();
}
inline const ::MapDataEventInfoV1& MapDataInfoV1::eventarr(int index) const {
  return eventarr_.Get(index);
}
inline ::MapDataEventInfoV1* MapDataInfoV1::mutable_eventarr(int index) {
  return eventarr_.Mutable(index);
}
inline ::MapDataEventInfoV1* MapDataInfoV1::add_eventarr() {
  return eventarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapDataEventInfoV1 >&
MapDataInfoV1::eventarr() const {
  return eventarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapDataEventInfoV1 >*
MapDataInfoV1::mutable_eventarr() {
  return &eventarr_;
}

// -------------------------------------------------------------------

// MapDataVector2V1

// optional float X1 = 1 [default = 0];
inline bool MapDataVector2V1::has_x1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapDataVector2V1::set_has_x1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapDataVector2V1::clear_has_x1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapDataVector2V1::clear_x1() {
  x1_ = 0;
  clear_has_x1();
}
inline float MapDataVector2V1::x1() const {
  return x1_;
}
inline void MapDataVector2V1::set_x1(float value) {
  set_has_x1();
  x1_ = value;
}

// optional float X2 = 2 [default = 0];
inline bool MapDataVector2V1::has_x2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapDataVector2V1::set_has_x2() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapDataVector2V1::clear_has_x2() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapDataVector2V1::clear_x2() {
  x2_ = 0;
  clear_has_x2();
}
inline float MapDataVector2V1::x2() const {
  return x2_;
}
inline void MapDataVector2V1::set_x2(float value) {
  set_has_x2();
  x2_ = value;
}

// optional float Z1 = 4 [default = 0];
inline bool MapDataVector2V1::has_z1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapDataVector2V1::set_has_z1() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapDataVector2V1::clear_has_z1() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapDataVector2V1::clear_z1() {
  z1_ = 0;
  clear_has_z1();
}
inline float MapDataVector2V1::z1() const {
  return z1_;
}
inline void MapDataVector2V1::set_z1(float value) {
  set_has_z1();
  z1_ = value;
}

// optional float Z2 = 5 [default = 0];
inline bool MapDataVector2V1::has_z2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapDataVector2V1::set_has_z2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapDataVector2V1::clear_has_z2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapDataVector2V1::clear_z2() {
  z2_ = 0;
  clear_has_z2();
}
inline float MapDataVector2V1::z2() const {
  return z2_;
}
inline void MapDataVector2V1::set_z2(float value) {
  set_has_z2();
  z2_ = value;
}

// optional float OrgAngle = 7 [default = 0];
inline bool MapDataVector2V1::has_organgle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapDataVector2V1::set_has_organgle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapDataVector2V1::clear_has_organgle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapDataVector2V1::clear_organgle() {
  organgle_ = 0;
  clear_has_organgle();
}
inline float MapDataVector2V1::organgle() const {
  return organgle_;
}
inline void MapDataVector2V1::set_organgle(float value) {
  set_has_organgle();
  organgle_ = value;
}

// optional float FinAngle = 8 [default = 0];
inline bool MapDataVector2V1::has_finangle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapDataVector2V1::set_has_finangle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapDataVector2V1::clear_has_finangle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MapDataVector2V1::clear_finangle() {
  finangle_ = 0;
  clear_has_finangle();
}
inline float MapDataVector2V1::finangle() const {
  return finangle_;
}
inline void MapDataVector2V1::set_finangle(float value) {
  set_has_finangle();
  finangle_ = value;
}

// optional float Radius = 11 [default = 0];
inline bool MapDataVector2V1::has_radius() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MapDataVector2V1::set_has_radius() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MapDataVector2V1::clear_has_radius() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MapDataVector2V1::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float MapDataVector2V1::radius() const {
  return radius_;
}
inline void MapDataVector2V1::set_radius(float value) {
  set_has_radius();
  radius_ = value;
}

// repeated .MapDataContourLineInfoV1 ContourLineArr = 12;
inline int MapDataVector2V1::contourlinearr_size() const {
  return contourlinearr_.size();
}
inline void MapDataVector2V1::clear_contourlinearr() {
  contourlinearr_.Clear();
}
inline const ::MapDataContourLineInfoV1& MapDataVector2V1::contourlinearr(int index) const {
  return contourlinearr_.Get(index);
}
inline ::MapDataContourLineInfoV1* MapDataVector2V1::mutable_contourlinearr(int index) {
  return contourlinearr_.Mutable(index);
}
inline ::MapDataContourLineInfoV1* MapDataVector2V1::add_contourlinearr() {
  return contourlinearr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapDataContourLineInfoV1 >&
MapDataVector2V1::contourlinearr() const {
  return contourlinearr_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapDataContourLineInfoV1 >*
MapDataVector2V1::mutable_contourlinearr() {
  return &contourlinearr_;
}

// -------------------------------------------------------------------

// MapDataSpawnInfoV1

// optional float X = 1 [default = 0];
inline bool MapDataSpawnInfoV1::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapDataSpawnInfoV1::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapDataSpawnInfoV1::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapDataSpawnInfoV1::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float MapDataSpawnInfoV1::x() const {
  return x_;
}
inline void MapDataSpawnInfoV1::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional sint32 Layer = 2 [default = 0];
inline bool MapDataSpawnInfoV1::has_layer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapDataSpawnInfoV1::set_has_layer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapDataSpawnInfoV1::clear_has_layer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapDataSpawnInfoV1::clear_layer() {
  layer_ = 0;
  clear_has_layer();
}
inline ::google::protobuf::int32 MapDataSpawnInfoV1::layer() const {
  return layer_;
}
inline void MapDataSpawnInfoV1::set_layer(::google::protobuf::int32 value) {
  set_has_layer();
  layer_ = value;
}

// optional sint32 SpawnDirection = 3 [default = 1];
inline bool MapDataSpawnInfoV1::has_spawndirection() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapDataSpawnInfoV1::set_has_spawndirection() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapDataSpawnInfoV1::clear_has_spawndirection() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapDataSpawnInfoV1::clear_spawndirection() {
  spawndirection_ = 1;
  clear_has_spawndirection();
}
inline ::google::protobuf::int32 MapDataSpawnInfoV1::spawndirection() const {
  return spawndirection_;
}
inline void MapDataSpawnInfoV1::set_spawndirection(::google::protobuf::int32 value) {
  set_has_spawndirection();
  spawndirection_ = value;
}

// optional float Z = 4 [default = 0];
inline bool MapDataSpawnInfoV1::has_z() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapDataSpawnInfoV1::set_has_z() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapDataSpawnInfoV1::clear_has_z() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapDataSpawnInfoV1::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float MapDataSpawnInfoV1::z() const {
  return z_;
}
inline void MapDataSpawnInfoV1::set_z(float value) {
  set_has_z();
  z_ = value;
}

// optional float Radius = 5 [default = 0];
inline bool MapDataSpawnInfoV1::has_radius() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapDataSpawnInfoV1::set_has_radius() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapDataSpawnInfoV1::clear_has_radius() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapDataSpawnInfoV1::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float MapDataSpawnInfoV1::radius() const {
  return radius_;
}
inline void MapDataSpawnInfoV1::set_radius(float value) {
  set_has_radius();
  radius_ = value;
}

// optional float Angle = 6 [default = 0];
inline bool MapDataSpawnInfoV1::has_angle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapDataSpawnInfoV1::set_has_angle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapDataSpawnInfoV1::clear_has_angle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MapDataSpawnInfoV1::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float MapDataSpawnInfoV1::angle() const {
  return angle_;
}
inline void MapDataSpawnInfoV1::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// -------------------------------------------------------------------

// MapDataDefeatInfoV1

// optional sint32 Condition = 1 [default = 0];
inline bool MapDataDefeatInfoV1::has_condition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapDataDefeatInfoV1::set_has_condition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapDataDefeatInfoV1::clear_has_condition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapDataDefeatInfoV1::clear_condition() {
  condition_ = 0;
  clear_has_condition();
}
inline ::google::protobuf::int32 MapDataDefeatInfoV1::condition() const {
  return condition_;
}
inline void MapDataDefeatInfoV1::set_condition(::google::protobuf::int32 value) {
  set_has_condition();
  condition_ = value;
}

// optional float TimeLimit = 4 [default = 0];
inline bool MapDataDefeatInfoV1::has_timelimit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapDataDefeatInfoV1::set_has_timelimit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapDataDefeatInfoV1::clear_has_timelimit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapDataDefeatInfoV1::clear_timelimit() {
  timelimit_ = 0;
  clear_has_timelimit();
}
inline float MapDataDefeatInfoV1::timelimit() const {
  return timelimit_;
}
inline void MapDataDefeatInfoV1::set_timelimit(float value) {
  set_has_timelimit();
  timelimit_ = value;
}

// -------------------------------------------------------------------

// MapDataPerfectInfoV1

// optional sint32 Condition = 1 [default = -1];
inline bool MapDataPerfectInfoV1::has_condition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapDataPerfectInfoV1::set_has_condition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapDataPerfectInfoV1::clear_has_condition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapDataPerfectInfoV1::clear_condition() {
  condition_ = -1;
  clear_has_condition();
}
inline ::google::protobuf::int32 MapDataPerfectInfoV1::condition() const {
  return condition_;
}
inline void MapDataPerfectInfoV1::set_condition(::google::protobuf::int32 value) {
  set_has_condition();
  condition_ = value;
}

// optional sint32 DeathCountNum = 2 [default = 0];
inline bool MapDataPerfectInfoV1::has_deathcountnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapDataPerfectInfoV1::set_has_deathcountnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapDataPerfectInfoV1::clear_has_deathcountnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapDataPerfectInfoV1::clear_deathcountnum() {
  deathcountnum_ = 0;
  clear_has_deathcountnum();
}
inline ::google::protobuf::int32 MapDataPerfectInfoV1::deathcountnum() const {
  return deathcountnum_;
}
inline void MapDataPerfectInfoV1::set_deathcountnum(::google::protobuf::int32 value) {
  set_has_deathcountnum();
  deathcountnum_ = value;
}

// optional sint32 KillEnemyID = 3 [default = 0];
inline bool MapDataPerfectInfoV1::has_killenemyid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapDataPerfectInfoV1::set_has_killenemyid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapDataPerfectInfoV1::clear_has_killenemyid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapDataPerfectInfoV1::clear_killenemyid() {
  killenemyid_ = 0;
  clear_has_killenemyid();
}
inline ::google::protobuf::int32 MapDataPerfectInfoV1::killenemyid() const {
  return killenemyid_;
}
inline void MapDataPerfectInfoV1::set_killenemyid(::google::protobuf::int32 value) {
  set_has_killenemyid();
  killenemyid_ = value;
}

// optional sint32 KillEnemyCount = 4 [default = 0];
inline bool MapDataPerfectInfoV1::has_killenemycount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapDataPerfectInfoV1::set_has_killenemycount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapDataPerfectInfoV1::clear_has_killenemycount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapDataPerfectInfoV1::clear_killenemycount() {
  killenemycount_ = 0;
  clear_has_killenemycount();
}
inline ::google::protobuf::int32 MapDataPerfectInfoV1::killenemycount() const {
  return killenemycount_;
}
inline void MapDataPerfectInfoV1::set_killenemycount(::google::protobuf::int32 value) {
  set_has_killenemycount();
  killenemycount_ = value;
}

// optional sint32 HpPercent = 5 [default = 0];
inline bool MapDataPerfectInfoV1::has_hppercent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapDataPerfectInfoV1::set_has_hppercent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapDataPerfectInfoV1::clear_has_hppercent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapDataPerfectInfoV1::clear_hppercent() {
  hppercent_ = 0;
  clear_has_hppercent();
}
inline ::google::protobuf::int32 MapDataPerfectInfoV1::hppercent() const {
  return hppercent_;
}
inline void MapDataPerfectInfoV1::set_hppercent(::google::protobuf::int32 value) {
  set_has_hppercent();
  hppercent_ = value;
}

// optional float TimeLimit = 6 [default = 0];
inline bool MapDataPerfectInfoV1::has_timelimit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapDataPerfectInfoV1::set_has_timelimit() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapDataPerfectInfoV1::clear_has_timelimit() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MapDataPerfectInfoV1::clear_timelimit() {
  timelimit_ = 0;
  clear_has_timelimit();
}
inline float MapDataPerfectInfoV1::timelimit() const {
  return timelimit_;
}
inline void MapDataPerfectInfoV1::set_timelimit(float value) {
  set_has_timelimit();
  timelimit_ = value;
}

// -------------------------------------------------------------------

// MapDataPortalInfoV1

// optional float SourceX = 1 [default = 0];
inline bool MapDataPortalInfoV1::has_sourcex() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapDataPortalInfoV1::set_has_sourcex() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapDataPortalInfoV1::clear_has_sourcex() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapDataPortalInfoV1::clear_sourcex() {
  sourcex_ = 0;
  clear_has_sourcex();
}
inline float MapDataPortalInfoV1::sourcex() const {
  return sourcex_;
}
inline void MapDataPortalInfoV1::set_sourcex(float value) {
  set_has_sourcex();
  sourcex_ = value;
}

// optional sint32 SourceLayer = 2 [default = 0];
inline bool MapDataPortalInfoV1::has_sourcelayer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapDataPortalInfoV1::set_has_sourcelayer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapDataPortalInfoV1::clear_has_sourcelayer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapDataPortalInfoV1::clear_sourcelayer() {
  sourcelayer_ = 0;
  clear_has_sourcelayer();
}
inline ::google::protobuf::int32 MapDataPortalInfoV1::sourcelayer() const {
  return sourcelayer_;
}
inline void MapDataPortalInfoV1::set_sourcelayer(::google::protobuf::int32 value) {
  set_has_sourcelayer();
  sourcelayer_ = value;
}

// optional float TargetX = 3 [default = -1];
inline bool MapDataPortalInfoV1::has_targetx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapDataPortalInfoV1::set_has_targetx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapDataPortalInfoV1::clear_has_targetx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapDataPortalInfoV1::clear_targetx() {
  targetx_ = -1;
  clear_has_targetx();
}
inline float MapDataPortalInfoV1::targetx() const {
  return targetx_;
}
inline void MapDataPortalInfoV1::set_targetx(float value) {
  set_has_targetx();
  targetx_ = value;
}

// optional sint32 TargetLayer = 4 [default = -1];
inline bool MapDataPortalInfoV1::has_targetlayer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapDataPortalInfoV1::set_has_targetlayer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapDataPortalInfoV1::clear_has_targetlayer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapDataPortalInfoV1::clear_targetlayer() {
  targetlayer_ = -1;
  clear_has_targetlayer();
}
inline ::google::protobuf::int32 MapDataPortalInfoV1::targetlayer() const {
  return targetlayer_;
}
inline void MapDataPortalInfoV1::set_targetlayer(::google::protobuf::int32 value) {
  set_has_targetlayer();
  targetlayer_ = value;
}

// optional sint32 UseCount = 5 [default = 1];
inline bool MapDataPortalInfoV1::has_usecount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapDataPortalInfoV1::set_has_usecount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapDataPortalInfoV1::clear_has_usecount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapDataPortalInfoV1::clear_usecount() {
  usecount_ = 1;
  clear_has_usecount();
}
inline ::google::protobuf::int32 MapDataPortalInfoV1::usecount() const {
  return usecount_;
}
inline void MapDataPortalInfoV1::set_usecount(::google::protobuf::int32 value) {
  set_has_usecount();
  usecount_ = value;
}

// optional bool Channel = 6 [default = false];
inline bool MapDataPortalInfoV1::has_channel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapDataPortalInfoV1::set_has_channel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapDataPortalInfoV1::clear_has_channel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MapDataPortalInfoV1::clear_channel() {
  channel_ = false;
  clear_has_channel();
}
inline bool MapDataPortalInfoV1::channel() const {
  return channel_;
}
inline void MapDataPortalInfoV1::set_channel(bool value) {
  set_has_channel();
  channel_ = value;
}

// optional sint32 PortalType = 7 [default = 0];
inline bool MapDataPortalInfoV1::has_portaltype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MapDataPortalInfoV1::set_has_portaltype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MapDataPortalInfoV1::clear_has_portaltype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MapDataPortalInfoV1::clear_portaltype() {
  portaltype_ = 0;
  clear_has_portaltype();
}
inline ::google::protobuf::int32 MapDataPortalInfoV1::portaltype() const {
  return portaltype_;
}
inline void MapDataPortalInfoV1::set_portaltype(::google::protobuf::int32 value) {
  set_has_portaltype();
  portaltype_ = value;
}

// optional sint32 TargetDungeonId = 8 [default = 0];
inline bool MapDataPortalInfoV1::has_targetdungeonid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MapDataPortalInfoV1::set_has_targetdungeonid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MapDataPortalInfoV1::clear_has_targetdungeonid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MapDataPortalInfoV1::clear_targetdungeonid() {
  targetdungeonid_ = 0;
  clear_has_targetdungeonid();
}
inline ::google::protobuf::int32 MapDataPortalInfoV1::targetdungeonid() const {
  return targetdungeonid_;
}
inline void MapDataPortalInfoV1::set_targetdungeonid(::google::protobuf::int32 value) {
  set_has_targetdungeonid();
  targetdungeonid_ = value;
}

// optional sint32 TargetSpawnIndex = 9 [default = 0];
inline bool MapDataPortalInfoV1::has_targetspawnindex() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MapDataPortalInfoV1::set_has_targetspawnindex() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MapDataPortalInfoV1::clear_has_targetspawnindex() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MapDataPortalInfoV1::clear_targetspawnindex() {
  targetspawnindex_ = 0;
  clear_has_targetspawnindex();
}
inline ::google::protobuf::int32 MapDataPortalInfoV1::targetspawnindex() const {
  return targetspawnindex_;
}
inline void MapDataPortalInfoV1::set_targetspawnindex(::google::protobuf::int32 value) {
  set_has_targetspawnindex();
  targetspawnindex_ = value;
}

// optional sint32 TargetDirection = 10 [default = 0];
inline bool MapDataPortalInfoV1::has_targetdirection() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MapDataPortalInfoV1::set_has_targetdirection() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MapDataPortalInfoV1::clear_has_targetdirection() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MapDataPortalInfoV1::clear_targetdirection() {
  targetdirection_ = 0;
  clear_has_targetdirection();
}
inline ::google::protobuf::int32 MapDataPortalInfoV1::targetdirection() const {
  return targetdirection_;
}
inline void MapDataPortalInfoV1::set_targetdirection(::google::protobuf::int32 value) {
  set_has_targetdirection();
  targetdirection_ = value;
}

// optional float SourceZ = 11 [default = 0];
inline bool MapDataPortalInfoV1::has_sourcez() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MapDataPortalInfoV1::set_has_sourcez() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MapDataPortalInfoV1::clear_has_sourcez() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MapDataPortalInfoV1::clear_sourcez() {
  sourcez_ = 0;
  clear_has_sourcez();
}
inline float MapDataPortalInfoV1::sourcez() const {
  return sourcez_;
}
inline void MapDataPortalInfoV1::set_sourcez(float value) {
  set_has_sourcez();
  sourcez_ = value;
}

// optional float TargetZ = 12 [default = 0];
inline bool MapDataPortalInfoV1::has_targetz() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MapDataPortalInfoV1::set_has_targetz() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MapDataPortalInfoV1::clear_has_targetz() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MapDataPortalInfoV1::clear_targetz() {
  targetz_ = 0;
  clear_has_targetz();
}
inline float MapDataPortalInfoV1::targetz() const {
  return targetz_;
}
inline void MapDataPortalInfoV1::set_targetz(float value) {
  set_has_targetz();
  targetz_ = value;
}

// optional float SourceAngle = 13 [default = 0];
inline bool MapDataPortalInfoV1::has_sourceangle() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MapDataPortalInfoV1::set_has_sourceangle() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MapDataPortalInfoV1::clear_has_sourceangle() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MapDataPortalInfoV1::clear_sourceangle() {
  sourceangle_ = 0;
  clear_has_sourceangle();
}
inline float MapDataPortalInfoV1::sourceangle() const {
  return sourceangle_;
}
inline void MapDataPortalInfoV1::set_sourceangle(float value) {
  set_has_sourceangle();
  sourceangle_ = value;
}

// optional float TargetAngle = 14 [default = 0];
inline bool MapDataPortalInfoV1::has_targetangle() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MapDataPortalInfoV1::set_has_targetangle() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MapDataPortalInfoV1::clear_has_targetangle() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MapDataPortalInfoV1::clear_targetangle() {
  targetangle_ = 0;
  clear_has_targetangle();
}
inline float MapDataPortalInfoV1::targetangle() const {
  return targetangle_;
}
inline void MapDataPortalInfoV1::set_targetangle(float value) {
  set_has_targetangle();
  targetangle_ = value;
}

// optional float SourceRadius = 15 [default = 0];
inline bool MapDataPortalInfoV1::has_sourceradius() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MapDataPortalInfoV1::set_has_sourceradius() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MapDataPortalInfoV1::clear_has_sourceradius() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MapDataPortalInfoV1::clear_sourceradius() {
  sourceradius_ = 0;
  clear_has_sourceradius();
}
inline float MapDataPortalInfoV1::sourceradius() const {
  return sourceradius_;
}
inline void MapDataPortalInfoV1::set_sourceradius(float value) {
  set_has_sourceradius();
  sourceradius_ = value;
}

// optional float TargetRadius = 16 [default = 0];
inline bool MapDataPortalInfoV1::has_targetradius() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MapDataPortalInfoV1::set_has_targetradius() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MapDataPortalInfoV1::clear_has_targetradius() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MapDataPortalInfoV1::clear_targetradius() {
  targetradius_ = 0;
  clear_has_targetradius();
}
inline float MapDataPortalInfoV1::targetradius() const {
  return targetradius_;
}
inline void MapDataPortalInfoV1::set_targetradius(float value) {
  set_has_targetradius();
  targetradius_ = value;
}

// -------------------------------------------------------------------

// MapDataTrapInfoV1

// optional sint32 TrapID = 1 [default = 0];
inline bool MapDataTrapInfoV1::has_trapid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapDataTrapInfoV1::set_has_trapid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapDataTrapInfoV1::clear_has_trapid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapDataTrapInfoV1::clear_trapid() {
  trapid_ = 0;
  clear_has_trapid();
}
inline ::google::protobuf::int32 MapDataTrapInfoV1::trapid() const {
  return trapid_;
}
inline void MapDataTrapInfoV1::set_trapid(::google::protobuf::int32 value) {
  set_has_trapid();
  trapid_ = value;
}

// optional float X = 2 [default = 0];
inline bool MapDataTrapInfoV1::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapDataTrapInfoV1::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapDataTrapInfoV1::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapDataTrapInfoV1::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float MapDataTrapInfoV1::x() const {
  return x_;
}
inline void MapDataTrapInfoV1::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float Y = 4 [default = 0];
inline bool MapDataTrapInfoV1::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapDataTrapInfoV1::set_has_y() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapDataTrapInfoV1::clear_has_y() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapDataTrapInfoV1::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float MapDataTrapInfoV1::y() const {
  return y_;
}
inline void MapDataTrapInfoV1::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional sint32 Direction = 5 [default = 1];
inline bool MapDataTrapInfoV1::has_direction() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapDataTrapInfoV1::set_has_direction() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapDataTrapInfoV1::clear_has_direction() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapDataTrapInfoV1::clear_direction() {
  direction_ = 1;
  clear_has_direction();
}
inline ::google::protobuf::int32 MapDataTrapInfoV1::direction() const {
  return direction_;
}
inline void MapDataTrapInfoV1::set_direction(::google::protobuf::int32 value) {
  set_has_direction();
  direction_ = value;
}

// optional float Z = 6 [default = 0];
inline bool MapDataTrapInfoV1::has_z() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapDataTrapInfoV1::set_has_z() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapDataTrapInfoV1::clear_has_z() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapDataTrapInfoV1::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float MapDataTrapInfoV1::z() const {
  return z_;
}
inline void MapDataTrapInfoV1::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// MapDataNpcInfoV1

// optional sint32 NpcID = 1 [default = 0];
inline bool MapDataNpcInfoV1::has_npcid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapDataNpcInfoV1::set_has_npcid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapDataNpcInfoV1::clear_has_npcid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapDataNpcInfoV1::clear_npcid() {
  npcid_ = 0;
  clear_has_npcid();
}
inline ::google::protobuf::int32 MapDataNpcInfoV1::npcid() const {
  return npcid_;
}
inline void MapDataNpcInfoV1::set_npcid(::google::protobuf::int32 value) {
  set_has_npcid();
  npcid_ = value;
}

// optional float X = 2 [default = 0];
inline bool MapDataNpcInfoV1::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapDataNpcInfoV1::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapDataNpcInfoV1::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapDataNpcInfoV1::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float MapDataNpcInfoV1::x() const {
  return x_;
}
inline void MapDataNpcInfoV1::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional sint32 Layer = 3 [default = 0];
inline bool MapDataNpcInfoV1::has_layer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapDataNpcInfoV1::set_has_layer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapDataNpcInfoV1::clear_has_layer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapDataNpcInfoV1::clear_layer() {
  layer_ = 0;
  clear_has_layer();
}
inline ::google::protobuf::int32 MapDataNpcInfoV1::layer() const {
  return layer_;
}
inline void MapDataNpcInfoV1::set_layer(::google::protobuf::int32 value) {
  set_has_layer();
  layer_ = value;
}

// optional float Z = 4 [default = 0];
inline bool MapDataNpcInfoV1::has_z() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapDataNpcInfoV1::set_has_z() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapDataNpcInfoV1::clear_has_z() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapDataNpcInfoV1::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float MapDataNpcInfoV1::z() const {
  return z_;
}
inline void MapDataNpcInfoV1::set_z(float value) {
  set_has_z();
  z_ = value;
}

// optional sint32 Direction = 5 [default = 1];
inline bool MapDataNpcInfoV1::has_direction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapDataNpcInfoV1::set_has_direction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapDataNpcInfoV1::clear_has_direction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapDataNpcInfoV1::clear_direction() {
  direction_ = 1;
  clear_has_direction();
}
inline ::google::protobuf::int32 MapDataNpcInfoV1::direction() const {
  return direction_;
}
inline void MapDataNpcInfoV1::set_direction(::google::protobuf::int32 value) {
  set_has_direction();
  direction_ = value;
}

// optional float Angle = 6 [default = 0];
inline bool MapDataNpcInfoV1::has_angle() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapDataNpcInfoV1::set_has_angle() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapDataNpcInfoV1::clear_has_angle() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MapDataNpcInfoV1::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float MapDataNpcInfoV1::angle() const {
  return angle_;
}
inline void MapDataNpcInfoV1::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// optional float Radius = 7 [default = 0];
inline bool MapDataNpcInfoV1::has_radius() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MapDataNpcInfoV1::set_has_radius() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MapDataNpcInfoV1::clear_has_radius() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MapDataNpcInfoV1::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float MapDataNpcInfoV1::radius() const {
  return radius_;
}
inline void MapDataNpcInfoV1::set_radius(float value) {
  set_has_radius();
  radius_ = value;
}

// -------------------------------------------------------------------

// MapDataMonsterInfoV1

// optional sint32 MonsterID = 1 [default = 0];
inline bool MapDataMonsterInfoV1::has_monsterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapDataMonsterInfoV1::set_has_monsterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapDataMonsterInfoV1::clear_has_monsterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapDataMonsterInfoV1::clear_monsterid() {
  monsterid_ = 0;
  clear_has_monsterid();
}
inline ::google::protobuf::int32 MapDataMonsterInfoV1::monsterid() const {
  return monsterid_;
}
inline void MapDataMonsterInfoV1::set_monsterid(::google::protobuf::int32 value) {
  set_has_monsterid();
  monsterid_ = value;
}

// optional float X = 2 [default = 0];
inline bool MapDataMonsterInfoV1::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapDataMonsterInfoV1::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapDataMonsterInfoV1::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapDataMonsterInfoV1::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float MapDataMonsterInfoV1::x() const {
  return x_;
}
inline void MapDataMonsterInfoV1::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional sint32 Layer = 3 [default = 0];
inline bool MapDataMonsterInfoV1::has_layer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapDataMonsterInfoV1::set_has_layer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapDataMonsterInfoV1::clear_has_layer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapDataMonsterInfoV1::clear_layer() {
  layer_ = 0;
  clear_has_layer();
}
inline ::google::protobuf::int32 MapDataMonsterInfoV1::layer() const {
  return layer_;
}
inline void MapDataMonsterInfoV1::set_layer(::google::protobuf::int32 value) {
  set_has_layer();
  layer_ = value;
}

// optional sint32 RepeatCount = 4 [default = 1];
inline bool MapDataMonsterInfoV1::has_repeatcount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapDataMonsterInfoV1::set_has_repeatcount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapDataMonsterInfoV1::clear_has_repeatcount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapDataMonsterInfoV1::clear_repeatcount() {
  repeatcount_ = 1;
  clear_has_repeatcount();
}
inline ::google::protobuf::int32 MapDataMonsterInfoV1::repeatcount() const {
  return repeatcount_;
}
inline void MapDataMonsterInfoV1::set_repeatcount(::google::protobuf::int32 value) {
  set_has_repeatcount();
  repeatcount_ = value;
}

// optional sint32 SpawmTriggerType = 5 [default = 0];
inline bool MapDataMonsterInfoV1::has_spawmtriggertype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapDataMonsterInfoV1::set_has_spawmtriggertype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapDataMonsterInfoV1::clear_has_spawmtriggertype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapDataMonsterInfoV1::clear_spawmtriggertype() {
  spawmtriggertype_ = 0;
  clear_has_spawmtriggertype();
}
inline ::google::protobuf::int32 MapDataMonsterInfoV1::spawmtriggertype() const {
  return spawmtriggertype_;
}
inline void MapDataMonsterInfoV1::set_spawmtriggertype(::google::protobuf::int32 value) {
  set_has_spawmtriggertype();
  spawmtriggertype_ = value;
}

// optional sint32 RespawmTriggerType = 6 [default = 0];
inline bool MapDataMonsterInfoV1::has_respawmtriggertype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapDataMonsterInfoV1::set_has_respawmtriggertype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapDataMonsterInfoV1::clear_has_respawmtriggertype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MapDataMonsterInfoV1::clear_respawmtriggertype() {
  respawmtriggertype_ = 0;
  clear_has_respawmtriggertype();
}
inline ::google::protobuf::int32 MapDataMonsterInfoV1::respawmtriggertype() const {
  return respawmtriggertype_;
}
inline void MapDataMonsterInfoV1::set_respawmtriggertype(::google::protobuf::int32 value) {
  set_has_respawmtriggertype();
  respawmtriggertype_ = value;
}

// optional float PatrolX1 = 11 [default = -1];
inline bool MapDataMonsterInfoV1::has_patrolx1() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MapDataMonsterInfoV1::set_has_patrolx1() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MapDataMonsterInfoV1::clear_has_patrolx1() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MapDataMonsterInfoV1::clear_patrolx1() {
  patrolx1_ = -1;
  clear_has_patrolx1();
}
inline float MapDataMonsterInfoV1::patrolx1() const {
  return patrolx1_;
}
inline void MapDataMonsterInfoV1::set_patrolx1(float value) {
  set_has_patrolx1();
  patrolx1_ = value;
}

// optional float PatrolX2 = 13 [default = -1];
inline bool MapDataMonsterInfoV1::has_patrolx2() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MapDataMonsterInfoV1::set_has_patrolx2() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MapDataMonsterInfoV1::clear_has_patrolx2() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MapDataMonsterInfoV1::clear_patrolx2() {
  patrolx2_ = -1;
  clear_has_patrolx2();
}
inline float MapDataMonsterInfoV1::patrolx2() const {
  return patrolx2_;
}
inline void MapDataMonsterInfoV1::set_patrolx2(float value) {
  set_has_patrolx2();
  patrolx2_ = value;
}

// optional float SpawnNodeTime = 14 [default = 0];
inline bool MapDataMonsterInfoV1::has_spawnnodetime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MapDataMonsterInfoV1::set_has_spawnnodetime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MapDataMonsterInfoV1::clear_has_spawnnodetime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MapDataMonsterInfoV1::clear_spawnnodetime() {
  spawnnodetime_ = 0;
  clear_has_spawnnodetime();
}
inline float MapDataMonsterInfoV1::spawnnodetime() const {
  return spawnnodetime_;
}
inline void MapDataMonsterInfoV1::set_spawnnodetime(float value) {
  set_has_spawnnodetime();
  spawnnodetime_ = value;
}

// optional sint32 SpawnKillEnemyID = 15 [default = 0];
inline bool MapDataMonsterInfoV1::has_spawnkillenemyid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MapDataMonsterInfoV1::set_has_spawnkillenemyid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MapDataMonsterInfoV1::clear_has_spawnkillenemyid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MapDataMonsterInfoV1::clear_spawnkillenemyid() {
  spawnkillenemyid_ = 0;
  clear_has_spawnkillenemyid();
}
inline ::google::protobuf::int32 MapDataMonsterInfoV1::spawnkillenemyid() const {
  return spawnkillenemyid_;
}
inline void MapDataMonsterInfoV1::set_spawnkillenemyid(::google::protobuf::int32 value) {
  set_has_spawnkillenemyid();
  spawnkillenemyid_ = value;
}

// optional sint32 SpawnKillEnemyCount = 16 [default = 0];
inline bool MapDataMonsterInfoV1::has_spawnkillenemycount() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MapDataMonsterInfoV1::set_has_spawnkillenemycount() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MapDataMonsterInfoV1::clear_has_spawnkillenemycount() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MapDataMonsterInfoV1::clear_spawnkillenemycount() {
  spawnkillenemycount_ = 0;
  clear_has_spawnkillenemycount();
}
inline ::google::protobuf::int32 MapDataMonsterInfoV1::spawnkillenemycount() const {
  return spawnkillenemycount_;
}
inline void MapDataMonsterInfoV1::set_spawnkillenemycount(::google::protobuf::int32 value) {
  set_has_spawnkillenemycount();
  spawnkillenemycount_ = value;
}

// optional float SpawnAfterDeathTime = 17 [default = 0];
inline bool MapDataMonsterInfoV1::has_spawnafterdeathtime() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MapDataMonsterInfoV1::set_has_spawnafterdeathtime() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MapDataMonsterInfoV1::clear_has_spawnafterdeathtime() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MapDataMonsterInfoV1::clear_spawnafterdeathtime() {
  spawnafterdeathtime_ = 0;
  clear_has_spawnafterdeathtime();
}
inline float MapDataMonsterInfoV1::spawnafterdeathtime() const {
  return spawnafterdeathtime_;
}
inline void MapDataMonsterInfoV1::set_spawnafterdeathtime(float value) {
  set_has_spawnafterdeathtime();
  spawnafterdeathtime_ = value;
}

// optional float RespawnNodeTime = 18 [default = 0];
inline bool MapDataMonsterInfoV1::has_respawnnodetime() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MapDataMonsterInfoV1::set_has_respawnnodetime() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MapDataMonsterInfoV1::clear_has_respawnnodetime() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MapDataMonsterInfoV1::clear_respawnnodetime() {
  respawnnodetime_ = 0;
  clear_has_respawnnodetime();
}
inline float MapDataMonsterInfoV1::respawnnodetime() const {
  return respawnnodetime_;
}
inline void MapDataMonsterInfoV1::set_respawnnodetime(float value) {
  set_has_respawnnodetime();
  respawnnodetime_ = value;
}

// optional sint32 RespawnKillEnemyID = 19 [default = 0];
inline bool MapDataMonsterInfoV1::has_respawnkillenemyid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MapDataMonsterInfoV1::set_has_respawnkillenemyid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MapDataMonsterInfoV1::clear_has_respawnkillenemyid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MapDataMonsterInfoV1::clear_respawnkillenemyid() {
  respawnkillenemyid_ = 0;
  clear_has_respawnkillenemyid();
}
inline ::google::protobuf::int32 MapDataMonsterInfoV1::respawnkillenemyid() const {
  return respawnkillenemyid_;
}
inline void MapDataMonsterInfoV1::set_respawnkillenemyid(::google::protobuf::int32 value) {
  set_has_respawnkillenemyid();
  respawnkillenemyid_ = value;
}

// optional sint32 RespawnKillEnemyCount = 20 [default = 0];
inline bool MapDataMonsterInfoV1::has_respawnkillenemycount() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MapDataMonsterInfoV1::set_has_respawnkillenemycount() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MapDataMonsterInfoV1::clear_has_respawnkillenemycount() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MapDataMonsterInfoV1::clear_respawnkillenemycount() {
  respawnkillenemycount_ = 0;
  clear_has_respawnkillenemycount();
}
inline ::google::protobuf::int32 MapDataMonsterInfoV1::respawnkillenemycount() const {
  return respawnkillenemycount_;
}
inline void MapDataMonsterInfoV1::set_respawnkillenemycount(::google::protobuf::int32 value) {
  set_has_respawnkillenemycount();
  respawnkillenemycount_ = value;
}

// optional float RespawnAfterDeathTime = 21 [default = 0];
inline bool MapDataMonsterInfoV1::has_respawnafterdeathtime() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MapDataMonsterInfoV1::set_has_respawnafterdeathtime() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MapDataMonsterInfoV1::clear_has_respawnafterdeathtime() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MapDataMonsterInfoV1::clear_respawnafterdeathtime() {
  respawnafterdeathtime_ = 0;
  clear_has_respawnafterdeathtime();
}
inline float MapDataMonsterInfoV1::respawnafterdeathtime() const {
  return respawnafterdeathtime_;
}
inline void MapDataMonsterInfoV1::set_respawnafterdeathtime(float value) {
  set_has_respawnafterdeathtime();
  respawnafterdeathtime_ = value;
}

// optional sint32 CreateMonsterType = 22 [default = 0];
inline bool MapDataMonsterInfoV1::has_createmonstertype() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MapDataMonsterInfoV1::set_has_createmonstertype() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MapDataMonsterInfoV1::clear_has_createmonstertype() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MapDataMonsterInfoV1::clear_createmonstertype() {
  createmonstertype_ = 0;
  clear_has_createmonstertype();
}
inline ::google::protobuf::int32 MapDataMonsterInfoV1::createmonstertype() const {
  return createmonstertype_;
}
inline void MapDataMonsterInfoV1::set_createmonstertype(::google::protobuf::int32 value) {
  set_has_createmonstertype();
  createmonstertype_ = value;
}

// repeated .MapDataNodeMonsterInfoV1 NodeMonsterInfoArr = 24;
inline int MapDataMonsterInfoV1::nodemonsterinfoarr_size() const {
  return nodemonsterinfoarr_.size();
}
inline void MapDataMonsterInfoV1::clear_nodemonsterinfoarr() {
  nodemonsterinfoarr_.Clear();
}
inline const ::MapDataNodeMonsterInfoV1& MapDataMonsterInfoV1::nodemonsterinfoarr(int index) const {
  return nodemonsterinfoarr_.Get(index);
}
inline ::MapDataNodeMonsterInfoV1* MapDataMonsterInfoV1::mutable_nodemonsterinfoarr(int index) {
  return nodemonsterinfoarr_.Mutable(index);
}
inline ::MapDataNodeMonsterInfoV1* MapDataMonsterInfoV1::add_nodemonsterinfoarr() {
  return nodemonsterinfoarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapDataNodeMonsterInfoV1 >&
MapDataMonsterInfoV1::nodemonsterinfoarr() const {
  return nodemonsterinfoarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapDataNodeMonsterInfoV1 >*
MapDataMonsterInfoV1::mutable_nodemonsterinfoarr() {
  return &nodemonsterinfoarr_;
}

// optional float Z = 25 [default = 0];
inline bool MapDataMonsterInfoV1::has_z() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MapDataMonsterInfoV1::set_has_z() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MapDataMonsterInfoV1::clear_has_z() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MapDataMonsterInfoV1::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float MapDataMonsterInfoV1::z() const {
  return z_;
}
inline void MapDataMonsterInfoV1::set_z(float value) {
  set_has_z();
  z_ = value;
}

// optional sint32 Direction = 26 [default = 1];
inline bool MapDataMonsterInfoV1::has_direction() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void MapDataMonsterInfoV1::set_has_direction() {
  _has_bits_[0] |= 0x00080000u;
}
inline void MapDataMonsterInfoV1::clear_has_direction() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void MapDataMonsterInfoV1::clear_direction() {
  direction_ = 1;
  clear_has_direction();
}
inline ::google::protobuf::int32 MapDataMonsterInfoV1::direction() const {
  return direction_;
}
inline void MapDataMonsterInfoV1::set_direction(::google::protobuf::int32 value) {
  set_has_direction();
  direction_ = value;
}

// -------------------------------------------------------------------

// MapDataNodeInfoV1

// optional float X = 1 [default = 0];
inline bool MapDataNodeInfoV1::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapDataNodeInfoV1::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapDataNodeInfoV1::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapDataNodeInfoV1::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float MapDataNodeInfoV1::x() const {
  return x_;
}
inline void MapDataNodeInfoV1::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional sint32 Layer = 2 [default = 0];
inline bool MapDataNodeInfoV1::has_layer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapDataNodeInfoV1::set_has_layer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapDataNodeInfoV1::clear_has_layer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapDataNodeInfoV1::clear_layer() {
  layer_ = 0;
  clear_has_layer();
}
inline ::google::protobuf::int32 MapDataNodeInfoV1::layer() const {
  return layer_;
}
inline void MapDataNodeInfoV1::set_layer(::google::protobuf::int32 value) {
  set_has_layer();
  layer_ = value;
}

// optional sint32 PassCondition = 3 [default = 0];
inline bool MapDataNodeInfoV1::has_passcondition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapDataNodeInfoV1::set_has_passcondition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapDataNodeInfoV1::clear_has_passcondition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapDataNodeInfoV1::clear_passcondition() {
  passcondition_ = 0;
  clear_has_passcondition();
}
inline ::google::protobuf::int32 MapDataNodeInfoV1::passcondition() const {
  return passcondition_;
}
inline void MapDataNodeInfoV1::set_passcondition(::google::protobuf::int32 value) {
  set_has_passcondition();
  passcondition_ = value;
}

// optional sint32 KillEnemyID = 4 [default = 0];
inline bool MapDataNodeInfoV1::has_killenemyid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapDataNodeInfoV1::set_has_killenemyid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapDataNodeInfoV1::clear_has_killenemyid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapDataNodeInfoV1::clear_killenemyid() {
  killenemyid_ = 0;
  clear_has_killenemyid();
}
inline ::google::protobuf::int32 MapDataNodeInfoV1::killenemyid() const {
  return killenemyid_;
}
inline void MapDataNodeInfoV1::set_killenemyid(::google::protobuf::int32 value) {
  set_has_killenemyid();
  killenemyid_ = value;
}

// optional sint32 KillEnemyCount = 5 [default = 0];
inline bool MapDataNodeInfoV1::has_killenemycount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapDataNodeInfoV1::set_has_killenemycount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapDataNodeInfoV1::clear_has_killenemycount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapDataNodeInfoV1::clear_killenemycount() {
  killenemycount_ = 0;
  clear_has_killenemycount();
}
inline ::google::protobuf::int32 MapDataNodeInfoV1::killenemycount() const {
  return killenemycount_;
}
inline void MapDataNodeInfoV1::set_killenemycount(::google::protobuf::int32 value) {
  set_has_killenemycount();
  killenemycount_ = value;
}

// repeated .MapDataMonsterInfoV1 MonsterArr = 6;
inline int MapDataNodeInfoV1::monsterarr_size() const {
  return monsterarr_.size();
}
inline void MapDataNodeInfoV1::clear_monsterarr() {
  monsterarr_.Clear();
}
inline const ::MapDataMonsterInfoV1& MapDataNodeInfoV1::monsterarr(int index) const {
  return monsterarr_.Get(index);
}
inline ::MapDataMonsterInfoV1* MapDataNodeInfoV1::mutable_monsterarr(int index) {
  return monsterarr_.Mutable(index);
}
inline ::MapDataMonsterInfoV1* MapDataNodeInfoV1::add_monsterarr() {
  return monsterarr_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::MapDataMonsterInfoV1 >&
MapDataNodeInfoV1::monsterarr() const {
  return monsterarr_;
}
inline ::google::protobuf::RepeatedPtrField< ::MapDataMonsterInfoV1 >*
MapDataNodeInfoV1::mutable_monsterarr() {
  return &monsterarr_;
}

// optional float TimeLimit = 7 [default = 0];
inline bool MapDataNodeInfoV1::has_timelimit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MapDataNodeInfoV1::set_has_timelimit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MapDataNodeInfoV1::clear_has_timelimit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MapDataNodeInfoV1::clear_timelimit() {
  timelimit_ = 0;
  clear_has_timelimit();
}
inline float MapDataNodeInfoV1::timelimit() const {
  return timelimit_;
}
inline void MapDataNodeInfoV1::set_timelimit(float value) {
  set_has_timelimit();
  timelimit_ = value;
}

// optional sint32 NodeType = 8 [default = 0];
inline bool MapDataNodeInfoV1::has_nodetype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MapDataNodeInfoV1::set_has_nodetype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MapDataNodeInfoV1::clear_has_nodetype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MapDataNodeInfoV1::clear_nodetype() {
  nodetype_ = 0;
  clear_has_nodetype();
}
inline ::google::protobuf::int32 MapDataNodeInfoV1::nodetype() const {
  return nodetype_;
}
inline void MapDataNodeInfoV1::set_nodetype(::google::protobuf::int32 value) {
  set_has_nodetype();
  nodetype_ = value;
}

// optional sint32 NodeArrowDisplayType = 9 [default = 0];
inline bool MapDataNodeInfoV1::has_nodearrowdisplaytype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MapDataNodeInfoV1::set_has_nodearrowdisplaytype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MapDataNodeInfoV1::clear_has_nodearrowdisplaytype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MapDataNodeInfoV1::clear_nodearrowdisplaytype() {
  nodearrowdisplaytype_ = 0;
  clear_has_nodearrowdisplaytype();
}
inline ::google::protobuf::int32 MapDataNodeInfoV1::nodearrowdisplaytype() const {
  return nodearrowdisplaytype_;
}
inline void MapDataNodeInfoV1::set_nodearrowdisplaytype(::google::protobuf::int32 value) {
  set_has_nodearrowdisplaytype();
  nodearrowdisplaytype_ = value;
}

// -------------------------------------------------------------------

// MapDataTerritorialInfoV1

// optional sint32 Layer = 1 [default = 0];
inline bool MapDataTerritorialInfoV1::has_layer() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapDataTerritorialInfoV1::set_has_layer() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapDataTerritorialInfoV1::clear_has_layer() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapDataTerritorialInfoV1::clear_layer() {
  layer_ = 0;
  clear_has_layer();
}
inline ::google::protobuf::int32 MapDataTerritorialInfoV1::layer() const {
  return layer_;
}
inline void MapDataTerritorialInfoV1::set_layer(::google::protobuf::int32 value) {
  set_has_layer();
  layer_ = value;
}

// optional .MapDataVector2V1 Area = 2;
inline bool MapDataTerritorialInfoV1::has_area() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapDataTerritorialInfoV1::set_has_area() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapDataTerritorialInfoV1::clear_has_area() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapDataTerritorialInfoV1::clear_area() {
  if (area_ != NULL) area_->::MapDataVector2V1::Clear();
  clear_has_area();
}
inline const ::MapDataVector2V1& MapDataTerritorialInfoV1::area() const {
  return area_ != NULL ? *area_ : *default_instance_->area_;
}
inline ::MapDataVector2V1* MapDataTerritorialInfoV1::mutable_area() {
  set_has_area();
  if (area_ == NULL) area_ = new ::MapDataVector2V1;
  return area_;
}
inline ::MapDataVector2V1* MapDataTerritorialInfoV1::release_area() {
  clear_has_area();
  ::MapDataVector2V1* temp = area_;
  area_ = NULL;
  return temp;
}
inline void MapDataTerritorialInfoV1::set_allocated_area(::MapDataVector2V1* area) {
  delete area_;
  area_ = area;
  if (area) {
    set_has_area();
  } else {
    clear_has_area();
  }
}

// optional float X = 3 [default = 0];
inline bool MapDataTerritorialInfoV1::has_x() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapDataTerritorialInfoV1::set_has_x() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapDataTerritorialInfoV1::clear_has_x() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapDataTerritorialInfoV1::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float MapDataTerritorialInfoV1::x() const {
  return x_;
}
inline void MapDataTerritorialInfoV1::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional sint32 ID = 4 [default = 0];
inline bool MapDataTerritorialInfoV1::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapDataTerritorialInfoV1::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapDataTerritorialInfoV1::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapDataTerritorialInfoV1::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MapDataTerritorialInfoV1::id() const {
  return id_;
}
inline void MapDataTerritorialInfoV1::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string ModelName = 5;
inline bool MapDataTerritorialInfoV1::has_modelname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapDataTerritorialInfoV1::set_has_modelname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapDataTerritorialInfoV1::clear_has_modelname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapDataTerritorialInfoV1::clear_modelname() {
  if (modelname_ != &::google::protobuf::internal::kEmptyString) {
    modelname_->clear();
  }
  clear_has_modelname();
}
inline const ::std::string& MapDataTerritorialInfoV1::modelname() const {
  return *modelname_;
}
inline void MapDataTerritorialInfoV1::set_modelname(const ::std::string& value) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::kEmptyString) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(value);
}
inline void MapDataTerritorialInfoV1::set_modelname(const char* value) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::kEmptyString) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(value);
}
inline void MapDataTerritorialInfoV1::set_modelname(const char* value, size_t size) {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::kEmptyString) {
    modelname_ = new ::std::string;
  }
  modelname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MapDataTerritorialInfoV1::mutable_modelname() {
  set_has_modelname();
  if (modelname_ == &::google::protobuf::internal::kEmptyString) {
    modelname_ = new ::std::string;
  }
  return modelname_;
}
inline ::std::string* MapDataTerritorialInfoV1::release_modelname() {
  clear_has_modelname();
  if (modelname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = modelname_;
    modelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MapDataTerritorialInfoV1::set_allocated_modelname(::std::string* modelname) {
  if (modelname_ != &::google::protobuf::internal::kEmptyString) {
    delete modelname_;
  }
  if (modelname) {
    set_has_modelname();
    modelname_ = modelname;
  } else {
    clear_has_modelname();
    modelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MapDataNodeMonsterInfoV1

// optional sint32 MonsterId = 1 [default = -1];
inline bool MapDataNodeMonsterInfoV1::has_monsterid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapDataNodeMonsterInfoV1::set_has_monsterid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapDataNodeMonsterInfoV1::clear_has_monsterid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapDataNodeMonsterInfoV1::clear_monsterid() {
  monsterid_ = -1;
  clear_has_monsterid();
}
inline ::google::protobuf::int32 MapDataNodeMonsterInfoV1::monsterid() const {
  return monsterid_;
}
inline void MapDataNodeMonsterInfoV1::set_monsterid(::google::protobuf::int32 value) {
  set_has_monsterid();
  monsterid_ = value;
}

// optional sint32 RandomWeight = 2 [default = -1];
inline bool MapDataNodeMonsterInfoV1::has_randomweight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapDataNodeMonsterInfoV1::set_has_randomweight() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapDataNodeMonsterInfoV1::clear_has_randomweight() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapDataNodeMonsterInfoV1::clear_randomweight() {
  randomweight_ = -1;
  clear_has_randomweight();
}
inline ::google::protobuf::int32 MapDataNodeMonsterInfoV1::randomweight() const {
  return randomweight_;
}
inline void MapDataNodeMonsterInfoV1::set_randomweight(::google::protobuf::int32 value) {
  set_has_randomweight();
  randomweight_ = value;
}

// -------------------------------------------------------------------

// MapDataBaseConfigV1

// optional sint32 MapType = 1 [default = 0];
inline bool MapDataBaseConfigV1::has_maptype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapDataBaseConfigV1::set_has_maptype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapDataBaseConfigV1::clear_has_maptype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapDataBaseConfigV1::clear_maptype() {
  maptype_ = 0;
  clear_has_maptype();
}
inline ::google::protobuf::int32 MapDataBaseConfigV1::maptype() const {
  return maptype_;
}
inline void MapDataBaseConfigV1::set_maptype(::google::protobuf::int32 value) {
  set_has_maptype();
  maptype_ = value;
}

// -------------------------------------------------------------------

// MapDataGatherInfoV1

// optional sint32 GatherId = 1 [default = 0];
inline bool MapDataGatherInfoV1::has_gatherid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapDataGatherInfoV1::set_has_gatherid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapDataGatherInfoV1::clear_has_gatherid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapDataGatherInfoV1::clear_gatherid() {
  gatherid_ = 0;
  clear_has_gatherid();
}
inline ::google::protobuf::int32 MapDataGatherInfoV1::gatherid() const {
  return gatherid_;
}
inline void MapDataGatherInfoV1::set_gatherid(::google::protobuf::int32 value) {
  set_has_gatherid();
  gatherid_ = value;
}

// optional float X = 2 [default = 0];
inline bool MapDataGatherInfoV1::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapDataGatherInfoV1::set_has_x() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapDataGatherInfoV1::clear_has_x() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapDataGatherInfoV1::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float MapDataGatherInfoV1::x() const {
  return x_;
}
inline void MapDataGatherInfoV1::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional sint32 Layer = 3 [default = 0];
inline bool MapDataGatherInfoV1::has_layer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapDataGatherInfoV1::set_has_layer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapDataGatherInfoV1::clear_has_layer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapDataGatherInfoV1::clear_layer() {
  layer_ = 0;
  clear_has_layer();
}
inline ::google::protobuf::int32 MapDataGatherInfoV1::layer() const {
  return layer_;
}
inline void MapDataGatherInfoV1::set_layer(::google::protobuf::int32 value) {
  set_has_layer();
  layer_ = value;
}

// optional float Z = 4 [default = 0];
inline bool MapDataGatherInfoV1::has_z() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapDataGatherInfoV1::set_has_z() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapDataGatherInfoV1::clear_has_z() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapDataGatherInfoV1::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float MapDataGatherInfoV1::z() const {
  return z_;
}
inline void MapDataGatherInfoV1::set_z(float value) {
  set_has_z();
  z_ = value;
}

// optional sint32 Direction = 5 [default = 1];
inline bool MapDataGatherInfoV1::has_direction() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapDataGatherInfoV1::set_has_direction() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapDataGatherInfoV1::clear_has_direction() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapDataGatherInfoV1::clear_direction() {
  direction_ = 1;
  clear_has_direction();
}
inline ::google::protobuf::int32 MapDataGatherInfoV1::direction() const {
  return direction_;
}
inline void MapDataGatherInfoV1::set_direction(::google::protobuf::int32 value) {
  set_has_direction();
  direction_ = value;
}

// -------------------------------------------------------------------

// MapDataContourLineInfoV1

// optional float Y = 1 [default = -1];
inline bool MapDataContourLineInfoV1::has_y() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapDataContourLineInfoV1::set_has_y() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapDataContourLineInfoV1::clear_has_y() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapDataContourLineInfoV1::clear_y() {
  y_ = -1;
  clear_has_y();
}
inline float MapDataContourLineInfoV1::y() const {
  return y_;
}
inline void MapDataContourLineInfoV1::set_y(float value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// MapDataEventInfoV1

// optional float X1 = 1 [default = 0];
inline bool MapDataEventInfoV1::has_x1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MapDataEventInfoV1::set_has_x1() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MapDataEventInfoV1::clear_has_x1() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MapDataEventInfoV1::clear_x1() {
  x1_ = 0;
  clear_has_x1();
}
inline float MapDataEventInfoV1::x1() const {
  return x1_;
}
inline void MapDataEventInfoV1::set_x1(float value) {
  set_has_x1();
  x1_ = value;
}

// optional float Z1 = 2 [default = 0];
inline bool MapDataEventInfoV1::has_z1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MapDataEventInfoV1::set_has_z1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MapDataEventInfoV1::clear_has_z1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MapDataEventInfoV1::clear_z1() {
  z1_ = 0;
  clear_has_z1();
}
inline float MapDataEventInfoV1::z1() const {
  return z1_;
}
inline void MapDataEventInfoV1::set_z1(float value) {
  set_has_z1();
  z1_ = value;
}

// optional float X2 = 3 [default = 0];
inline bool MapDataEventInfoV1::has_x2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MapDataEventInfoV1::set_has_x2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MapDataEventInfoV1::clear_has_x2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MapDataEventInfoV1::clear_x2() {
  x2_ = 0;
  clear_has_x2();
}
inline float MapDataEventInfoV1::x2() const {
  return x2_;
}
inline void MapDataEventInfoV1::set_x2(float value) {
  set_has_x2();
  x2_ = value;
}

// optional float Z2 = 4 [default = 0];
inline bool MapDataEventInfoV1::has_z2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MapDataEventInfoV1::set_has_z2() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MapDataEventInfoV1::clear_has_z2() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MapDataEventInfoV1::clear_z2() {
  z2_ = 0;
  clear_has_z2();
}
inline float MapDataEventInfoV1::z2() const {
  return z2_;
}
inline void MapDataEventInfoV1::set_z2(float value) {
  set_has_z2();
  z2_ = value;
}

// optional sint32 Type = 5 [default = 0];
inline bool MapDataEventInfoV1::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MapDataEventInfoV1::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MapDataEventInfoV1::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MapDataEventInfoV1::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 MapDataEventInfoV1::type() const {
  return type_;
}
inline void MapDataEventInfoV1::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional sint32 EventId = 6 [default = 0];
inline bool MapDataEventInfoV1::has_eventid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MapDataEventInfoV1::set_has_eventid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MapDataEventInfoV1::clear_has_eventid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MapDataEventInfoV1::clear_eventid() {
  eventid_ = 0;
  clear_has_eventid();
}
inline ::google::protobuf::int32 MapDataEventInfoV1::eventid() const {
  return eventid_;
}
inline void MapDataEventInfoV1::set_eventid(::google::protobuf::int32 value) {
  set_has_eventid();
  eventid_ = value;
}

// optional sint32 Layer = 7 [default = 0];
inline bool MapDataEventInfoV1::has_layer() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MapDataEventInfoV1::set_has_layer() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MapDataEventInfoV1::clear_has_layer() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MapDataEventInfoV1::clear_layer() {
  layer_ = 0;
  clear_has_layer();
}
inline ::google::protobuf::int32 MapDataEventInfoV1::layer() const {
  return layer_;
}
inline void MapDataEventInfoV1::set_layer(::google::protobuf::int32 value) {
  set_has_layer();
  layer_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MapDataV1Data_2eproto__INCLUDED
