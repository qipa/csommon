// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MapDataV1Data.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "MapDataV1Data.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* MapDataUselessV1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapDataUselessV1_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapDataLayerInfoV1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapDataLayerInfoV1_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapDataInfoV1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapDataInfoV1_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapDataVector2V1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapDataVector2V1_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapDataSpawnInfoV1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapDataSpawnInfoV1_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapDataDefeatInfoV1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapDataDefeatInfoV1_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapDataPerfectInfoV1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapDataPerfectInfoV1_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapDataPortalInfoV1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapDataPortalInfoV1_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapDataTrapInfoV1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapDataTrapInfoV1_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapDataNpcInfoV1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapDataNpcInfoV1_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapDataMonsterInfoV1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapDataMonsterInfoV1_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapDataNodeInfoV1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapDataNodeInfoV1_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapDataTerritorialInfoV1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapDataTerritorialInfoV1_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapDataNodeMonsterInfoV1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapDataNodeMonsterInfoV1_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapDataBaseConfigV1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapDataBaseConfigV1_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapDataGatherInfoV1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapDataGatherInfoV1_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapDataContourLineInfoV1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapDataContourLineInfoV1_reflection_ = NULL;
const ::google::protobuf::Descriptor* MapDataEventInfoV1_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MapDataEventInfoV1_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_MapDataV1Data_2eproto() {
  protobuf_AddDesc_MapDataV1Data_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "MapDataV1Data.proto");
  GOOGLE_CHECK(file != NULL);
  MapDataUselessV1_descriptor_ = file->message_type(0);
  static const int MapDataUselessV1_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataUselessV1, x1_),
  };
  MapDataUselessV1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapDataUselessV1_descriptor_,
      MapDataUselessV1::default_instance_,
      MapDataUselessV1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataUselessV1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataUselessV1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapDataUselessV1));
  MapDataLayerInfoV1_descriptor_ = file->message_type(1);
  static const int MapDataLayerInfoV1_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataLayerInfoV1, walkarea_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataLayerInfoV1, lostarea_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataLayerInfoV1, clienthight_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataLayerInfoV1, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataLayerInfoV1, z_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataLayerInfoV1, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataLayerInfoV1, minheightlimit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataLayerInfoV1, maxheightlimit_),
  };
  MapDataLayerInfoV1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapDataLayerInfoV1_descriptor_,
      MapDataLayerInfoV1::default_instance_,
      MapDataLayerInfoV1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataLayerInfoV1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataLayerInfoV1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapDataLayerInfoV1));
  MapDataInfoV1_descriptor_ = file->message_type(2);
  static const int MapDataInfoV1_offsets_[14] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataInfoV1, layerarr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataInfoV1, spawnarr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataInfoV1, defeat_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataInfoV1, perfectarr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataInfoV1, portalarr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataInfoV1, traparr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataInfoV1, npcarr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataInfoV1, nodearr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataInfoV1, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataInfoV1, stormbasearr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataInfoV1, stormflag_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataInfoV1, baseconfig_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataInfoV1, gatherarr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataInfoV1, eventarr_),
  };
  MapDataInfoV1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapDataInfoV1_descriptor_,
      MapDataInfoV1::default_instance_,
      MapDataInfoV1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataInfoV1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataInfoV1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapDataInfoV1));
  MapDataVector2V1_descriptor_ = file->message_type(3);
  static const int MapDataVector2V1_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataVector2V1, x1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataVector2V1, x2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataVector2V1, z1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataVector2V1, z2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataVector2V1, organgle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataVector2V1, finangle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataVector2V1, radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataVector2V1, contourlinearr_),
  };
  MapDataVector2V1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapDataVector2V1_descriptor_,
      MapDataVector2V1::default_instance_,
      MapDataVector2V1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataVector2V1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataVector2V1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapDataVector2V1));
  MapDataSpawnInfoV1_descriptor_ = file->message_type(4);
  static const int MapDataSpawnInfoV1_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataSpawnInfoV1, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataSpawnInfoV1, layer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataSpawnInfoV1, spawndirection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataSpawnInfoV1, z_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataSpawnInfoV1, radius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataSpawnInfoV1, angle_),
  };
  MapDataSpawnInfoV1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapDataSpawnInfoV1_descriptor_,
      MapDataSpawnInfoV1::default_instance_,
      MapDataSpawnInfoV1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataSpawnInfoV1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataSpawnInfoV1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapDataSpawnInfoV1));
  MapDataDefeatInfoV1_descriptor_ = file->message_type(5);
  static const int MapDataDefeatInfoV1_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataDefeatInfoV1, condition_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataDefeatInfoV1, timelimit_),
  };
  MapDataDefeatInfoV1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapDataDefeatInfoV1_descriptor_,
      MapDataDefeatInfoV1::default_instance_,
      MapDataDefeatInfoV1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataDefeatInfoV1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataDefeatInfoV1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapDataDefeatInfoV1));
  MapDataPerfectInfoV1_descriptor_ = file->message_type(6);
  static const int MapDataPerfectInfoV1_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPerfectInfoV1, condition_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPerfectInfoV1, deathcountnum_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPerfectInfoV1, killenemyid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPerfectInfoV1, killenemycount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPerfectInfoV1, hppercent_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPerfectInfoV1, timelimit_),
  };
  MapDataPerfectInfoV1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapDataPerfectInfoV1_descriptor_,
      MapDataPerfectInfoV1::default_instance_,
      MapDataPerfectInfoV1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPerfectInfoV1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPerfectInfoV1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapDataPerfectInfoV1));
  MapDataPortalInfoV1_descriptor_ = file->message_type(7);
  static const int MapDataPortalInfoV1_offsets_[16] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPortalInfoV1, sourcex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPortalInfoV1, sourcelayer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPortalInfoV1, targetx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPortalInfoV1, targetlayer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPortalInfoV1, usecount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPortalInfoV1, channel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPortalInfoV1, portaltype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPortalInfoV1, targetdungeonid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPortalInfoV1, targetspawnindex_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPortalInfoV1, targetdirection_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPortalInfoV1, sourcez_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPortalInfoV1, targetz_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPortalInfoV1, sourceangle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPortalInfoV1, targetangle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPortalInfoV1, sourceradius_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPortalInfoV1, targetradius_),
  };
  MapDataPortalInfoV1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapDataPortalInfoV1_descriptor_,
      MapDataPortalInfoV1::default_instance_,
      MapDataPortalInfoV1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPortalInfoV1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataPortalInfoV1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapDataPortalInfoV1));
  MapDataTrapInfoV1_descriptor_ = file->message_type(8);
  static const int MapDataTrapInfoV1_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataTrapInfoV1, trapid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataTrapInfoV1, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataTrapInfoV1, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataTrapInfoV1, direction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataTrapInfoV1, z_),
  };
  MapDataTrapInfoV1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapDataTrapInfoV1_descriptor_,
      MapDataTrapInfoV1::default_instance_,
      MapDataTrapInfoV1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataTrapInfoV1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataTrapInfoV1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapDataTrapInfoV1));
  MapDataNpcInfoV1_descriptor_ = file->message_type(9);
  static const int MapDataNpcInfoV1_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNpcInfoV1, npcid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNpcInfoV1, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNpcInfoV1, layer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNpcInfoV1, z_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNpcInfoV1, direction_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNpcInfoV1, angle_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNpcInfoV1, radius_),
  };
  MapDataNpcInfoV1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapDataNpcInfoV1_descriptor_,
      MapDataNpcInfoV1::default_instance_,
      MapDataNpcInfoV1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNpcInfoV1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNpcInfoV1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapDataNpcInfoV1));
  MapDataMonsterInfoV1_descriptor_ = file->message_type(10);
  static const int MapDataMonsterInfoV1_offsets_[20] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, monsterid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, layer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, repeatcount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, spawmtriggertype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, respawmtriggertype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, patrolx1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, patrolx2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, spawnnodetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, spawnkillenemyid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, spawnkillenemycount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, spawnafterdeathtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, respawnnodetime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, respawnkillenemyid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, respawnkillenemycount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, respawnafterdeathtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, createmonstertype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, nodemonsterinfoarr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, z_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, direction_),
  };
  MapDataMonsterInfoV1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapDataMonsterInfoV1_descriptor_,
      MapDataMonsterInfoV1::default_instance_,
      MapDataMonsterInfoV1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataMonsterInfoV1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapDataMonsterInfoV1));
  MapDataNodeInfoV1_descriptor_ = file->message_type(11);
  static const int MapDataNodeInfoV1_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNodeInfoV1, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNodeInfoV1, layer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNodeInfoV1, passcondition_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNodeInfoV1, killenemyid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNodeInfoV1, killenemycount_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNodeInfoV1, monsterarr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNodeInfoV1, timelimit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNodeInfoV1, nodetype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNodeInfoV1, nodearrowdisplaytype_),
  };
  MapDataNodeInfoV1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapDataNodeInfoV1_descriptor_,
      MapDataNodeInfoV1::default_instance_,
      MapDataNodeInfoV1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNodeInfoV1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNodeInfoV1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapDataNodeInfoV1));
  MapDataTerritorialInfoV1_descriptor_ = file->message_type(12);
  static const int MapDataTerritorialInfoV1_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataTerritorialInfoV1, layer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataTerritorialInfoV1, area_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataTerritorialInfoV1, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataTerritorialInfoV1, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataTerritorialInfoV1, modelname_),
  };
  MapDataTerritorialInfoV1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapDataTerritorialInfoV1_descriptor_,
      MapDataTerritorialInfoV1::default_instance_,
      MapDataTerritorialInfoV1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataTerritorialInfoV1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataTerritorialInfoV1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapDataTerritorialInfoV1));
  MapDataNodeMonsterInfoV1_descriptor_ = file->message_type(13);
  static const int MapDataNodeMonsterInfoV1_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNodeMonsterInfoV1, monsterid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNodeMonsterInfoV1, randomweight_),
  };
  MapDataNodeMonsterInfoV1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapDataNodeMonsterInfoV1_descriptor_,
      MapDataNodeMonsterInfoV1::default_instance_,
      MapDataNodeMonsterInfoV1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNodeMonsterInfoV1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataNodeMonsterInfoV1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapDataNodeMonsterInfoV1));
  MapDataBaseConfigV1_descriptor_ = file->message_type(14);
  static const int MapDataBaseConfigV1_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataBaseConfigV1, maptype_),
  };
  MapDataBaseConfigV1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapDataBaseConfigV1_descriptor_,
      MapDataBaseConfigV1::default_instance_,
      MapDataBaseConfigV1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataBaseConfigV1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataBaseConfigV1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapDataBaseConfigV1));
  MapDataGatherInfoV1_descriptor_ = file->message_type(15);
  static const int MapDataGatherInfoV1_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataGatherInfoV1, gatherid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataGatherInfoV1, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataGatherInfoV1, layer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataGatherInfoV1, z_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataGatherInfoV1, direction_),
  };
  MapDataGatherInfoV1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapDataGatherInfoV1_descriptor_,
      MapDataGatherInfoV1::default_instance_,
      MapDataGatherInfoV1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataGatherInfoV1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataGatherInfoV1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapDataGatherInfoV1));
  MapDataContourLineInfoV1_descriptor_ = file->message_type(16);
  static const int MapDataContourLineInfoV1_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataContourLineInfoV1, y_),
  };
  MapDataContourLineInfoV1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapDataContourLineInfoV1_descriptor_,
      MapDataContourLineInfoV1::default_instance_,
      MapDataContourLineInfoV1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataContourLineInfoV1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataContourLineInfoV1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapDataContourLineInfoV1));
  MapDataEventInfoV1_descriptor_ = file->message_type(17);
  static const int MapDataEventInfoV1_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataEventInfoV1, x1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataEventInfoV1, z1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataEventInfoV1, x2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataEventInfoV1, z2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataEventInfoV1, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataEventInfoV1, eventid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataEventInfoV1, layer_),
  };
  MapDataEventInfoV1_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MapDataEventInfoV1_descriptor_,
      MapDataEventInfoV1::default_instance_,
      MapDataEventInfoV1_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataEventInfoV1, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MapDataEventInfoV1, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MapDataEventInfoV1));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_MapDataV1Data_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapDataUselessV1_descriptor_, &MapDataUselessV1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapDataLayerInfoV1_descriptor_, &MapDataLayerInfoV1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapDataInfoV1_descriptor_, &MapDataInfoV1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapDataVector2V1_descriptor_, &MapDataVector2V1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapDataSpawnInfoV1_descriptor_, &MapDataSpawnInfoV1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapDataDefeatInfoV1_descriptor_, &MapDataDefeatInfoV1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapDataPerfectInfoV1_descriptor_, &MapDataPerfectInfoV1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapDataPortalInfoV1_descriptor_, &MapDataPortalInfoV1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapDataTrapInfoV1_descriptor_, &MapDataTrapInfoV1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapDataNpcInfoV1_descriptor_, &MapDataNpcInfoV1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapDataMonsterInfoV1_descriptor_, &MapDataMonsterInfoV1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapDataNodeInfoV1_descriptor_, &MapDataNodeInfoV1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapDataTerritorialInfoV1_descriptor_, &MapDataTerritorialInfoV1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapDataNodeMonsterInfoV1_descriptor_, &MapDataNodeMonsterInfoV1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapDataBaseConfigV1_descriptor_, &MapDataBaseConfigV1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapDataGatherInfoV1_descriptor_, &MapDataGatherInfoV1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapDataContourLineInfoV1_descriptor_, &MapDataContourLineInfoV1::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MapDataEventInfoV1_descriptor_, &MapDataEventInfoV1::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_MapDataV1Data_2eproto() {
  delete MapDataUselessV1::default_instance_;
  delete MapDataUselessV1_reflection_;
  delete MapDataLayerInfoV1::default_instance_;
  delete MapDataLayerInfoV1_reflection_;
  delete MapDataInfoV1::default_instance_;
  delete MapDataInfoV1_reflection_;
  delete MapDataVector2V1::default_instance_;
  delete MapDataVector2V1_reflection_;
  delete MapDataSpawnInfoV1::default_instance_;
  delete MapDataSpawnInfoV1_reflection_;
  delete MapDataDefeatInfoV1::default_instance_;
  delete MapDataDefeatInfoV1_reflection_;
  delete MapDataPerfectInfoV1::default_instance_;
  delete MapDataPerfectInfoV1_reflection_;
  delete MapDataPortalInfoV1::default_instance_;
  delete MapDataPortalInfoV1_reflection_;
  delete MapDataTrapInfoV1::default_instance_;
  delete MapDataTrapInfoV1_reflection_;
  delete MapDataNpcInfoV1::default_instance_;
  delete MapDataNpcInfoV1_reflection_;
  delete MapDataMonsterInfoV1::default_instance_;
  delete MapDataMonsterInfoV1_reflection_;
  delete MapDataNodeInfoV1::default_instance_;
  delete MapDataNodeInfoV1_reflection_;
  delete MapDataTerritorialInfoV1::default_instance_;
  delete MapDataTerritorialInfoV1_reflection_;
  delete MapDataNodeMonsterInfoV1::default_instance_;
  delete MapDataNodeMonsterInfoV1_reflection_;
  delete MapDataBaseConfigV1::default_instance_;
  delete MapDataBaseConfigV1_reflection_;
  delete MapDataGatherInfoV1::default_instance_;
  delete MapDataGatherInfoV1_reflection_;
  delete MapDataContourLineInfoV1::default_instance_;
  delete MapDataContourLineInfoV1_reflection_;
  delete MapDataEventInfoV1::default_instance_;
  delete MapDataEventInfoV1_reflection_;
}

void protobuf_AddDesc_MapDataV1Data_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::protobuf_AddDesc_PublicStruct_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\023MapDataV1Data.proto\032\022PublicStruct.prot"
    "o\"\"\n\020MapDataUselessV1\022\016\n\002X1\030\001 \001(\021:\002-1\"\326\001"
    "\n\022MapDataLayerInfoV1\022#\n\010WalkArea\030\002 \003(\0132\021"
    ".MapDataVector2V1\022#\n\010LostArea\030\003 \003(\0132\021.Ma"
    "pDataVector2V1\022\026\n\013ClientHight\030\004 \001(\002:\0010\022\014"
    "\n\001X\030\005 \001(\002:\0010\022\014\n\001Z\030\006 \001(\002:\0010\022\014\n\001Y\030\007 \001(\002:\0010"
    "\022\031\n\016MinHeightLimit\030\t \001(\002:\0010\022\031\n\016MaxHeight"
    "Limit\030\n \001(\002:\0010\"\253\004\n\rMapDataInfoV1\022%\n\010Laye"
    "rArr\030\001 \003(\0132\023.MapDataLayerInfoV1\022%\n\010Spawn"
    "Arr\030\002 \003(\0132\023.MapDataSpawnInfoV1\022$\n\006Defeat"
    "\030\003 \001(\0132\024.MapDataDefeatInfoV1\022)\n\nPerfectA"
    "rr\030\004 \003(\0132\025.MapDataPerfectInfoV1\022\'\n\tPorta"
    "lArr\030\005 \003(\0132\024.MapDataPortalInfoV1\022#\n\007Trap"
    "Arr\030\006 \003(\0132\022.MapDataTrapInfoV1\022!\n\006NpcArr\030"
    "\007 \003(\0132\021.MapDataNpcInfoV1\022#\n\007NodeArr\030\010 \003("
    "\0132\022.MapDataNodeInfoV1\022\014\n\004Name\030\t \001(\t\022/\n\014S"
    "tormBaseArr\030\n \003(\0132\031.MapDataTerritorialIn"
    "foV1\022,\n\tStormFlag\030\013 \001(\0132\031.MapDataTerrito"
    "rialInfoV1\022(\n\nBaseConfig\030\014 \001(\0132\024.MapData"
    "BaseConfigV1\022\'\n\tGatherArr\030\r \003(\0132\024.MapDat"
    "aGatherInfoV1\022%\n\010EventArr\030\016 \003(\0132\023.MapDat"
    "aEventInfoV1\"\276\001\n\020MapDataVector2V1\022\r\n\002X1\030"
    "\001 \001(\002:\0010\022\r\n\002X2\030\002 \001(\002:\0010\022\r\n\002Z1\030\004 \001(\002:\0010\022\r"
    "\n\002Z2\030\005 \001(\002:\0010\022\023\n\010OrgAngle\030\007 \001(\002:\0010\022\023\n\010Fi"
    "nAngle\030\010 \001(\002:\0010\022\021\n\006Radius\030\013 \001(\002:\0010\0221\n\016Co"
    "ntourLineArr\030\014 \003(\0132\031.MapDataContourLineI"
    "nfoV1\"\202\001\n\022MapDataSpawnInfoV1\022\014\n\001X\030\001 \001(\002:"
    "\0010\022\020\n\005Layer\030\002 \001(\021:\0010\022\031\n\016SpawnDirection\030\003"
    " \001(\021:\0011\022\014\n\001Z\030\004 \001(\002:\0010\022\021\n\006Radius\030\005 \001(\002:\0010"
    "\022\020\n\005Angle\030\006 \001(\002:\0010\"A\n\023MapDataDefeatInfoV"
    "1\022\024\n\tCondition\030\001 \001(\021:\0010\022\024\n\tTimeLimit\030\004 \001"
    "(\002:\0010\"\246\001\n\024MapDataPerfectInfoV1\022\025\n\tCondit"
    "ion\030\001 \001(\021:\002-1\022\030\n\rDeathCountNum\030\002 \001(\021:\0010\022"
    "\026\n\013KillEnemyID\030\003 \001(\021:\0010\022\031\n\016KillEnemyCoun"
    "t\030\004 \001(\021:\0010\022\024\n\tHpPercent\030\005 \001(\021:\0010\022\024\n\tTime"
    "Limit\030\006 \001(\002:\0010\"\222\003\n\023MapDataPortalInfoV1\022\022"
    "\n\007SourceX\030\001 \001(\002:\0010\022\026\n\013SourceLayer\030\002 \001(\021:"
    "\0010\022\023\n\007TargetX\030\003 \001(\002:\002-1\022\027\n\013TargetLayer\030\004"
    " \001(\021:\002-1\022\023\n\010UseCount\030\005 \001(\021:\0011\022\026\n\007Channel"
    "\030\006 \001(\010:\005false\022\025\n\nPortalType\030\007 \001(\021:\0010\022\032\n\017"
    "TargetDungeonId\030\010 \001(\021:\0010\022\033\n\020TargetSpawnI"
    "ndex\030\t \001(\021:\0010\022\032\n\017TargetDirection\030\n \001(\021:\001"
    "0\022\022\n\007SourceZ\030\013 \001(\002:\0010\022\022\n\007TargetZ\030\014 \001(\002:\001"
    "0\022\026\n\013SourceAngle\030\r \001(\002:\0010\022\026\n\013TargetAngle"
    "\030\016 \001(\002:\0010\022\027\n\014SourceRadius\030\017 \001(\002:\0010\022\027\n\014Ta"
    "rgetRadius\030\020 \001(\002:\0010\"f\n\021MapDataTrapInfoV1"
    "\022\021\n\006TrapID\030\001 \001(\021:\0010\022\014\n\001X\030\002 \001(\002:\0010\022\014\n\001Y\030\004"
    " \001(\002:\0010\022\024\n\tDirection\030\005 \001(\021:\0011\022\014\n\001Z\030\006 \001(\002"
    ":\0010\"\215\001\n\020MapDataNpcInfoV1\022\020\n\005NpcID\030\001 \001(\021:"
    "\0010\022\014\n\001X\030\002 \001(\002:\0010\022\020\n\005Layer\030\003 \001(\021:\0010\022\014\n\001Z\030"
    "\004 \001(\002:\0010\022\024\n\tDirection\030\005 \001(\021:\0011\022\020\n\005Angle\030"
    "\006 \001(\002:\0010\022\021\n\006Radius\030\007 \001(\002:\0010\"\273\004\n\024MapDataM"
    "onsterInfoV1\022\024\n\tMonsterID\030\001 \001(\021:\0010\022\014\n\001X\030"
    "\002 \001(\002:\0010\022\020\n\005Layer\030\003 \001(\021:\0010\022\026\n\013RepeatCoun"
    "t\030\004 \001(\021:\0011\022\033\n\020SpawmTriggerType\030\005 \001(\021:\0010\022"
    "\035\n\022RespawmTriggerType\030\006 \001(\021:\0010\022\024\n\010Patrol"
    "X1\030\013 \001(\002:\002-1\022\024\n\010PatrolX2\030\r \001(\002:\002-1\022\030\n\rSp"
    "awnNodeTime\030\016 \001(\002:\0010\022\033\n\020SpawnKillEnemyID"
    "\030\017 \001(\021:\0010\022\036\n\023SpawnKillEnemyCount\030\020 \001(\021:\001"
    "0\022\036\n\023SpawnAfterDeathTime\030\021 \001(\002:\0010\022\032\n\017Res"
    "pawnNodeTime\030\022 \001(\002:\0010\022\035\n\022RespawnKillEnem"
    "yID\030\023 \001(\021:\0010\022 \n\025RespawnKillEnemyCount\030\024 "
    "\001(\021:\0010\022 \n\025RespawnAfterDeathTime\030\025 \001(\002:\0010"
    "\022\034\n\021CreateMonsterType\030\026 \001(\021:\0010\0225\n\022NodeMo"
    "nsterInfoArr\030\030 \003(\0132\031.MapDataNodeMonsterI"
    "nfoV1\022\014\n\001Z\030\031 \001(\002:\0010\022\024\n\tDirection\030\032 \001(\021:\001"
    "1\"\367\001\n\021MapDataNodeInfoV1\022\014\n\001X\030\001 \001(\002:\0010\022\020\n"
    "\005Layer\030\002 \001(\021:\0010\022\030\n\rPassCondition\030\003 \001(\021:\001"
    "0\022\026\n\013KillEnemyID\030\004 \001(\021:\0010\022\031\n\016KillEnemyCo"
    "unt\030\005 \001(\021:\0010\022)\n\nMonsterArr\030\006 \003(\0132\025.MapDa"
    "taMonsterInfoV1\022\024\n\tTimeLimit\030\007 \001(\002:\0010\022\023\n"
    "\010NodeType\030\010 \001(\021:\0010\022\037\n\024NodeArrowDisplayTy"
    "pe\030\t \001(\021:\0010\"}\n\030MapDataTerritorialInfoV1\022"
    "\020\n\005Layer\030\001 \001(\021:\0010\022\037\n\004Area\030\002 \001(\0132\021.MapDat"
    "aVector2V1\022\014\n\001X\030\003 \001(\002:\0010\022\r\n\002ID\030\004 \001(\021:\0010\022"
    "\021\n\tModelName\030\005 \001(\t\"K\n\030MapDataNodeMonster"
    "InfoV1\022\025\n\tMonsterId\030\001 \001(\021:\002-1\022\030\n\014RandomW"
    "eight\030\002 \001(\021:\002-1\")\n\023MapDataBaseConfigV1\022\022"
    "\n\007MapType\030\001 \001(\021:\0010\"n\n\023MapDataGatherInfoV"
    "1\022\023\n\010GatherId\030\001 \001(\021:\0010\022\014\n\001X\030\002 \001(\002:\0010\022\020\n\005"
    "Layer\030\003 \001(\021:\0010\022\014\n\001Z\030\004 \001(\002:\0010\022\024\n\tDirectio"
    "n\030\005 \001(\021:\0011\")\n\030MapDataContourLineInfoV1\022\r"
    "\n\001Y\030\001 \001(\002:\002-1\"\207\001\n\022MapDataEventInfoV1\022\r\n\002"
    "X1\030\001 \001(\002:\0010\022\r\n\002Z1\030\002 \001(\002:\0010\022\r\n\002X2\030\003 \001(\002:\001"
    "0\022\r\n\002Z2\030\004 \001(\002:\0010\022\017\n\004Type\030\005 \001(\021:\0010\022\022\n\007Eve"
    "ntId\030\006 \001(\021:\0010\022\020\n\005Layer\030\007 \001(\021:\0010", 3431);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "MapDataV1Data.proto", &protobuf_RegisterTypes);
  MapDataUselessV1::default_instance_ = new MapDataUselessV1();
  MapDataLayerInfoV1::default_instance_ = new MapDataLayerInfoV1();
  MapDataInfoV1::default_instance_ = new MapDataInfoV1();
  MapDataVector2V1::default_instance_ = new MapDataVector2V1();
  MapDataSpawnInfoV1::default_instance_ = new MapDataSpawnInfoV1();
  MapDataDefeatInfoV1::default_instance_ = new MapDataDefeatInfoV1();
  MapDataPerfectInfoV1::default_instance_ = new MapDataPerfectInfoV1();
  MapDataPortalInfoV1::default_instance_ = new MapDataPortalInfoV1();
  MapDataTrapInfoV1::default_instance_ = new MapDataTrapInfoV1();
  MapDataNpcInfoV1::default_instance_ = new MapDataNpcInfoV1();
  MapDataMonsterInfoV1::default_instance_ = new MapDataMonsterInfoV1();
  MapDataNodeInfoV1::default_instance_ = new MapDataNodeInfoV1();
  MapDataTerritorialInfoV1::default_instance_ = new MapDataTerritorialInfoV1();
  MapDataNodeMonsterInfoV1::default_instance_ = new MapDataNodeMonsterInfoV1();
  MapDataBaseConfigV1::default_instance_ = new MapDataBaseConfigV1();
  MapDataGatherInfoV1::default_instance_ = new MapDataGatherInfoV1();
  MapDataContourLineInfoV1::default_instance_ = new MapDataContourLineInfoV1();
  MapDataEventInfoV1::default_instance_ = new MapDataEventInfoV1();
  MapDataUselessV1::default_instance_->InitAsDefaultInstance();
  MapDataLayerInfoV1::default_instance_->InitAsDefaultInstance();
  MapDataInfoV1::default_instance_->InitAsDefaultInstance();
  MapDataVector2V1::default_instance_->InitAsDefaultInstance();
  MapDataSpawnInfoV1::default_instance_->InitAsDefaultInstance();
  MapDataDefeatInfoV1::default_instance_->InitAsDefaultInstance();
  MapDataPerfectInfoV1::default_instance_->InitAsDefaultInstance();
  MapDataPortalInfoV1::default_instance_->InitAsDefaultInstance();
  MapDataTrapInfoV1::default_instance_->InitAsDefaultInstance();
  MapDataNpcInfoV1::default_instance_->InitAsDefaultInstance();
  MapDataMonsterInfoV1::default_instance_->InitAsDefaultInstance();
  MapDataNodeInfoV1::default_instance_->InitAsDefaultInstance();
  MapDataTerritorialInfoV1::default_instance_->InitAsDefaultInstance();
  MapDataNodeMonsterInfoV1::default_instance_->InitAsDefaultInstance();
  MapDataBaseConfigV1::default_instance_->InitAsDefaultInstance();
  MapDataGatherInfoV1::default_instance_->InitAsDefaultInstance();
  MapDataContourLineInfoV1::default_instance_->InitAsDefaultInstance();
  MapDataEventInfoV1::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_MapDataV1Data_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_MapDataV1Data_2eproto {
  StaticDescriptorInitializer_MapDataV1Data_2eproto() {
    protobuf_AddDesc_MapDataV1Data_2eproto();
  }
} static_descriptor_initializer_MapDataV1Data_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int MapDataUselessV1::kX1FieldNumber;
#endif  // !_MSC_VER

MapDataUselessV1::MapDataUselessV1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapDataUselessV1::InitAsDefaultInstance() {
}

MapDataUselessV1::MapDataUselessV1(const MapDataUselessV1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapDataUselessV1::SharedCtor() {
  _cached_size_ = 0;
  x1_ = -1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapDataUselessV1::~MapDataUselessV1() {
  SharedDtor();
}

void MapDataUselessV1::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapDataUselessV1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapDataUselessV1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapDataUselessV1_descriptor_;
}

const MapDataUselessV1& MapDataUselessV1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapDataV1Data_2eproto();
  return *default_instance_;
}

MapDataUselessV1* MapDataUselessV1::default_instance_ = NULL;

MapDataUselessV1* MapDataUselessV1::New() const {
  return new MapDataUselessV1;
}

void MapDataUselessV1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x1_ = -1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapDataUselessV1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint32 X1 = 1 [default = -1];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &x1_)));
          set_has_x1();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapDataUselessV1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional sint32 X1 = 1 [default = -1];
  if (has_x1()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(1, this->x1(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapDataUselessV1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional sint32 X1 = 1 [default = -1];
  if (has_x1()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(1, this->x1(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapDataUselessV1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional sint32 X1 = 1 [default = -1];
    if (has_x1()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->x1());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapDataUselessV1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapDataUselessV1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapDataUselessV1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapDataUselessV1::MergeFrom(const MapDataUselessV1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x1()) {
      set_x1(from.x1());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapDataUselessV1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapDataUselessV1::CopyFrom(const MapDataUselessV1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapDataUselessV1::IsInitialized() const {

  return true;
}

void MapDataUselessV1::Swap(MapDataUselessV1* other) {
  if (other != this) {
    std::swap(x1_, other->x1_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapDataUselessV1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapDataUselessV1_descriptor_;
  metadata.reflection = MapDataUselessV1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapDataLayerInfoV1::kWalkAreaFieldNumber;
const int MapDataLayerInfoV1::kLostAreaFieldNumber;
const int MapDataLayerInfoV1::kClientHightFieldNumber;
const int MapDataLayerInfoV1::kXFieldNumber;
const int MapDataLayerInfoV1::kZFieldNumber;
const int MapDataLayerInfoV1::kYFieldNumber;
const int MapDataLayerInfoV1::kMinHeightLimitFieldNumber;
const int MapDataLayerInfoV1::kMaxHeightLimitFieldNumber;
#endif  // !_MSC_VER

MapDataLayerInfoV1::MapDataLayerInfoV1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapDataLayerInfoV1::InitAsDefaultInstance() {
}

MapDataLayerInfoV1::MapDataLayerInfoV1(const MapDataLayerInfoV1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapDataLayerInfoV1::SharedCtor() {
  _cached_size_ = 0;
  clienthight_ = 0;
  x_ = 0;
  z_ = 0;
  y_ = 0;
  minheightlimit_ = 0;
  maxheightlimit_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapDataLayerInfoV1::~MapDataLayerInfoV1() {
  SharedDtor();
}

void MapDataLayerInfoV1::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapDataLayerInfoV1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapDataLayerInfoV1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapDataLayerInfoV1_descriptor_;
}

const MapDataLayerInfoV1& MapDataLayerInfoV1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapDataV1Data_2eproto();
  return *default_instance_;
}

MapDataLayerInfoV1* MapDataLayerInfoV1::default_instance_ = NULL;

MapDataLayerInfoV1* MapDataLayerInfoV1::New() const {
  return new MapDataLayerInfoV1;
}

void MapDataLayerInfoV1::Clear() {
  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    clienthight_ = 0;
    x_ = 0;
    z_ = 0;
    y_ = 0;
    minheightlimit_ = 0;
    maxheightlimit_ = 0;
  }
  walkarea_.Clear();
  lostarea_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapDataLayerInfoV1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .MapDataVector2V1 WalkArea = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_WalkArea:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_walkarea()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_WalkArea;
        if (input->ExpectTag(26)) goto parse_LostArea;
        break;
      }

      // repeated .MapDataVector2V1 LostArea = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_LostArea:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lostarea()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_LostArea;
        if (input->ExpectTag(37)) goto parse_ClientHight;
        break;
      }

      // optional float ClientHight = 4 [default = 0];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_ClientHight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &clienthight_)));
          set_has_clienthight();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_X;
        break;
      }

      // optional float X = 5 [default = 0];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_X:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_Z;
        break;
      }

      // optional float Z = 6 [default = 0];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_Z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_Y;
        break;
      }

      // optional float Y = 7 [default = 0];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_Y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(77)) goto parse_MinHeightLimit;
        break;
      }

      // optional float MinHeightLimit = 9 [default = 0];
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_MinHeightLimit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &minheightlimit_)));
          set_has_minheightlimit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(85)) goto parse_MaxHeightLimit;
        break;
      }

      // optional float MaxHeightLimit = 10 [default = 0];
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_MaxHeightLimit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &maxheightlimit_)));
          set_has_maxheightlimit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapDataLayerInfoV1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .MapDataVector2V1 WalkArea = 2;
  for (int i = 0; i < this->walkarea_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->walkarea(i), output);
  }

  // repeated .MapDataVector2V1 LostArea = 3;
  for (int i = 0; i < this->lostarea_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->lostarea(i), output);
  }

  // optional float ClientHight = 4 [default = 0];
  if (has_clienthight()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->clienthight(), output);
  }

  // optional float X = 5 [default = 0];
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->x(), output);
  }

  // optional float Z = 6 [default = 0];
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->z(), output);
  }

  // optional float Y = 7 [default = 0];
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->y(), output);
  }

  // optional float MinHeightLimit = 9 [default = 0];
  if (has_minheightlimit()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(9, this->minheightlimit(), output);
  }

  // optional float MaxHeightLimit = 10 [default = 0];
  if (has_maxheightlimit()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(10, this->maxheightlimit(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapDataLayerInfoV1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .MapDataVector2V1 WalkArea = 2;
  for (int i = 0; i < this->walkarea_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->walkarea(i), target);
  }

  // repeated .MapDataVector2V1 LostArea = 3;
  for (int i = 0; i < this->lostarea_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->lostarea(i), target);
  }

  // optional float ClientHight = 4 [default = 0];
  if (has_clienthight()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->clienthight(), target);
  }

  // optional float X = 5 [default = 0];
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->x(), target);
  }

  // optional float Z = 6 [default = 0];
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->z(), target);
  }

  // optional float Y = 7 [default = 0];
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->y(), target);
  }

  // optional float MinHeightLimit = 9 [default = 0];
  if (has_minheightlimit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(9, this->minheightlimit(), target);
  }

  // optional float MaxHeightLimit = 10 [default = 0];
  if (has_maxheightlimit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(10, this->maxheightlimit(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapDataLayerInfoV1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // optional float ClientHight = 4 [default = 0];
    if (has_clienthight()) {
      total_size += 1 + 4;
    }

    // optional float X = 5 [default = 0];
    if (has_x()) {
      total_size += 1 + 4;
    }

    // optional float Z = 6 [default = 0];
    if (has_z()) {
      total_size += 1 + 4;
    }

    // optional float Y = 7 [default = 0];
    if (has_y()) {
      total_size += 1 + 4;
    }

    // optional float MinHeightLimit = 9 [default = 0];
    if (has_minheightlimit()) {
      total_size += 1 + 4;
    }

    // optional float MaxHeightLimit = 10 [default = 0];
    if (has_maxheightlimit()) {
      total_size += 1 + 4;
    }

  }
  // repeated .MapDataVector2V1 WalkArea = 2;
  total_size += 1 * this->walkarea_size();
  for (int i = 0; i < this->walkarea_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->walkarea(i));
  }

  // repeated .MapDataVector2V1 LostArea = 3;
  total_size += 1 * this->lostarea_size();
  for (int i = 0; i < this->lostarea_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lostarea(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapDataLayerInfoV1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapDataLayerInfoV1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapDataLayerInfoV1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapDataLayerInfoV1::MergeFrom(const MapDataLayerInfoV1& from) {
  GOOGLE_CHECK_NE(&from, this);
  walkarea_.MergeFrom(from.walkarea_);
  lostarea_.MergeFrom(from.lostarea_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_clienthight()) {
      set_clienthight(from.clienthight());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_minheightlimit()) {
      set_minheightlimit(from.minheightlimit());
    }
    if (from.has_maxheightlimit()) {
      set_maxheightlimit(from.maxheightlimit());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapDataLayerInfoV1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapDataLayerInfoV1::CopyFrom(const MapDataLayerInfoV1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapDataLayerInfoV1::IsInitialized() const {

  return true;
}

void MapDataLayerInfoV1::Swap(MapDataLayerInfoV1* other) {
  if (other != this) {
    walkarea_.Swap(&other->walkarea_);
    lostarea_.Swap(&other->lostarea_);
    std::swap(clienthight_, other->clienthight_);
    std::swap(x_, other->x_);
    std::swap(z_, other->z_);
    std::swap(y_, other->y_);
    std::swap(minheightlimit_, other->minheightlimit_);
    std::swap(maxheightlimit_, other->maxheightlimit_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapDataLayerInfoV1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapDataLayerInfoV1_descriptor_;
  metadata.reflection = MapDataLayerInfoV1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapDataInfoV1::kLayerArrFieldNumber;
const int MapDataInfoV1::kSpawnArrFieldNumber;
const int MapDataInfoV1::kDefeatFieldNumber;
const int MapDataInfoV1::kPerfectArrFieldNumber;
const int MapDataInfoV1::kPortalArrFieldNumber;
const int MapDataInfoV1::kTrapArrFieldNumber;
const int MapDataInfoV1::kNpcArrFieldNumber;
const int MapDataInfoV1::kNodeArrFieldNumber;
const int MapDataInfoV1::kNameFieldNumber;
const int MapDataInfoV1::kStormBaseArrFieldNumber;
const int MapDataInfoV1::kStormFlagFieldNumber;
const int MapDataInfoV1::kBaseConfigFieldNumber;
const int MapDataInfoV1::kGatherArrFieldNumber;
const int MapDataInfoV1::kEventArrFieldNumber;
#endif  // !_MSC_VER

MapDataInfoV1::MapDataInfoV1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapDataInfoV1::InitAsDefaultInstance() {
  defeat_ = const_cast< ::MapDataDefeatInfoV1*>(&::MapDataDefeatInfoV1::default_instance());
  stormflag_ = const_cast< ::MapDataTerritorialInfoV1*>(&::MapDataTerritorialInfoV1::default_instance());
  baseconfig_ = const_cast< ::MapDataBaseConfigV1*>(&::MapDataBaseConfigV1::default_instance());
}

MapDataInfoV1::MapDataInfoV1(const MapDataInfoV1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapDataInfoV1::SharedCtor() {
  _cached_size_ = 0;
  defeat_ = NULL;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  stormflag_ = NULL;
  baseconfig_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapDataInfoV1::~MapDataInfoV1() {
  SharedDtor();
}

void MapDataInfoV1::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
    delete defeat_;
    delete stormflag_;
    delete baseconfig_;
  }
}

void MapDataInfoV1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapDataInfoV1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapDataInfoV1_descriptor_;
}

const MapDataInfoV1& MapDataInfoV1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapDataV1Data_2eproto();
  return *default_instance_;
}

MapDataInfoV1* MapDataInfoV1::default_instance_ = NULL;

MapDataInfoV1* MapDataInfoV1::New() const {
  return new MapDataInfoV1;
}

void MapDataInfoV1::Clear() {
  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (has_defeat()) {
      if (defeat_ != NULL) defeat_->::MapDataDefeatInfoV1::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_stormflag()) {
      if (stormflag_ != NULL) stormflag_->::MapDataTerritorialInfoV1::Clear();
    }
    if (has_baseconfig()) {
      if (baseconfig_ != NULL) baseconfig_->::MapDataBaseConfigV1::Clear();
    }
  }
  layerarr_.Clear();
  spawnarr_.Clear();
  perfectarr_.Clear();
  portalarr_.Clear();
  traparr_.Clear();
  npcarr_.Clear();
  nodearr_.Clear();
  stormbasearr_.Clear();
  gatherarr_.Clear();
  eventarr_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapDataInfoV1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .MapDataLayerInfoV1 LayerArr = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_LayerArr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_layerarr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_LayerArr;
        if (input->ExpectTag(18)) goto parse_SpawnArr;
        break;
      }

      // repeated .MapDataSpawnInfoV1 SpawnArr = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_SpawnArr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_spawnarr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_SpawnArr;
        if (input->ExpectTag(26)) goto parse_Defeat;
        break;
      }

      // optional .MapDataDefeatInfoV1 Defeat = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Defeat:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_defeat()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_PerfectArr;
        break;
      }

      // repeated .MapDataPerfectInfoV1 PerfectArr = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_PerfectArr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_perfectarr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_PerfectArr;
        if (input->ExpectTag(42)) goto parse_PortalArr;
        break;
      }

      // repeated .MapDataPortalInfoV1 PortalArr = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_PortalArr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_portalarr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_PortalArr;
        if (input->ExpectTag(50)) goto parse_TrapArr;
        break;
      }

      // repeated .MapDataTrapInfoV1 TrapArr = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_TrapArr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_traparr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_TrapArr;
        if (input->ExpectTag(58)) goto parse_NpcArr;
        break;
      }

      // repeated .MapDataNpcInfoV1 NpcArr = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_NpcArr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_npcarr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_NpcArr;
        if (input->ExpectTag(66)) goto parse_NodeArr;
        break;
      }

      // repeated .MapDataNodeInfoV1 NodeArr = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_NodeArr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_nodearr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_NodeArr;
        if (input->ExpectTag(74)) goto parse_Name;
        break;
      }

      // optional string Name = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_StormBaseArr;
        break;
      }

      // repeated .MapDataTerritorialInfoV1 StormBaseArr = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_StormBaseArr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_stormbasearr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_StormBaseArr;
        if (input->ExpectTag(90)) goto parse_StormFlag;
        break;
      }

      // optional .MapDataTerritorialInfoV1 StormFlag = 11;
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_StormFlag:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_stormflag()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_BaseConfig;
        break;
      }

      // optional .MapDataBaseConfigV1 BaseConfig = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_BaseConfig:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_baseconfig()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_GatherArr;
        break;
      }

      // repeated .MapDataGatherInfoV1 GatherArr = 13;
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_GatherArr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_gatherarr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(106)) goto parse_GatherArr;
        if (input->ExpectTag(114)) goto parse_EventArr;
        break;
      }

      // repeated .MapDataEventInfoV1 EventArr = 14;
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_EventArr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_eventarr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(114)) goto parse_EventArr;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapDataInfoV1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .MapDataLayerInfoV1 LayerArr = 1;
  for (int i = 0; i < this->layerarr_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->layerarr(i), output);
  }

  // repeated .MapDataSpawnInfoV1 SpawnArr = 2;
  for (int i = 0; i < this->spawnarr_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->spawnarr(i), output);
  }

  // optional .MapDataDefeatInfoV1 Defeat = 3;
  if (has_defeat()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->defeat(), output);
  }

  // repeated .MapDataPerfectInfoV1 PerfectArr = 4;
  for (int i = 0; i < this->perfectarr_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->perfectarr(i), output);
  }

  // repeated .MapDataPortalInfoV1 PortalArr = 5;
  for (int i = 0; i < this->portalarr_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->portalarr(i), output);
  }

  // repeated .MapDataTrapInfoV1 TrapArr = 6;
  for (int i = 0; i < this->traparr_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->traparr(i), output);
  }

  // repeated .MapDataNpcInfoV1 NpcArr = 7;
  for (int i = 0; i < this->npcarr_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->npcarr(i), output);
  }

  // repeated .MapDataNodeInfoV1 NodeArr = 8;
  for (int i = 0; i < this->nodearr_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->nodearr(i), output);
  }

  // optional string Name = 9;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      9, this->name(), output);
  }

  // repeated .MapDataTerritorialInfoV1 StormBaseArr = 10;
  for (int i = 0; i < this->stormbasearr_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->stormbasearr(i), output);
  }

  // optional .MapDataTerritorialInfoV1 StormFlag = 11;
  if (has_stormflag()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, this->stormflag(), output);
  }

  // optional .MapDataBaseConfigV1 BaseConfig = 12;
  if (has_baseconfig()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->baseconfig(), output);
  }

  // repeated .MapDataGatherInfoV1 GatherArr = 13;
  for (int i = 0; i < this->gatherarr_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, this->gatherarr(i), output);
  }

  // repeated .MapDataEventInfoV1 EventArr = 14;
  for (int i = 0; i < this->eventarr_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, this->eventarr(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapDataInfoV1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .MapDataLayerInfoV1 LayerArr = 1;
  for (int i = 0; i < this->layerarr_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->layerarr(i), target);
  }

  // repeated .MapDataSpawnInfoV1 SpawnArr = 2;
  for (int i = 0; i < this->spawnarr_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->spawnarr(i), target);
  }

  // optional .MapDataDefeatInfoV1 Defeat = 3;
  if (has_defeat()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->defeat(), target);
  }

  // repeated .MapDataPerfectInfoV1 PerfectArr = 4;
  for (int i = 0; i < this->perfectarr_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->perfectarr(i), target);
  }

  // repeated .MapDataPortalInfoV1 PortalArr = 5;
  for (int i = 0; i < this->portalarr_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->portalarr(i), target);
  }

  // repeated .MapDataTrapInfoV1 TrapArr = 6;
  for (int i = 0; i < this->traparr_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->traparr(i), target);
  }

  // repeated .MapDataNpcInfoV1 NpcArr = 7;
  for (int i = 0; i < this->npcarr_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->npcarr(i), target);
  }

  // repeated .MapDataNodeInfoV1 NodeArr = 8;
  for (int i = 0; i < this->nodearr_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->nodearr(i), target);
  }

  // optional string Name = 9;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->name(), target);
  }

  // repeated .MapDataTerritorialInfoV1 StormBaseArr = 10;
  for (int i = 0; i < this->stormbasearr_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->stormbasearr(i), target);
  }

  // optional .MapDataTerritorialInfoV1 StormFlag = 11;
  if (has_stormflag()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        11, this->stormflag(), target);
  }

  // optional .MapDataBaseConfigV1 BaseConfig = 12;
  if (has_baseconfig()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->baseconfig(), target);
  }

  // repeated .MapDataGatherInfoV1 GatherArr = 13;
  for (int i = 0; i < this->gatherarr_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        13, this->gatherarr(i), target);
  }

  // repeated .MapDataEventInfoV1 EventArr = 14;
  for (int i = 0; i < this->eventarr_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        14, this->eventarr(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapDataInfoV1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    // optional .MapDataDefeatInfoV1 Defeat = 3;
    if (has_defeat()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->defeat());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional string Name = 9;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .MapDataTerritorialInfoV1 StormFlag = 11;
    if (has_stormflag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->stormflag());
    }

    // optional .MapDataBaseConfigV1 BaseConfig = 12;
    if (has_baseconfig()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->baseconfig());
    }

  }
  // repeated .MapDataLayerInfoV1 LayerArr = 1;
  total_size += 1 * this->layerarr_size();
  for (int i = 0; i < this->layerarr_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->layerarr(i));
  }

  // repeated .MapDataSpawnInfoV1 SpawnArr = 2;
  total_size += 1 * this->spawnarr_size();
  for (int i = 0; i < this->spawnarr_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->spawnarr(i));
  }

  // repeated .MapDataPerfectInfoV1 PerfectArr = 4;
  total_size += 1 * this->perfectarr_size();
  for (int i = 0; i < this->perfectarr_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->perfectarr(i));
  }

  // repeated .MapDataPortalInfoV1 PortalArr = 5;
  total_size += 1 * this->portalarr_size();
  for (int i = 0; i < this->portalarr_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->portalarr(i));
  }

  // repeated .MapDataTrapInfoV1 TrapArr = 6;
  total_size += 1 * this->traparr_size();
  for (int i = 0; i < this->traparr_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->traparr(i));
  }

  // repeated .MapDataNpcInfoV1 NpcArr = 7;
  total_size += 1 * this->npcarr_size();
  for (int i = 0; i < this->npcarr_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->npcarr(i));
  }

  // repeated .MapDataNodeInfoV1 NodeArr = 8;
  total_size += 1 * this->nodearr_size();
  for (int i = 0; i < this->nodearr_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->nodearr(i));
  }

  // repeated .MapDataTerritorialInfoV1 StormBaseArr = 10;
  total_size += 1 * this->stormbasearr_size();
  for (int i = 0; i < this->stormbasearr_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->stormbasearr(i));
  }

  // repeated .MapDataGatherInfoV1 GatherArr = 13;
  total_size += 1 * this->gatherarr_size();
  for (int i = 0; i < this->gatherarr_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->gatherarr(i));
  }

  // repeated .MapDataEventInfoV1 EventArr = 14;
  total_size += 1 * this->eventarr_size();
  for (int i = 0; i < this->eventarr_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->eventarr(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapDataInfoV1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapDataInfoV1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapDataInfoV1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapDataInfoV1::MergeFrom(const MapDataInfoV1& from) {
  GOOGLE_CHECK_NE(&from, this);
  layerarr_.MergeFrom(from.layerarr_);
  spawnarr_.MergeFrom(from.spawnarr_);
  perfectarr_.MergeFrom(from.perfectarr_);
  portalarr_.MergeFrom(from.portalarr_);
  traparr_.MergeFrom(from.traparr_);
  npcarr_.MergeFrom(from.npcarr_);
  nodearr_.MergeFrom(from.nodearr_);
  stormbasearr_.MergeFrom(from.stormbasearr_);
  gatherarr_.MergeFrom(from.gatherarr_);
  eventarr_.MergeFrom(from.eventarr_);
  if (from._has_bits_[2 / 32] & (0xffu << (2 % 32))) {
    if (from.has_defeat()) {
      mutable_defeat()->::MapDataDefeatInfoV1::MergeFrom(from.defeat());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_stormflag()) {
      mutable_stormflag()->::MapDataTerritorialInfoV1::MergeFrom(from.stormflag());
    }
    if (from.has_baseconfig()) {
      mutable_baseconfig()->::MapDataBaseConfigV1::MergeFrom(from.baseconfig());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapDataInfoV1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapDataInfoV1::CopyFrom(const MapDataInfoV1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapDataInfoV1::IsInitialized() const {

  return true;
}

void MapDataInfoV1::Swap(MapDataInfoV1* other) {
  if (other != this) {
    layerarr_.Swap(&other->layerarr_);
    spawnarr_.Swap(&other->spawnarr_);
    std::swap(defeat_, other->defeat_);
    perfectarr_.Swap(&other->perfectarr_);
    portalarr_.Swap(&other->portalarr_);
    traparr_.Swap(&other->traparr_);
    npcarr_.Swap(&other->npcarr_);
    nodearr_.Swap(&other->nodearr_);
    std::swap(name_, other->name_);
    stormbasearr_.Swap(&other->stormbasearr_);
    std::swap(stormflag_, other->stormflag_);
    std::swap(baseconfig_, other->baseconfig_);
    gatherarr_.Swap(&other->gatherarr_);
    eventarr_.Swap(&other->eventarr_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapDataInfoV1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapDataInfoV1_descriptor_;
  metadata.reflection = MapDataInfoV1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapDataVector2V1::kX1FieldNumber;
const int MapDataVector2V1::kX2FieldNumber;
const int MapDataVector2V1::kZ1FieldNumber;
const int MapDataVector2V1::kZ2FieldNumber;
const int MapDataVector2V1::kOrgAngleFieldNumber;
const int MapDataVector2V1::kFinAngleFieldNumber;
const int MapDataVector2V1::kRadiusFieldNumber;
const int MapDataVector2V1::kContourLineArrFieldNumber;
#endif  // !_MSC_VER

MapDataVector2V1::MapDataVector2V1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapDataVector2V1::InitAsDefaultInstance() {
}

MapDataVector2V1::MapDataVector2V1(const MapDataVector2V1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapDataVector2V1::SharedCtor() {
  _cached_size_ = 0;
  x1_ = 0;
  x2_ = 0;
  z1_ = 0;
  z2_ = 0;
  organgle_ = 0;
  finangle_ = 0;
  radius_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapDataVector2V1::~MapDataVector2V1() {
  SharedDtor();
}

void MapDataVector2V1::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapDataVector2V1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapDataVector2V1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapDataVector2V1_descriptor_;
}

const MapDataVector2V1& MapDataVector2V1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapDataV1Data_2eproto();
  return *default_instance_;
}

MapDataVector2V1* MapDataVector2V1::default_instance_ = NULL;

MapDataVector2V1* MapDataVector2V1::New() const {
  return new MapDataVector2V1;
}

void MapDataVector2V1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x1_ = 0;
    x2_ = 0;
    z1_ = 0;
    z2_ = 0;
    organgle_ = 0;
    finangle_ = 0;
    radius_ = 0;
  }
  contourlinearr_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapDataVector2V1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float X1 = 1 [default = 0];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x1_)));
          set_has_x1();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_X2;
        break;
      }

      // optional float X2 = 2 [default = 0];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_X2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x2_)));
          set_has_x2();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_Z1;
        break;
      }

      // optional float Z1 = 4 [default = 0];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_Z1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z1_)));
          set_has_z1();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_Z2;
        break;
      }

      // optional float Z2 = 5 [default = 0];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_Z2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z2_)));
          set_has_z2();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_OrgAngle;
        break;
      }

      // optional float OrgAngle = 7 [default = 0];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_OrgAngle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &organgle_)));
          set_has_organgle();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_FinAngle;
        break;
      }

      // optional float FinAngle = 8 [default = 0];
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_FinAngle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &finangle_)));
          set_has_finangle();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(93)) goto parse_Radius;
        break;
      }

      // optional float Radius = 11 [default = 0];
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_Radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_ContourLineArr;
        break;
      }

      // repeated .MapDataContourLineInfoV1 ContourLineArr = 12;
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ContourLineArr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_contourlinearr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(98)) goto parse_ContourLineArr;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapDataVector2V1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float X1 = 1 [default = 0];
  if (has_x1()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x1(), output);
  }

  // optional float X2 = 2 [default = 0];
  if (has_x2()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->x2(), output);
  }

  // optional float Z1 = 4 [default = 0];
  if (has_z1()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->z1(), output);
  }

  // optional float Z2 = 5 [default = 0];
  if (has_z2()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->z2(), output);
  }

  // optional float OrgAngle = 7 [default = 0];
  if (has_organgle()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->organgle(), output);
  }

  // optional float FinAngle = 8 [default = 0];
  if (has_finangle()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->finangle(), output);
  }

  // optional float Radius = 11 [default = 0];
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->radius(), output);
  }

  // repeated .MapDataContourLineInfoV1 ContourLineArr = 12;
  for (int i = 0; i < this->contourlinearr_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, this->contourlinearr(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapDataVector2V1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional float X1 = 1 [default = 0];
  if (has_x1()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x1(), target);
  }

  // optional float X2 = 2 [default = 0];
  if (has_x2()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->x2(), target);
  }

  // optional float Z1 = 4 [default = 0];
  if (has_z1()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->z1(), target);
  }

  // optional float Z2 = 5 [default = 0];
  if (has_z2()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->z2(), target);
  }

  // optional float OrgAngle = 7 [default = 0];
  if (has_organgle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->organgle(), target);
  }

  // optional float FinAngle = 8 [default = 0];
  if (has_finangle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->finangle(), target);
  }

  // optional float Radius = 11 [default = 0];
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(11, this->radius(), target);
  }

  // repeated .MapDataContourLineInfoV1 ContourLineArr = 12;
  for (int i = 0; i < this->contourlinearr_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        12, this->contourlinearr(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapDataVector2V1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float X1 = 1 [default = 0];
    if (has_x1()) {
      total_size += 1 + 4;
    }

    // optional float X2 = 2 [default = 0];
    if (has_x2()) {
      total_size += 1 + 4;
    }

    // optional float Z1 = 4 [default = 0];
    if (has_z1()) {
      total_size += 1 + 4;
    }

    // optional float Z2 = 5 [default = 0];
    if (has_z2()) {
      total_size += 1 + 4;
    }

    // optional float OrgAngle = 7 [default = 0];
    if (has_organgle()) {
      total_size += 1 + 4;
    }

    // optional float FinAngle = 8 [default = 0];
    if (has_finangle()) {
      total_size += 1 + 4;
    }

    // optional float Radius = 11 [default = 0];
    if (has_radius()) {
      total_size += 1 + 4;
    }

  }
  // repeated .MapDataContourLineInfoV1 ContourLineArr = 12;
  total_size += 1 * this->contourlinearr_size();
  for (int i = 0; i < this->contourlinearr_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->contourlinearr(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapDataVector2V1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapDataVector2V1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapDataVector2V1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapDataVector2V1::MergeFrom(const MapDataVector2V1& from) {
  GOOGLE_CHECK_NE(&from, this);
  contourlinearr_.MergeFrom(from.contourlinearr_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x1()) {
      set_x1(from.x1());
    }
    if (from.has_x2()) {
      set_x2(from.x2());
    }
    if (from.has_z1()) {
      set_z1(from.z1());
    }
    if (from.has_z2()) {
      set_z2(from.z2());
    }
    if (from.has_organgle()) {
      set_organgle(from.organgle());
    }
    if (from.has_finangle()) {
      set_finangle(from.finangle());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapDataVector2V1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapDataVector2V1::CopyFrom(const MapDataVector2V1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapDataVector2V1::IsInitialized() const {

  return true;
}

void MapDataVector2V1::Swap(MapDataVector2V1* other) {
  if (other != this) {
    std::swap(x1_, other->x1_);
    std::swap(x2_, other->x2_);
    std::swap(z1_, other->z1_);
    std::swap(z2_, other->z2_);
    std::swap(organgle_, other->organgle_);
    std::swap(finangle_, other->finangle_);
    std::swap(radius_, other->radius_);
    contourlinearr_.Swap(&other->contourlinearr_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapDataVector2V1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapDataVector2V1_descriptor_;
  metadata.reflection = MapDataVector2V1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapDataSpawnInfoV1::kXFieldNumber;
const int MapDataSpawnInfoV1::kLayerFieldNumber;
const int MapDataSpawnInfoV1::kSpawnDirectionFieldNumber;
const int MapDataSpawnInfoV1::kZFieldNumber;
const int MapDataSpawnInfoV1::kRadiusFieldNumber;
const int MapDataSpawnInfoV1::kAngleFieldNumber;
#endif  // !_MSC_VER

MapDataSpawnInfoV1::MapDataSpawnInfoV1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapDataSpawnInfoV1::InitAsDefaultInstance() {
}

MapDataSpawnInfoV1::MapDataSpawnInfoV1(const MapDataSpawnInfoV1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapDataSpawnInfoV1::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  layer_ = 0;
  spawndirection_ = 1;
  z_ = 0;
  radius_ = 0;
  angle_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapDataSpawnInfoV1::~MapDataSpawnInfoV1() {
  SharedDtor();
}

void MapDataSpawnInfoV1::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapDataSpawnInfoV1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapDataSpawnInfoV1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapDataSpawnInfoV1_descriptor_;
}

const MapDataSpawnInfoV1& MapDataSpawnInfoV1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapDataV1Data_2eproto();
  return *default_instance_;
}

MapDataSpawnInfoV1* MapDataSpawnInfoV1::default_instance_ = NULL;

MapDataSpawnInfoV1* MapDataSpawnInfoV1::New() const {
  return new MapDataSpawnInfoV1;
}

void MapDataSpawnInfoV1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    layer_ = 0;
    spawndirection_ = 1;
    z_ = 0;
    radius_ = 0;
    angle_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapDataSpawnInfoV1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float X = 1 [default = 0];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_Layer;
        break;
      }

      // optional sint32 Layer = 2 [default = 0];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Layer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &layer_)));
          set_has_layer();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_SpawnDirection;
        break;
      }

      // optional sint32 SpawnDirection = 3 [default = 1];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SpawnDirection:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &spawndirection_)));
          set_has_spawndirection();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_Z;
        break;
      }

      // optional float Z = 4 [default = 0];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_Z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(45)) goto parse_Radius;
        break;
      }

      // optional float Radius = 5 [default = 0];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_Radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_Angle;
        break;
      }

      // optional float Angle = 6 [default = 0];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_Angle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &angle_)));
          set_has_angle();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapDataSpawnInfoV1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float X = 1 [default = 0];
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // optional sint32 Layer = 2 [default = 0];
  if (has_layer()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(2, this->layer(), output);
  }

  // optional sint32 SpawnDirection = 3 [default = 1];
  if (has_spawndirection()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(3, this->spawndirection(), output);
  }

  // optional float Z = 4 [default = 0];
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->z(), output);
  }

  // optional float Radius = 5 [default = 0];
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->radius(), output);
  }

  // optional float Angle = 6 [default = 0];
  if (has_angle()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->angle(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapDataSpawnInfoV1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional float X = 1 [default = 0];
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // optional sint32 Layer = 2 [default = 0];
  if (has_layer()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(2, this->layer(), target);
  }

  // optional sint32 SpawnDirection = 3 [default = 1];
  if (has_spawndirection()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(3, this->spawndirection(), target);
  }

  // optional float Z = 4 [default = 0];
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->z(), target);
  }

  // optional float Radius = 5 [default = 0];
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->radius(), target);
  }

  // optional float Angle = 6 [default = 0];
  if (has_angle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->angle(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapDataSpawnInfoV1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float X = 1 [default = 0];
    if (has_x()) {
      total_size += 1 + 4;
    }

    // optional sint32 Layer = 2 [default = 0];
    if (has_layer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->layer());
    }

    // optional sint32 SpawnDirection = 3 [default = 1];
    if (has_spawndirection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->spawndirection());
    }

    // optional float Z = 4 [default = 0];
    if (has_z()) {
      total_size += 1 + 4;
    }

    // optional float Radius = 5 [default = 0];
    if (has_radius()) {
      total_size += 1 + 4;
    }

    // optional float Angle = 6 [default = 0];
    if (has_angle()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapDataSpawnInfoV1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapDataSpawnInfoV1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapDataSpawnInfoV1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapDataSpawnInfoV1::MergeFrom(const MapDataSpawnInfoV1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_layer()) {
      set_layer(from.layer());
    }
    if (from.has_spawndirection()) {
      set_spawndirection(from.spawndirection());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
    if (from.has_angle()) {
      set_angle(from.angle());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapDataSpawnInfoV1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapDataSpawnInfoV1::CopyFrom(const MapDataSpawnInfoV1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapDataSpawnInfoV1::IsInitialized() const {

  return true;
}

void MapDataSpawnInfoV1::Swap(MapDataSpawnInfoV1* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(layer_, other->layer_);
    std::swap(spawndirection_, other->spawndirection_);
    std::swap(z_, other->z_);
    std::swap(radius_, other->radius_);
    std::swap(angle_, other->angle_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapDataSpawnInfoV1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapDataSpawnInfoV1_descriptor_;
  metadata.reflection = MapDataSpawnInfoV1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapDataDefeatInfoV1::kConditionFieldNumber;
const int MapDataDefeatInfoV1::kTimeLimitFieldNumber;
#endif  // !_MSC_VER

MapDataDefeatInfoV1::MapDataDefeatInfoV1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapDataDefeatInfoV1::InitAsDefaultInstance() {
}

MapDataDefeatInfoV1::MapDataDefeatInfoV1(const MapDataDefeatInfoV1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapDataDefeatInfoV1::SharedCtor() {
  _cached_size_ = 0;
  condition_ = 0;
  timelimit_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapDataDefeatInfoV1::~MapDataDefeatInfoV1() {
  SharedDtor();
}

void MapDataDefeatInfoV1::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapDataDefeatInfoV1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapDataDefeatInfoV1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapDataDefeatInfoV1_descriptor_;
}

const MapDataDefeatInfoV1& MapDataDefeatInfoV1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapDataV1Data_2eproto();
  return *default_instance_;
}

MapDataDefeatInfoV1* MapDataDefeatInfoV1::default_instance_ = NULL;

MapDataDefeatInfoV1* MapDataDefeatInfoV1::New() const {
  return new MapDataDefeatInfoV1;
}

void MapDataDefeatInfoV1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    condition_ = 0;
    timelimit_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapDataDefeatInfoV1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint32 Condition = 1 [default = 0];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &condition_)));
          set_has_condition();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_TimeLimit;
        break;
      }

      // optional float TimeLimit = 4 [default = 0];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_TimeLimit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &timelimit_)));
          set_has_timelimit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapDataDefeatInfoV1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional sint32 Condition = 1 [default = 0];
  if (has_condition()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(1, this->condition(), output);
  }

  // optional float TimeLimit = 4 [default = 0];
  if (has_timelimit()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->timelimit(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapDataDefeatInfoV1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional sint32 Condition = 1 [default = 0];
  if (has_condition()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(1, this->condition(), target);
  }

  // optional float TimeLimit = 4 [default = 0];
  if (has_timelimit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->timelimit(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapDataDefeatInfoV1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional sint32 Condition = 1 [default = 0];
    if (has_condition()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->condition());
    }

    // optional float TimeLimit = 4 [default = 0];
    if (has_timelimit()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapDataDefeatInfoV1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapDataDefeatInfoV1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapDataDefeatInfoV1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapDataDefeatInfoV1::MergeFrom(const MapDataDefeatInfoV1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_condition()) {
      set_condition(from.condition());
    }
    if (from.has_timelimit()) {
      set_timelimit(from.timelimit());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapDataDefeatInfoV1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapDataDefeatInfoV1::CopyFrom(const MapDataDefeatInfoV1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapDataDefeatInfoV1::IsInitialized() const {

  return true;
}

void MapDataDefeatInfoV1::Swap(MapDataDefeatInfoV1* other) {
  if (other != this) {
    std::swap(condition_, other->condition_);
    std::swap(timelimit_, other->timelimit_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapDataDefeatInfoV1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapDataDefeatInfoV1_descriptor_;
  metadata.reflection = MapDataDefeatInfoV1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapDataPerfectInfoV1::kConditionFieldNumber;
const int MapDataPerfectInfoV1::kDeathCountNumFieldNumber;
const int MapDataPerfectInfoV1::kKillEnemyIDFieldNumber;
const int MapDataPerfectInfoV1::kKillEnemyCountFieldNumber;
const int MapDataPerfectInfoV1::kHpPercentFieldNumber;
const int MapDataPerfectInfoV1::kTimeLimitFieldNumber;
#endif  // !_MSC_VER

MapDataPerfectInfoV1::MapDataPerfectInfoV1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapDataPerfectInfoV1::InitAsDefaultInstance() {
}

MapDataPerfectInfoV1::MapDataPerfectInfoV1(const MapDataPerfectInfoV1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapDataPerfectInfoV1::SharedCtor() {
  _cached_size_ = 0;
  condition_ = -1;
  deathcountnum_ = 0;
  killenemyid_ = 0;
  killenemycount_ = 0;
  hppercent_ = 0;
  timelimit_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapDataPerfectInfoV1::~MapDataPerfectInfoV1() {
  SharedDtor();
}

void MapDataPerfectInfoV1::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapDataPerfectInfoV1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapDataPerfectInfoV1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapDataPerfectInfoV1_descriptor_;
}

const MapDataPerfectInfoV1& MapDataPerfectInfoV1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapDataV1Data_2eproto();
  return *default_instance_;
}

MapDataPerfectInfoV1* MapDataPerfectInfoV1::default_instance_ = NULL;

MapDataPerfectInfoV1* MapDataPerfectInfoV1::New() const {
  return new MapDataPerfectInfoV1;
}

void MapDataPerfectInfoV1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    condition_ = -1;
    deathcountnum_ = 0;
    killenemyid_ = 0;
    killenemycount_ = 0;
    hppercent_ = 0;
    timelimit_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapDataPerfectInfoV1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint32 Condition = 1 [default = -1];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &condition_)));
          set_has_condition();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_DeathCountNum;
        break;
      }

      // optional sint32 DeathCountNum = 2 [default = 0];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_DeathCountNum:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &deathcountnum_)));
          set_has_deathcountnum();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_KillEnemyID;
        break;
      }

      // optional sint32 KillEnemyID = 3 [default = 0];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_KillEnemyID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &killenemyid_)));
          set_has_killenemyid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_KillEnemyCount;
        break;
      }

      // optional sint32 KillEnemyCount = 4 [default = 0];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_KillEnemyCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &killenemycount_)));
          set_has_killenemycount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_HpPercent;
        break;
      }

      // optional sint32 HpPercent = 5 [default = 0];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_HpPercent:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &hppercent_)));
          set_has_hppercent();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_TimeLimit;
        break;
      }

      // optional float TimeLimit = 6 [default = 0];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_TimeLimit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &timelimit_)));
          set_has_timelimit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapDataPerfectInfoV1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional sint32 Condition = 1 [default = -1];
  if (has_condition()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(1, this->condition(), output);
  }

  // optional sint32 DeathCountNum = 2 [default = 0];
  if (has_deathcountnum()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(2, this->deathcountnum(), output);
  }

  // optional sint32 KillEnemyID = 3 [default = 0];
  if (has_killenemyid()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(3, this->killenemyid(), output);
  }

  // optional sint32 KillEnemyCount = 4 [default = 0];
  if (has_killenemycount()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(4, this->killenemycount(), output);
  }

  // optional sint32 HpPercent = 5 [default = 0];
  if (has_hppercent()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(5, this->hppercent(), output);
  }

  // optional float TimeLimit = 6 [default = 0];
  if (has_timelimit()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->timelimit(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapDataPerfectInfoV1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional sint32 Condition = 1 [default = -1];
  if (has_condition()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(1, this->condition(), target);
  }

  // optional sint32 DeathCountNum = 2 [default = 0];
  if (has_deathcountnum()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(2, this->deathcountnum(), target);
  }

  // optional sint32 KillEnemyID = 3 [default = 0];
  if (has_killenemyid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(3, this->killenemyid(), target);
  }

  // optional sint32 KillEnemyCount = 4 [default = 0];
  if (has_killenemycount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(4, this->killenemycount(), target);
  }

  // optional sint32 HpPercent = 5 [default = 0];
  if (has_hppercent()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(5, this->hppercent(), target);
  }

  // optional float TimeLimit = 6 [default = 0];
  if (has_timelimit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->timelimit(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapDataPerfectInfoV1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional sint32 Condition = 1 [default = -1];
    if (has_condition()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->condition());
    }

    // optional sint32 DeathCountNum = 2 [default = 0];
    if (has_deathcountnum()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->deathcountnum());
    }

    // optional sint32 KillEnemyID = 3 [default = 0];
    if (has_killenemyid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->killenemyid());
    }

    // optional sint32 KillEnemyCount = 4 [default = 0];
    if (has_killenemycount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->killenemycount());
    }

    // optional sint32 HpPercent = 5 [default = 0];
    if (has_hppercent()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->hppercent());
    }

    // optional float TimeLimit = 6 [default = 0];
    if (has_timelimit()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapDataPerfectInfoV1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapDataPerfectInfoV1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapDataPerfectInfoV1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapDataPerfectInfoV1::MergeFrom(const MapDataPerfectInfoV1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_condition()) {
      set_condition(from.condition());
    }
    if (from.has_deathcountnum()) {
      set_deathcountnum(from.deathcountnum());
    }
    if (from.has_killenemyid()) {
      set_killenemyid(from.killenemyid());
    }
    if (from.has_killenemycount()) {
      set_killenemycount(from.killenemycount());
    }
    if (from.has_hppercent()) {
      set_hppercent(from.hppercent());
    }
    if (from.has_timelimit()) {
      set_timelimit(from.timelimit());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapDataPerfectInfoV1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapDataPerfectInfoV1::CopyFrom(const MapDataPerfectInfoV1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapDataPerfectInfoV1::IsInitialized() const {

  return true;
}

void MapDataPerfectInfoV1::Swap(MapDataPerfectInfoV1* other) {
  if (other != this) {
    std::swap(condition_, other->condition_);
    std::swap(deathcountnum_, other->deathcountnum_);
    std::swap(killenemyid_, other->killenemyid_);
    std::swap(killenemycount_, other->killenemycount_);
    std::swap(hppercent_, other->hppercent_);
    std::swap(timelimit_, other->timelimit_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapDataPerfectInfoV1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapDataPerfectInfoV1_descriptor_;
  metadata.reflection = MapDataPerfectInfoV1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapDataPortalInfoV1::kSourceXFieldNumber;
const int MapDataPortalInfoV1::kSourceLayerFieldNumber;
const int MapDataPortalInfoV1::kTargetXFieldNumber;
const int MapDataPortalInfoV1::kTargetLayerFieldNumber;
const int MapDataPortalInfoV1::kUseCountFieldNumber;
const int MapDataPortalInfoV1::kChannelFieldNumber;
const int MapDataPortalInfoV1::kPortalTypeFieldNumber;
const int MapDataPortalInfoV1::kTargetDungeonIdFieldNumber;
const int MapDataPortalInfoV1::kTargetSpawnIndexFieldNumber;
const int MapDataPortalInfoV1::kTargetDirectionFieldNumber;
const int MapDataPortalInfoV1::kSourceZFieldNumber;
const int MapDataPortalInfoV1::kTargetZFieldNumber;
const int MapDataPortalInfoV1::kSourceAngleFieldNumber;
const int MapDataPortalInfoV1::kTargetAngleFieldNumber;
const int MapDataPortalInfoV1::kSourceRadiusFieldNumber;
const int MapDataPortalInfoV1::kTargetRadiusFieldNumber;
#endif  // !_MSC_VER

MapDataPortalInfoV1::MapDataPortalInfoV1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapDataPortalInfoV1::InitAsDefaultInstance() {
}

MapDataPortalInfoV1::MapDataPortalInfoV1(const MapDataPortalInfoV1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapDataPortalInfoV1::SharedCtor() {
  _cached_size_ = 0;
  sourcex_ = 0;
  sourcelayer_ = 0;
  targetx_ = -1;
  targetlayer_ = -1;
  usecount_ = 1;
  channel_ = false;
  portaltype_ = 0;
  targetdungeonid_ = 0;
  targetspawnindex_ = 0;
  targetdirection_ = 0;
  sourcez_ = 0;
  targetz_ = 0;
  sourceangle_ = 0;
  targetangle_ = 0;
  sourceradius_ = 0;
  targetradius_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapDataPortalInfoV1::~MapDataPortalInfoV1() {
  SharedDtor();
}

void MapDataPortalInfoV1::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapDataPortalInfoV1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapDataPortalInfoV1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapDataPortalInfoV1_descriptor_;
}

const MapDataPortalInfoV1& MapDataPortalInfoV1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapDataV1Data_2eproto();
  return *default_instance_;
}

MapDataPortalInfoV1* MapDataPortalInfoV1::default_instance_ = NULL;

MapDataPortalInfoV1* MapDataPortalInfoV1::New() const {
  return new MapDataPortalInfoV1;
}

void MapDataPortalInfoV1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    sourcex_ = 0;
    sourcelayer_ = 0;
    targetx_ = -1;
    targetlayer_ = -1;
    usecount_ = 1;
    channel_ = false;
    portaltype_ = 0;
    targetdungeonid_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    targetspawnindex_ = 0;
    targetdirection_ = 0;
    sourcez_ = 0;
    targetz_ = 0;
    sourceangle_ = 0;
    targetangle_ = 0;
    sourceradius_ = 0;
    targetradius_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapDataPortalInfoV1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float SourceX = 1 [default = 0];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sourcex_)));
          set_has_sourcex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_SourceLayer;
        break;
      }

      // optional sint32 SourceLayer = 2 [default = 0];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SourceLayer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &sourcelayer_)));
          set_has_sourcelayer();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_TargetX;
        break;
      }

      // optional float TargetX = 3 [default = -1];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_TargetX:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &targetx_)));
          set_has_targetx();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_TargetLayer;
        break;
      }

      // optional sint32 TargetLayer = 4 [default = -1];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TargetLayer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &targetlayer_)));
          set_has_targetlayer();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_UseCount;
        break;
      }

      // optional sint32 UseCount = 5 [default = 1];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_UseCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &usecount_)));
          set_has_usecount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_Channel;
        break;
      }

      // optional bool Channel = 6 [default = false];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Channel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &channel_)));
          set_has_channel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_PortalType;
        break;
      }

      // optional sint32 PortalType = 7 [default = 0];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_PortalType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &portaltype_)));
          set_has_portaltype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_TargetDungeonId;
        break;
      }

      // optional sint32 TargetDungeonId = 8 [default = 0];
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TargetDungeonId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &targetdungeonid_)));
          set_has_targetdungeonid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_TargetSpawnIndex;
        break;
      }

      // optional sint32 TargetSpawnIndex = 9 [default = 0];
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TargetSpawnIndex:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &targetspawnindex_)));
          set_has_targetspawnindex();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(80)) goto parse_TargetDirection;
        break;
      }

      // optional sint32 TargetDirection = 10 [default = 0];
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_TargetDirection:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &targetdirection_)));
          set_has_targetdirection();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(93)) goto parse_SourceZ;
        break;
      }

      // optional float SourceZ = 11 [default = 0];
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_SourceZ:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sourcez_)));
          set_has_sourcez();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(101)) goto parse_TargetZ;
        break;
      }

      // optional float TargetZ = 12 [default = 0];
      case 12: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_TargetZ:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &targetz_)));
          set_has_targetz();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(109)) goto parse_SourceAngle;
        break;
      }

      // optional float SourceAngle = 13 [default = 0];
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_SourceAngle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sourceangle_)));
          set_has_sourceangle();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(117)) goto parse_TargetAngle;
        break;
      }

      // optional float TargetAngle = 14 [default = 0];
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_TargetAngle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &targetangle_)));
          set_has_targetangle();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(125)) goto parse_SourceRadius;
        break;
      }

      // optional float SourceRadius = 15 [default = 0];
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_SourceRadius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &sourceradius_)));
          set_has_sourceradius();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(133)) goto parse_TargetRadius;
        break;
      }

      // optional float TargetRadius = 16 [default = 0];
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_TargetRadius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &targetradius_)));
          set_has_targetradius();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapDataPortalInfoV1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float SourceX = 1 [default = 0];
  if (has_sourcex()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->sourcex(), output);
  }

  // optional sint32 SourceLayer = 2 [default = 0];
  if (has_sourcelayer()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(2, this->sourcelayer(), output);
  }

  // optional float TargetX = 3 [default = -1];
  if (has_targetx()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->targetx(), output);
  }

  // optional sint32 TargetLayer = 4 [default = -1];
  if (has_targetlayer()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(4, this->targetlayer(), output);
  }

  // optional sint32 UseCount = 5 [default = 1];
  if (has_usecount()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(5, this->usecount(), output);
  }

  // optional bool Channel = 6 [default = false];
  if (has_channel()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->channel(), output);
  }

  // optional sint32 PortalType = 7 [default = 0];
  if (has_portaltype()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(7, this->portaltype(), output);
  }

  // optional sint32 TargetDungeonId = 8 [default = 0];
  if (has_targetdungeonid()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(8, this->targetdungeonid(), output);
  }

  // optional sint32 TargetSpawnIndex = 9 [default = 0];
  if (has_targetspawnindex()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(9, this->targetspawnindex(), output);
  }

  // optional sint32 TargetDirection = 10 [default = 0];
  if (has_targetdirection()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(10, this->targetdirection(), output);
  }

  // optional float SourceZ = 11 [default = 0];
  if (has_sourcez()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->sourcez(), output);
  }

  // optional float TargetZ = 12 [default = 0];
  if (has_targetz()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(12, this->targetz(), output);
  }

  // optional float SourceAngle = 13 [default = 0];
  if (has_sourceangle()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(13, this->sourceangle(), output);
  }

  // optional float TargetAngle = 14 [default = 0];
  if (has_targetangle()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(14, this->targetangle(), output);
  }

  // optional float SourceRadius = 15 [default = 0];
  if (has_sourceradius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(15, this->sourceradius(), output);
  }

  // optional float TargetRadius = 16 [default = 0];
  if (has_targetradius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(16, this->targetradius(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapDataPortalInfoV1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional float SourceX = 1 [default = 0];
  if (has_sourcex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->sourcex(), target);
  }

  // optional sint32 SourceLayer = 2 [default = 0];
  if (has_sourcelayer()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(2, this->sourcelayer(), target);
  }

  // optional float TargetX = 3 [default = -1];
  if (has_targetx()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->targetx(), target);
  }

  // optional sint32 TargetLayer = 4 [default = -1];
  if (has_targetlayer()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(4, this->targetlayer(), target);
  }

  // optional sint32 UseCount = 5 [default = 1];
  if (has_usecount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(5, this->usecount(), target);
  }

  // optional bool Channel = 6 [default = false];
  if (has_channel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->channel(), target);
  }

  // optional sint32 PortalType = 7 [default = 0];
  if (has_portaltype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(7, this->portaltype(), target);
  }

  // optional sint32 TargetDungeonId = 8 [default = 0];
  if (has_targetdungeonid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(8, this->targetdungeonid(), target);
  }

  // optional sint32 TargetSpawnIndex = 9 [default = 0];
  if (has_targetspawnindex()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(9, this->targetspawnindex(), target);
  }

  // optional sint32 TargetDirection = 10 [default = 0];
  if (has_targetdirection()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(10, this->targetdirection(), target);
  }

  // optional float SourceZ = 11 [default = 0];
  if (has_sourcez()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(11, this->sourcez(), target);
  }

  // optional float TargetZ = 12 [default = 0];
  if (has_targetz()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(12, this->targetz(), target);
  }

  // optional float SourceAngle = 13 [default = 0];
  if (has_sourceangle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(13, this->sourceangle(), target);
  }

  // optional float TargetAngle = 14 [default = 0];
  if (has_targetangle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(14, this->targetangle(), target);
  }

  // optional float SourceRadius = 15 [default = 0];
  if (has_sourceradius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(15, this->sourceradius(), target);
  }

  // optional float TargetRadius = 16 [default = 0];
  if (has_targetradius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(16, this->targetradius(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapDataPortalInfoV1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float SourceX = 1 [default = 0];
    if (has_sourcex()) {
      total_size += 1 + 4;
    }

    // optional sint32 SourceLayer = 2 [default = 0];
    if (has_sourcelayer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->sourcelayer());
    }

    // optional float TargetX = 3 [default = -1];
    if (has_targetx()) {
      total_size += 1 + 4;
    }

    // optional sint32 TargetLayer = 4 [default = -1];
    if (has_targetlayer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->targetlayer());
    }

    // optional sint32 UseCount = 5 [default = 1];
    if (has_usecount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->usecount());
    }

    // optional bool Channel = 6 [default = false];
    if (has_channel()) {
      total_size += 1 + 1;
    }

    // optional sint32 PortalType = 7 [default = 0];
    if (has_portaltype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->portaltype());
    }

    // optional sint32 TargetDungeonId = 8 [default = 0];
    if (has_targetdungeonid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->targetdungeonid());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional sint32 TargetSpawnIndex = 9 [default = 0];
    if (has_targetspawnindex()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->targetspawnindex());
    }

    // optional sint32 TargetDirection = 10 [default = 0];
    if (has_targetdirection()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->targetdirection());
    }

    // optional float SourceZ = 11 [default = 0];
    if (has_sourcez()) {
      total_size += 1 + 4;
    }

    // optional float TargetZ = 12 [default = 0];
    if (has_targetz()) {
      total_size += 1 + 4;
    }

    // optional float SourceAngle = 13 [default = 0];
    if (has_sourceangle()) {
      total_size += 1 + 4;
    }

    // optional float TargetAngle = 14 [default = 0];
    if (has_targetangle()) {
      total_size += 1 + 4;
    }

    // optional float SourceRadius = 15 [default = 0];
    if (has_sourceradius()) {
      total_size += 1 + 4;
    }

    // optional float TargetRadius = 16 [default = 0];
    if (has_targetradius()) {
      total_size += 2 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapDataPortalInfoV1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapDataPortalInfoV1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapDataPortalInfoV1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapDataPortalInfoV1::MergeFrom(const MapDataPortalInfoV1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_sourcex()) {
      set_sourcex(from.sourcex());
    }
    if (from.has_sourcelayer()) {
      set_sourcelayer(from.sourcelayer());
    }
    if (from.has_targetx()) {
      set_targetx(from.targetx());
    }
    if (from.has_targetlayer()) {
      set_targetlayer(from.targetlayer());
    }
    if (from.has_usecount()) {
      set_usecount(from.usecount());
    }
    if (from.has_channel()) {
      set_channel(from.channel());
    }
    if (from.has_portaltype()) {
      set_portaltype(from.portaltype());
    }
    if (from.has_targetdungeonid()) {
      set_targetdungeonid(from.targetdungeonid());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_targetspawnindex()) {
      set_targetspawnindex(from.targetspawnindex());
    }
    if (from.has_targetdirection()) {
      set_targetdirection(from.targetdirection());
    }
    if (from.has_sourcez()) {
      set_sourcez(from.sourcez());
    }
    if (from.has_targetz()) {
      set_targetz(from.targetz());
    }
    if (from.has_sourceangle()) {
      set_sourceangle(from.sourceangle());
    }
    if (from.has_targetangle()) {
      set_targetangle(from.targetangle());
    }
    if (from.has_sourceradius()) {
      set_sourceradius(from.sourceradius());
    }
    if (from.has_targetradius()) {
      set_targetradius(from.targetradius());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapDataPortalInfoV1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapDataPortalInfoV1::CopyFrom(const MapDataPortalInfoV1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapDataPortalInfoV1::IsInitialized() const {

  return true;
}

void MapDataPortalInfoV1::Swap(MapDataPortalInfoV1* other) {
  if (other != this) {
    std::swap(sourcex_, other->sourcex_);
    std::swap(sourcelayer_, other->sourcelayer_);
    std::swap(targetx_, other->targetx_);
    std::swap(targetlayer_, other->targetlayer_);
    std::swap(usecount_, other->usecount_);
    std::swap(channel_, other->channel_);
    std::swap(portaltype_, other->portaltype_);
    std::swap(targetdungeonid_, other->targetdungeonid_);
    std::swap(targetspawnindex_, other->targetspawnindex_);
    std::swap(targetdirection_, other->targetdirection_);
    std::swap(sourcez_, other->sourcez_);
    std::swap(targetz_, other->targetz_);
    std::swap(sourceangle_, other->sourceangle_);
    std::swap(targetangle_, other->targetangle_);
    std::swap(sourceradius_, other->sourceradius_);
    std::swap(targetradius_, other->targetradius_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapDataPortalInfoV1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapDataPortalInfoV1_descriptor_;
  metadata.reflection = MapDataPortalInfoV1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapDataTrapInfoV1::kTrapIDFieldNumber;
const int MapDataTrapInfoV1::kXFieldNumber;
const int MapDataTrapInfoV1::kYFieldNumber;
const int MapDataTrapInfoV1::kDirectionFieldNumber;
const int MapDataTrapInfoV1::kZFieldNumber;
#endif  // !_MSC_VER

MapDataTrapInfoV1::MapDataTrapInfoV1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapDataTrapInfoV1::InitAsDefaultInstance() {
}

MapDataTrapInfoV1::MapDataTrapInfoV1(const MapDataTrapInfoV1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapDataTrapInfoV1::SharedCtor() {
  _cached_size_ = 0;
  trapid_ = 0;
  x_ = 0;
  y_ = 0;
  direction_ = 1;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapDataTrapInfoV1::~MapDataTrapInfoV1() {
  SharedDtor();
}

void MapDataTrapInfoV1::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapDataTrapInfoV1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapDataTrapInfoV1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapDataTrapInfoV1_descriptor_;
}

const MapDataTrapInfoV1& MapDataTrapInfoV1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapDataV1Data_2eproto();
  return *default_instance_;
}

MapDataTrapInfoV1* MapDataTrapInfoV1::default_instance_ = NULL;

MapDataTrapInfoV1* MapDataTrapInfoV1::New() const {
  return new MapDataTrapInfoV1;
}

void MapDataTrapInfoV1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    trapid_ = 0;
    x_ = 0;
    y_ = 0;
    direction_ = 1;
    z_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapDataTrapInfoV1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint32 TrapID = 1 [default = 0];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &trapid_)));
          set_has_trapid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_X;
        break;
      }

      // optional float X = 2 [default = 0];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_X:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_Y;
        break;
      }

      // optional float Y = 4 [default = 0];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_Y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_Direction;
        break;
      }

      // optional sint32 Direction = 5 [default = 1];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Direction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &direction_)));
          set_has_direction();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_Z;
        break;
      }

      // optional float Z = 6 [default = 0];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_Z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapDataTrapInfoV1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional sint32 TrapID = 1 [default = 0];
  if (has_trapid()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(1, this->trapid(), output);
  }

  // optional float X = 2 [default = 0];
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->x(), output);
  }

  // optional float Y = 4 [default = 0];
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->y(), output);
  }

  // optional sint32 Direction = 5 [default = 1];
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(5, this->direction(), output);
  }

  // optional float Z = 6 [default = 0];
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->z(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapDataTrapInfoV1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional sint32 TrapID = 1 [default = 0];
  if (has_trapid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(1, this->trapid(), target);
  }

  // optional float X = 2 [default = 0];
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->x(), target);
  }

  // optional float Y = 4 [default = 0];
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->y(), target);
  }

  // optional sint32 Direction = 5 [default = 1];
  if (has_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(5, this->direction(), target);
  }

  // optional float Z = 6 [default = 0];
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->z(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapDataTrapInfoV1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional sint32 TrapID = 1 [default = 0];
    if (has_trapid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->trapid());
    }

    // optional float X = 2 [default = 0];
    if (has_x()) {
      total_size += 1 + 4;
    }

    // optional float Y = 4 [default = 0];
    if (has_y()) {
      total_size += 1 + 4;
    }

    // optional sint32 Direction = 5 [default = 1];
    if (has_direction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->direction());
    }

    // optional float Z = 6 [default = 0];
    if (has_z()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapDataTrapInfoV1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapDataTrapInfoV1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapDataTrapInfoV1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapDataTrapInfoV1::MergeFrom(const MapDataTrapInfoV1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_trapid()) {
      set_trapid(from.trapid());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_y()) {
      set_y(from.y());
    }
    if (from.has_direction()) {
      set_direction(from.direction());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapDataTrapInfoV1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapDataTrapInfoV1::CopyFrom(const MapDataTrapInfoV1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapDataTrapInfoV1::IsInitialized() const {

  return true;
}

void MapDataTrapInfoV1::Swap(MapDataTrapInfoV1* other) {
  if (other != this) {
    std::swap(trapid_, other->trapid_);
    std::swap(x_, other->x_);
    std::swap(y_, other->y_);
    std::swap(direction_, other->direction_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapDataTrapInfoV1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapDataTrapInfoV1_descriptor_;
  metadata.reflection = MapDataTrapInfoV1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapDataNpcInfoV1::kNpcIDFieldNumber;
const int MapDataNpcInfoV1::kXFieldNumber;
const int MapDataNpcInfoV1::kLayerFieldNumber;
const int MapDataNpcInfoV1::kZFieldNumber;
const int MapDataNpcInfoV1::kDirectionFieldNumber;
const int MapDataNpcInfoV1::kAngleFieldNumber;
const int MapDataNpcInfoV1::kRadiusFieldNumber;
#endif  // !_MSC_VER

MapDataNpcInfoV1::MapDataNpcInfoV1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapDataNpcInfoV1::InitAsDefaultInstance() {
}

MapDataNpcInfoV1::MapDataNpcInfoV1(const MapDataNpcInfoV1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapDataNpcInfoV1::SharedCtor() {
  _cached_size_ = 0;
  npcid_ = 0;
  x_ = 0;
  layer_ = 0;
  z_ = 0;
  direction_ = 1;
  angle_ = 0;
  radius_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapDataNpcInfoV1::~MapDataNpcInfoV1() {
  SharedDtor();
}

void MapDataNpcInfoV1::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapDataNpcInfoV1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapDataNpcInfoV1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapDataNpcInfoV1_descriptor_;
}

const MapDataNpcInfoV1& MapDataNpcInfoV1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapDataV1Data_2eproto();
  return *default_instance_;
}

MapDataNpcInfoV1* MapDataNpcInfoV1::default_instance_ = NULL;

MapDataNpcInfoV1* MapDataNpcInfoV1::New() const {
  return new MapDataNpcInfoV1;
}

void MapDataNpcInfoV1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    npcid_ = 0;
    x_ = 0;
    layer_ = 0;
    z_ = 0;
    direction_ = 1;
    angle_ = 0;
    radius_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapDataNpcInfoV1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint32 NpcID = 1 [default = 0];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &npcid_)));
          set_has_npcid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_X;
        break;
      }

      // optional float X = 2 [default = 0];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_X:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_Layer;
        break;
      }

      // optional sint32 Layer = 3 [default = 0];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Layer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &layer_)));
          set_has_layer();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_Z;
        break;
      }

      // optional float Z = 4 [default = 0];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_Z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_Direction;
        break;
      }

      // optional sint32 Direction = 5 [default = 1];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Direction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &direction_)));
          set_has_direction();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(53)) goto parse_Angle;
        break;
      }

      // optional float Angle = 6 [default = 0];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_Angle:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &angle_)));
          set_has_angle();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(61)) goto parse_Radius;
        break;
      }

      // optional float Radius = 7 [default = 0];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_Radius:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &radius_)));
          set_has_radius();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapDataNpcInfoV1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional sint32 NpcID = 1 [default = 0];
  if (has_npcid()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(1, this->npcid(), output);
  }

  // optional float X = 2 [default = 0];
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->x(), output);
  }

  // optional sint32 Layer = 3 [default = 0];
  if (has_layer()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(3, this->layer(), output);
  }

  // optional float Z = 4 [default = 0];
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->z(), output);
  }

  // optional sint32 Direction = 5 [default = 1];
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(5, this->direction(), output);
  }

  // optional float Angle = 6 [default = 0];
  if (has_angle()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->angle(), output);
  }

  // optional float Radius = 7 [default = 0];
  if (has_radius()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->radius(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapDataNpcInfoV1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional sint32 NpcID = 1 [default = 0];
  if (has_npcid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(1, this->npcid(), target);
  }

  // optional float X = 2 [default = 0];
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->x(), target);
  }

  // optional sint32 Layer = 3 [default = 0];
  if (has_layer()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(3, this->layer(), target);
  }

  // optional float Z = 4 [default = 0];
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->z(), target);
  }

  // optional sint32 Direction = 5 [default = 1];
  if (has_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(5, this->direction(), target);
  }

  // optional float Angle = 6 [default = 0];
  if (has_angle()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->angle(), target);
  }

  // optional float Radius = 7 [default = 0];
  if (has_radius()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->radius(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapDataNpcInfoV1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional sint32 NpcID = 1 [default = 0];
    if (has_npcid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->npcid());
    }

    // optional float X = 2 [default = 0];
    if (has_x()) {
      total_size += 1 + 4;
    }

    // optional sint32 Layer = 3 [default = 0];
    if (has_layer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->layer());
    }

    // optional float Z = 4 [default = 0];
    if (has_z()) {
      total_size += 1 + 4;
    }

    // optional sint32 Direction = 5 [default = 1];
    if (has_direction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->direction());
    }

    // optional float Angle = 6 [default = 0];
    if (has_angle()) {
      total_size += 1 + 4;
    }

    // optional float Radius = 7 [default = 0];
    if (has_radius()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapDataNpcInfoV1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapDataNpcInfoV1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapDataNpcInfoV1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapDataNpcInfoV1::MergeFrom(const MapDataNpcInfoV1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_npcid()) {
      set_npcid(from.npcid());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_layer()) {
      set_layer(from.layer());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
    if (from.has_direction()) {
      set_direction(from.direction());
    }
    if (from.has_angle()) {
      set_angle(from.angle());
    }
    if (from.has_radius()) {
      set_radius(from.radius());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapDataNpcInfoV1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapDataNpcInfoV1::CopyFrom(const MapDataNpcInfoV1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapDataNpcInfoV1::IsInitialized() const {

  return true;
}

void MapDataNpcInfoV1::Swap(MapDataNpcInfoV1* other) {
  if (other != this) {
    std::swap(npcid_, other->npcid_);
    std::swap(x_, other->x_);
    std::swap(layer_, other->layer_);
    std::swap(z_, other->z_);
    std::swap(direction_, other->direction_);
    std::swap(angle_, other->angle_);
    std::swap(radius_, other->radius_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapDataNpcInfoV1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapDataNpcInfoV1_descriptor_;
  metadata.reflection = MapDataNpcInfoV1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapDataMonsterInfoV1::kMonsterIDFieldNumber;
const int MapDataMonsterInfoV1::kXFieldNumber;
const int MapDataMonsterInfoV1::kLayerFieldNumber;
const int MapDataMonsterInfoV1::kRepeatCountFieldNumber;
const int MapDataMonsterInfoV1::kSpawmTriggerTypeFieldNumber;
const int MapDataMonsterInfoV1::kRespawmTriggerTypeFieldNumber;
const int MapDataMonsterInfoV1::kPatrolX1FieldNumber;
const int MapDataMonsterInfoV1::kPatrolX2FieldNumber;
const int MapDataMonsterInfoV1::kSpawnNodeTimeFieldNumber;
const int MapDataMonsterInfoV1::kSpawnKillEnemyIDFieldNumber;
const int MapDataMonsterInfoV1::kSpawnKillEnemyCountFieldNumber;
const int MapDataMonsterInfoV1::kSpawnAfterDeathTimeFieldNumber;
const int MapDataMonsterInfoV1::kRespawnNodeTimeFieldNumber;
const int MapDataMonsterInfoV1::kRespawnKillEnemyIDFieldNumber;
const int MapDataMonsterInfoV1::kRespawnKillEnemyCountFieldNumber;
const int MapDataMonsterInfoV1::kRespawnAfterDeathTimeFieldNumber;
const int MapDataMonsterInfoV1::kCreateMonsterTypeFieldNumber;
const int MapDataMonsterInfoV1::kNodeMonsterInfoArrFieldNumber;
const int MapDataMonsterInfoV1::kZFieldNumber;
const int MapDataMonsterInfoV1::kDirectionFieldNumber;
#endif  // !_MSC_VER

MapDataMonsterInfoV1::MapDataMonsterInfoV1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapDataMonsterInfoV1::InitAsDefaultInstance() {
}

MapDataMonsterInfoV1::MapDataMonsterInfoV1(const MapDataMonsterInfoV1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapDataMonsterInfoV1::SharedCtor() {
  _cached_size_ = 0;
  monsterid_ = 0;
  x_ = 0;
  layer_ = 0;
  repeatcount_ = 1;
  spawmtriggertype_ = 0;
  respawmtriggertype_ = 0;
  patrolx1_ = -1;
  patrolx2_ = -1;
  spawnnodetime_ = 0;
  spawnkillenemyid_ = 0;
  spawnkillenemycount_ = 0;
  spawnafterdeathtime_ = 0;
  respawnnodetime_ = 0;
  respawnkillenemyid_ = 0;
  respawnkillenemycount_ = 0;
  respawnafterdeathtime_ = 0;
  createmonstertype_ = 0;
  z_ = 0;
  direction_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapDataMonsterInfoV1::~MapDataMonsterInfoV1() {
  SharedDtor();
}

void MapDataMonsterInfoV1::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapDataMonsterInfoV1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapDataMonsterInfoV1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapDataMonsterInfoV1_descriptor_;
}

const MapDataMonsterInfoV1& MapDataMonsterInfoV1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapDataV1Data_2eproto();
  return *default_instance_;
}

MapDataMonsterInfoV1* MapDataMonsterInfoV1::default_instance_ = NULL;

MapDataMonsterInfoV1* MapDataMonsterInfoV1::New() const {
  return new MapDataMonsterInfoV1;
}

void MapDataMonsterInfoV1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    monsterid_ = 0;
    x_ = 0;
    layer_ = 0;
    repeatcount_ = 1;
    spawmtriggertype_ = 0;
    respawmtriggertype_ = 0;
    patrolx1_ = -1;
    patrolx2_ = -1;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    spawnnodetime_ = 0;
    spawnkillenemyid_ = 0;
    spawnkillenemycount_ = 0;
    spawnafterdeathtime_ = 0;
    respawnnodetime_ = 0;
    respawnkillenemyid_ = 0;
    respawnkillenemycount_ = 0;
    respawnafterdeathtime_ = 0;
  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    createmonstertype_ = 0;
    z_ = 0;
    direction_ = 1;
  }
  nodemonsterinfoarr_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapDataMonsterInfoV1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint32 MonsterID = 1 [default = 0];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &monsterid_)));
          set_has_monsterid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_X;
        break;
      }

      // optional float X = 2 [default = 0];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_X:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_Layer;
        break;
      }

      // optional sint32 Layer = 3 [default = 0];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Layer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &layer_)));
          set_has_layer();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_RepeatCount;
        break;
      }

      // optional sint32 RepeatCount = 4 [default = 1];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_RepeatCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &repeatcount_)));
          set_has_repeatcount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_SpawmTriggerType;
        break;
      }

      // optional sint32 SpawmTriggerType = 5 [default = 0];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SpawmTriggerType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &spawmtriggertype_)));
          set_has_spawmtriggertype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_RespawmTriggerType;
        break;
      }

      // optional sint32 RespawmTriggerType = 6 [default = 0];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_RespawmTriggerType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &respawmtriggertype_)));
          set_has_respawmtriggertype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(93)) goto parse_PatrolX1;
        break;
      }

      // optional float PatrolX1 = 11 [default = -1];
      case 11: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_PatrolX1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &patrolx1_)));
          set_has_patrolx1();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(109)) goto parse_PatrolX2;
        break;
      }

      // optional float PatrolX2 = 13 [default = -1];
      case 13: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_PatrolX2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &patrolx2_)));
          set_has_patrolx2();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(117)) goto parse_SpawnNodeTime;
        break;
      }

      // optional float SpawnNodeTime = 14 [default = 0];
      case 14: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_SpawnNodeTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &spawnnodetime_)));
          set_has_spawnnodetime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(120)) goto parse_SpawnKillEnemyID;
        break;
      }

      // optional sint32 SpawnKillEnemyID = 15 [default = 0];
      case 15: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SpawnKillEnemyID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &spawnkillenemyid_)));
          set_has_spawnkillenemyid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(128)) goto parse_SpawnKillEnemyCount;
        break;
      }

      // optional sint32 SpawnKillEnemyCount = 16 [default = 0];
      case 16: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_SpawnKillEnemyCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &spawnkillenemycount_)));
          set_has_spawnkillenemycount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(141)) goto parse_SpawnAfterDeathTime;
        break;
      }

      // optional float SpawnAfterDeathTime = 17 [default = 0];
      case 17: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_SpawnAfterDeathTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &spawnafterdeathtime_)));
          set_has_spawnafterdeathtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(149)) goto parse_RespawnNodeTime;
        break;
      }

      // optional float RespawnNodeTime = 18 [default = 0];
      case 18: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_RespawnNodeTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &respawnnodetime_)));
          set_has_respawnnodetime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(152)) goto parse_RespawnKillEnemyID;
        break;
      }

      // optional sint32 RespawnKillEnemyID = 19 [default = 0];
      case 19: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_RespawnKillEnemyID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &respawnkillenemyid_)));
          set_has_respawnkillenemyid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(160)) goto parse_RespawnKillEnemyCount;
        break;
      }

      // optional sint32 RespawnKillEnemyCount = 20 [default = 0];
      case 20: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_RespawnKillEnemyCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &respawnkillenemycount_)));
          set_has_respawnkillenemycount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(173)) goto parse_RespawnAfterDeathTime;
        break;
      }

      // optional float RespawnAfterDeathTime = 21 [default = 0];
      case 21: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_RespawnAfterDeathTime:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &respawnafterdeathtime_)));
          set_has_respawnafterdeathtime();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(176)) goto parse_CreateMonsterType;
        break;
      }

      // optional sint32 CreateMonsterType = 22 [default = 0];
      case 22: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_CreateMonsterType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &createmonstertype_)));
          set_has_createmonstertype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(194)) goto parse_NodeMonsterInfoArr;
        break;
      }

      // repeated .MapDataNodeMonsterInfoV1 NodeMonsterInfoArr = 24;
      case 24: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_NodeMonsterInfoArr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_nodemonsterinfoarr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(194)) goto parse_NodeMonsterInfoArr;
        if (input->ExpectTag(205)) goto parse_Z;
        break;
      }

      // optional float Z = 25 [default = 0];
      case 25: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_Z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(208)) goto parse_Direction;
        break;
      }

      // optional sint32 Direction = 26 [default = 1];
      case 26: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Direction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &direction_)));
          set_has_direction();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapDataMonsterInfoV1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional sint32 MonsterID = 1 [default = 0];
  if (has_monsterid()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(1, this->monsterid(), output);
  }

  // optional float X = 2 [default = 0];
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->x(), output);
  }

  // optional sint32 Layer = 3 [default = 0];
  if (has_layer()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(3, this->layer(), output);
  }

  // optional sint32 RepeatCount = 4 [default = 1];
  if (has_repeatcount()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(4, this->repeatcount(), output);
  }

  // optional sint32 SpawmTriggerType = 5 [default = 0];
  if (has_spawmtriggertype()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(5, this->spawmtriggertype(), output);
  }

  // optional sint32 RespawmTriggerType = 6 [default = 0];
  if (has_respawmtriggertype()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(6, this->respawmtriggertype(), output);
  }

  // optional float PatrolX1 = 11 [default = -1];
  if (has_patrolx1()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(11, this->patrolx1(), output);
  }

  // optional float PatrolX2 = 13 [default = -1];
  if (has_patrolx2()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(13, this->patrolx2(), output);
  }

  // optional float SpawnNodeTime = 14 [default = 0];
  if (has_spawnnodetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(14, this->spawnnodetime(), output);
  }

  // optional sint32 SpawnKillEnemyID = 15 [default = 0];
  if (has_spawnkillenemyid()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(15, this->spawnkillenemyid(), output);
  }

  // optional sint32 SpawnKillEnemyCount = 16 [default = 0];
  if (has_spawnkillenemycount()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(16, this->spawnkillenemycount(), output);
  }

  // optional float SpawnAfterDeathTime = 17 [default = 0];
  if (has_spawnafterdeathtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(17, this->spawnafterdeathtime(), output);
  }

  // optional float RespawnNodeTime = 18 [default = 0];
  if (has_respawnnodetime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(18, this->respawnnodetime(), output);
  }

  // optional sint32 RespawnKillEnemyID = 19 [default = 0];
  if (has_respawnkillenemyid()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(19, this->respawnkillenemyid(), output);
  }

  // optional sint32 RespawnKillEnemyCount = 20 [default = 0];
  if (has_respawnkillenemycount()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(20, this->respawnkillenemycount(), output);
  }

  // optional float RespawnAfterDeathTime = 21 [default = 0];
  if (has_respawnafterdeathtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(21, this->respawnafterdeathtime(), output);
  }

  // optional sint32 CreateMonsterType = 22 [default = 0];
  if (has_createmonstertype()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(22, this->createmonstertype(), output);
  }

  // repeated .MapDataNodeMonsterInfoV1 NodeMonsterInfoArr = 24;
  for (int i = 0; i < this->nodemonsterinfoarr_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      24, this->nodemonsterinfoarr(i), output);
  }

  // optional float Z = 25 [default = 0];
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(25, this->z(), output);
  }

  // optional sint32 Direction = 26 [default = 1];
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(26, this->direction(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapDataMonsterInfoV1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional sint32 MonsterID = 1 [default = 0];
  if (has_monsterid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(1, this->monsterid(), target);
  }

  // optional float X = 2 [default = 0];
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->x(), target);
  }

  // optional sint32 Layer = 3 [default = 0];
  if (has_layer()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(3, this->layer(), target);
  }

  // optional sint32 RepeatCount = 4 [default = 1];
  if (has_repeatcount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(4, this->repeatcount(), target);
  }

  // optional sint32 SpawmTriggerType = 5 [default = 0];
  if (has_spawmtriggertype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(5, this->spawmtriggertype(), target);
  }

  // optional sint32 RespawmTriggerType = 6 [default = 0];
  if (has_respawmtriggertype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(6, this->respawmtriggertype(), target);
  }

  // optional float PatrolX1 = 11 [default = -1];
  if (has_patrolx1()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(11, this->patrolx1(), target);
  }

  // optional float PatrolX2 = 13 [default = -1];
  if (has_patrolx2()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(13, this->patrolx2(), target);
  }

  // optional float SpawnNodeTime = 14 [default = 0];
  if (has_spawnnodetime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(14, this->spawnnodetime(), target);
  }

  // optional sint32 SpawnKillEnemyID = 15 [default = 0];
  if (has_spawnkillenemyid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(15, this->spawnkillenemyid(), target);
  }

  // optional sint32 SpawnKillEnemyCount = 16 [default = 0];
  if (has_spawnkillenemycount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(16, this->spawnkillenemycount(), target);
  }

  // optional float SpawnAfterDeathTime = 17 [default = 0];
  if (has_spawnafterdeathtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(17, this->spawnafterdeathtime(), target);
  }

  // optional float RespawnNodeTime = 18 [default = 0];
  if (has_respawnnodetime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(18, this->respawnnodetime(), target);
  }

  // optional sint32 RespawnKillEnemyID = 19 [default = 0];
  if (has_respawnkillenemyid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(19, this->respawnkillenemyid(), target);
  }

  // optional sint32 RespawnKillEnemyCount = 20 [default = 0];
  if (has_respawnkillenemycount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(20, this->respawnkillenemycount(), target);
  }

  // optional float RespawnAfterDeathTime = 21 [default = 0];
  if (has_respawnafterdeathtime()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(21, this->respawnafterdeathtime(), target);
  }

  // optional sint32 CreateMonsterType = 22 [default = 0];
  if (has_createmonstertype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(22, this->createmonstertype(), target);
  }

  // repeated .MapDataNodeMonsterInfoV1 NodeMonsterInfoArr = 24;
  for (int i = 0; i < this->nodemonsterinfoarr_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        24, this->nodemonsterinfoarr(i), target);
  }

  // optional float Z = 25 [default = 0];
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(25, this->z(), target);
  }

  // optional sint32 Direction = 26 [default = 1];
  if (has_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(26, this->direction(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapDataMonsterInfoV1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional sint32 MonsterID = 1 [default = 0];
    if (has_monsterid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->monsterid());
    }

    // optional float X = 2 [default = 0];
    if (has_x()) {
      total_size += 1 + 4;
    }

    // optional sint32 Layer = 3 [default = 0];
    if (has_layer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->layer());
    }

    // optional sint32 RepeatCount = 4 [default = 1];
    if (has_repeatcount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->repeatcount());
    }

    // optional sint32 SpawmTriggerType = 5 [default = 0];
    if (has_spawmtriggertype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->spawmtriggertype());
    }

    // optional sint32 RespawmTriggerType = 6 [default = 0];
    if (has_respawmtriggertype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->respawmtriggertype());
    }

    // optional float PatrolX1 = 11 [default = -1];
    if (has_patrolx1()) {
      total_size += 1 + 4;
    }

    // optional float PatrolX2 = 13 [default = -1];
    if (has_patrolx2()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional float SpawnNodeTime = 14 [default = 0];
    if (has_spawnnodetime()) {
      total_size += 1 + 4;
    }

    // optional sint32 SpawnKillEnemyID = 15 [default = 0];
    if (has_spawnkillenemyid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->spawnkillenemyid());
    }

    // optional sint32 SpawnKillEnemyCount = 16 [default = 0];
    if (has_spawnkillenemycount()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->spawnkillenemycount());
    }

    // optional float SpawnAfterDeathTime = 17 [default = 0];
    if (has_spawnafterdeathtime()) {
      total_size += 2 + 4;
    }

    // optional float RespawnNodeTime = 18 [default = 0];
    if (has_respawnnodetime()) {
      total_size += 2 + 4;
    }

    // optional sint32 RespawnKillEnemyID = 19 [default = 0];
    if (has_respawnkillenemyid()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->respawnkillenemyid());
    }

    // optional sint32 RespawnKillEnemyCount = 20 [default = 0];
    if (has_respawnkillenemycount()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->respawnkillenemycount());
    }

    // optional float RespawnAfterDeathTime = 21 [default = 0];
    if (has_respawnafterdeathtime()) {
      total_size += 2 + 4;
    }

  }
  if (_has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    // optional sint32 CreateMonsterType = 22 [default = 0];
    if (has_createmonstertype()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->createmonstertype());
    }

    // optional float Z = 25 [default = 0];
    if (has_z()) {
      total_size += 2 + 4;
    }

    // optional sint32 Direction = 26 [default = 1];
    if (has_direction()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->direction());
    }

  }
  // repeated .MapDataNodeMonsterInfoV1 NodeMonsterInfoArr = 24;
  total_size += 2 * this->nodemonsterinfoarr_size();
  for (int i = 0; i < this->nodemonsterinfoarr_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->nodemonsterinfoarr(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapDataMonsterInfoV1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapDataMonsterInfoV1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapDataMonsterInfoV1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapDataMonsterInfoV1::MergeFrom(const MapDataMonsterInfoV1& from) {
  GOOGLE_CHECK_NE(&from, this);
  nodemonsterinfoarr_.MergeFrom(from.nodemonsterinfoarr_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_monsterid()) {
      set_monsterid(from.monsterid());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_layer()) {
      set_layer(from.layer());
    }
    if (from.has_repeatcount()) {
      set_repeatcount(from.repeatcount());
    }
    if (from.has_spawmtriggertype()) {
      set_spawmtriggertype(from.spawmtriggertype());
    }
    if (from.has_respawmtriggertype()) {
      set_respawmtriggertype(from.respawmtriggertype());
    }
    if (from.has_patrolx1()) {
      set_patrolx1(from.patrolx1());
    }
    if (from.has_patrolx2()) {
      set_patrolx2(from.patrolx2());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_spawnnodetime()) {
      set_spawnnodetime(from.spawnnodetime());
    }
    if (from.has_spawnkillenemyid()) {
      set_spawnkillenemyid(from.spawnkillenemyid());
    }
    if (from.has_spawnkillenemycount()) {
      set_spawnkillenemycount(from.spawnkillenemycount());
    }
    if (from.has_spawnafterdeathtime()) {
      set_spawnafterdeathtime(from.spawnafterdeathtime());
    }
    if (from.has_respawnnodetime()) {
      set_respawnnodetime(from.respawnnodetime());
    }
    if (from.has_respawnkillenemyid()) {
      set_respawnkillenemyid(from.respawnkillenemyid());
    }
    if (from.has_respawnkillenemycount()) {
      set_respawnkillenemycount(from.respawnkillenemycount());
    }
    if (from.has_respawnafterdeathtime()) {
      set_respawnafterdeathtime(from.respawnafterdeathtime());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_createmonstertype()) {
      set_createmonstertype(from.createmonstertype());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
    if (from.has_direction()) {
      set_direction(from.direction());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapDataMonsterInfoV1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapDataMonsterInfoV1::CopyFrom(const MapDataMonsterInfoV1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapDataMonsterInfoV1::IsInitialized() const {

  return true;
}

void MapDataMonsterInfoV1::Swap(MapDataMonsterInfoV1* other) {
  if (other != this) {
    std::swap(monsterid_, other->monsterid_);
    std::swap(x_, other->x_);
    std::swap(layer_, other->layer_);
    std::swap(repeatcount_, other->repeatcount_);
    std::swap(spawmtriggertype_, other->spawmtriggertype_);
    std::swap(respawmtriggertype_, other->respawmtriggertype_);
    std::swap(patrolx1_, other->patrolx1_);
    std::swap(patrolx2_, other->patrolx2_);
    std::swap(spawnnodetime_, other->spawnnodetime_);
    std::swap(spawnkillenemyid_, other->spawnkillenemyid_);
    std::swap(spawnkillenemycount_, other->spawnkillenemycount_);
    std::swap(spawnafterdeathtime_, other->spawnafterdeathtime_);
    std::swap(respawnnodetime_, other->respawnnodetime_);
    std::swap(respawnkillenemyid_, other->respawnkillenemyid_);
    std::swap(respawnkillenemycount_, other->respawnkillenemycount_);
    std::swap(respawnafterdeathtime_, other->respawnafterdeathtime_);
    std::swap(createmonstertype_, other->createmonstertype_);
    nodemonsterinfoarr_.Swap(&other->nodemonsterinfoarr_);
    std::swap(z_, other->z_);
    std::swap(direction_, other->direction_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapDataMonsterInfoV1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapDataMonsterInfoV1_descriptor_;
  metadata.reflection = MapDataMonsterInfoV1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapDataNodeInfoV1::kXFieldNumber;
const int MapDataNodeInfoV1::kLayerFieldNumber;
const int MapDataNodeInfoV1::kPassConditionFieldNumber;
const int MapDataNodeInfoV1::kKillEnemyIDFieldNumber;
const int MapDataNodeInfoV1::kKillEnemyCountFieldNumber;
const int MapDataNodeInfoV1::kMonsterArrFieldNumber;
const int MapDataNodeInfoV1::kTimeLimitFieldNumber;
const int MapDataNodeInfoV1::kNodeTypeFieldNumber;
const int MapDataNodeInfoV1::kNodeArrowDisplayTypeFieldNumber;
#endif  // !_MSC_VER

MapDataNodeInfoV1::MapDataNodeInfoV1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapDataNodeInfoV1::InitAsDefaultInstance() {
}

MapDataNodeInfoV1::MapDataNodeInfoV1(const MapDataNodeInfoV1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapDataNodeInfoV1::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  layer_ = 0;
  passcondition_ = 0;
  killenemyid_ = 0;
  killenemycount_ = 0;
  timelimit_ = 0;
  nodetype_ = 0;
  nodearrowdisplaytype_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapDataNodeInfoV1::~MapDataNodeInfoV1() {
  SharedDtor();
}

void MapDataNodeInfoV1::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapDataNodeInfoV1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapDataNodeInfoV1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapDataNodeInfoV1_descriptor_;
}

const MapDataNodeInfoV1& MapDataNodeInfoV1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapDataV1Data_2eproto();
  return *default_instance_;
}

MapDataNodeInfoV1* MapDataNodeInfoV1::default_instance_ = NULL;

MapDataNodeInfoV1* MapDataNodeInfoV1::New() const {
  return new MapDataNodeInfoV1;
}

void MapDataNodeInfoV1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_ = 0;
    layer_ = 0;
    passcondition_ = 0;
    killenemyid_ = 0;
    killenemycount_ = 0;
    timelimit_ = 0;
    nodetype_ = 0;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    nodearrowdisplaytype_ = 0;
  }
  monsterarr_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapDataNodeInfoV1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float X = 1 [default = 0];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_Layer;
        break;
      }

      // optional sint32 Layer = 2 [default = 0];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Layer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &layer_)));
          set_has_layer();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_PassCondition;
        break;
      }

      // optional sint32 PassCondition = 3 [default = 0];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_PassCondition:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &passcondition_)));
          set_has_passcondition();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_KillEnemyID;
        break;
      }

      // optional sint32 KillEnemyID = 4 [default = 0];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_KillEnemyID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &killenemyid_)));
          set_has_killenemyid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_KillEnemyCount;
        break;
      }

      // optional sint32 KillEnemyCount = 5 [default = 0];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_KillEnemyCount:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &killenemycount_)));
          set_has_killenemycount();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_MonsterArr;
        break;
      }

      // repeated .MapDataMonsterInfoV1 MonsterArr = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_MonsterArr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_monsterarr()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(50)) goto parse_MonsterArr;
        if (input->ExpectTag(61)) goto parse_TimeLimit;
        break;
      }

      // optional float TimeLimit = 7 [default = 0];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_TimeLimit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &timelimit_)));
          set_has_timelimit();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(64)) goto parse_NodeType;
        break;
      }

      // optional sint32 NodeType = 8 [default = 0];
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_NodeType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &nodetype_)));
          set_has_nodetype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_NodeArrowDisplayType;
        break;
      }

      // optional sint32 NodeArrowDisplayType = 9 [default = 0];
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_NodeArrowDisplayType:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &nodearrowdisplaytype_)));
          set_has_nodearrowdisplaytype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapDataNodeInfoV1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float X = 1 [default = 0];
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // optional sint32 Layer = 2 [default = 0];
  if (has_layer()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(2, this->layer(), output);
  }

  // optional sint32 PassCondition = 3 [default = 0];
  if (has_passcondition()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(3, this->passcondition(), output);
  }

  // optional sint32 KillEnemyID = 4 [default = 0];
  if (has_killenemyid()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(4, this->killenemyid(), output);
  }

  // optional sint32 KillEnemyCount = 5 [default = 0];
  if (has_killenemycount()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(5, this->killenemycount(), output);
  }

  // repeated .MapDataMonsterInfoV1 MonsterArr = 6;
  for (int i = 0; i < this->monsterarr_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->monsterarr(i), output);
  }

  // optional float TimeLimit = 7 [default = 0];
  if (has_timelimit()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->timelimit(), output);
  }

  // optional sint32 NodeType = 8 [default = 0];
  if (has_nodetype()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(8, this->nodetype(), output);
  }

  // optional sint32 NodeArrowDisplayType = 9 [default = 0];
  if (has_nodearrowdisplaytype()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(9, this->nodearrowdisplaytype(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapDataNodeInfoV1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional float X = 1 [default = 0];
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // optional sint32 Layer = 2 [default = 0];
  if (has_layer()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(2, this->layer(), target);
  }

  // optional sint32 PassCondition = 3 [default = 0];
  if (has_passcondition()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(3, this->passcondition(), target);
  }

  // optional sint32 KillEnemyID = 4 [default = 0];
  if (has_killenemyid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(4, this->killenemyid(), target);
  }

  // optional sint32 KillEnemyCount = 5 [default = 0];
  if (has_killenemycount()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(5, this->killenemycount(), target);
  }

  // repeated .MapDataMonsterInfoV1 MonsterArr = 6;
  for (int i = 0; i < this->monsterarr_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->monsterarr(i), target);
  }

  // optional float TimeLimit = 7 [default = 0];
  if (has_timelimit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->timelimit(), target);
  }

  // optional sint32 NodeType = 8 [default = 0];
  if (has_nodetype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(8, this->nodetype(), target);
  }

  // optional sint32 NodeArrowDisplayType = 9 [default = 0];
  if (has_nodearrowdisplaytype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(9, this->nodearrowdisplaytype(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapDataNodeInfoV1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float X = 1 [default = 0];
    if (has_x()) {
      total_size += 1 + 4;
    }

    // optional sint32 Layer = 2 [default = 0];
    if (has_layer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->layer());
    }

    // optional sint32 PassCondition = 3 [default = 0];
    if (has_passcondition()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->passcondition());
    }

    // optional sint32 KillEnemyID = 4 [default = 0];
    if (has_killenemyid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->killenemyid());
    }

    // optional sint32 KillEnemyCount = 5 [default = 0];
    if (has_killenemycount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->killenemycount());
    }

    // optional float TimeLimit = 7 [default = 0];
    if (has_timelimit()) {
      total_size += 1 + 4;
    }

    // optional sint32 NodeType = 8 [default = 0];
    if (has_nodetype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->nodetype());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional sint32 NodeArrowDisplayType = 9 [default = 0];
    if (has_nodearrowdisplaytype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->nodearrowdisplaytype());
    }

  }
  // repeated .MapDataMonsterInfoV1 MonsterArr = 6;
  total_size += 1 * this->monsterarr_size();
  for (int i = 0; i < this->monsterarr_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->monsterarr(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapDataNodeInfoV1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapDataNodeInfoV1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapDataNodeInfoV1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapDataNodeInfoV1::MergeFrom(const MapDataNodeInfoV1& from) {
  GOOGLE_CHECK_NE(&from, this);
  monsterarr_.MergeFrom(from.monsterarr_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_layer()) {
      set_layer(from.layer());
    }
    if (from.has_passcondition()) {
      set_passcondition(from.passcondition());
    }
    if (from.has_killenemyid()) {
      set_killenemyid(from.killenemyid());
    }
    if (from.has_killenemycount()) {
      set_killenemycount(from.killenemycount());
    }
    if (from.has_timelimit()) {
      set_timelimit(from.timelimit());
    }
    if (from.has_nodetype()) {
      set_nodetype(from.nodetype());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_nodearrowdisplaytype()) {
      set_nodearrowdisplaytype(from.nodearrowdisplaytype());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapDataNodeInfoV1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapDataNodeInfoV1::CopyFrom(const MapDataNodeInfoV1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapDataNodeInfoV1::IsInitialized() const {

  return true;
}

void MapDataNodeInfoV1::Swap(MapDataNodeInfoV1* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(layer_, other->layer_);
    std::swap(passcondition_, other->passcondition_);
    std::swap(killenemyid_, other->killenemyid_);
    std::swap(killenemycount_, other->killenemycount_);
    monsterarr_.Swap(&other->monsterarr_);
    std::swap(timelimit_, other->timelimit_);
    std::swap(nodetype_, other->nodetype_);
    std::swap(nodearrowdisplaytype_, other->nodearrowdisplaytype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapDataNodeInfoV1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapDataNodeInfoV1_descriptor_;
  metadata.reflection = MapDataNodeInfoV1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapDataTerritorialInfoV1::kLayerFieldNumber;
const int MapDataTerritorialInfoV1::kAreaFieldNumber;
const int MapDataTerritorialInfoV1::kXFieldNumber;
const int MapDataTerritorialInfoV1::kIDFieldNumber;
const int MapDataTerritorialInfoV1::kModelNameFieldNumber;
#endif  // !_MSC_VER

MapDataTerritorialInfoV1::MapDataTerritorialInfoV1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapDataTerritorialInfoV1::InitAsDefaultInstance() {
  area_ = const_cast< ::MapDataVector2V1*>(&::MapDataVector2V1::default_instance());
}

MapDataTerritorialInfoV1::MapDataTerritorialInfoV1(const MapDataTerritorialInfoV1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapDataTerritorialInfoV1::SharedCtor() {
  _cached_size_ = 0;
  layer_ = 0;
  area_ = NULL;
  x_ = 0;
  id_ = 0;
  modelname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapDataTerritorialInfoV1::~MapDataTerritorialInfoV1() {
  SharedDtor();
}

void MapDataTerritorialInfoV1::SharedDtor() {
  if (modelname_ != &::google::protobuf::internal::kEmptyString) {
    delete modelname_;
  }
  if (this != default_instance_) {
    delete area_;
  }
}

void MapDataTerritorialInfoV1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapDataTerritorialInfoV1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapDataTerritorialInfoV1_descriptor_;
}

const MapDataTerritorialInfoV1& MapDataTerritorialInfoV1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapDataV1Data_2eproto();
  return *default_instance_;
}

MapDataTerritorialInfoV1* MapDataTerritorialInfoV1::default_instance_ = NULL;

MapDataTerritorialInfoV1* MapDataTerritorialInfoV1::New() const {
  return new MapDataTerritorialInfoV1;
}

void MapDataTerritorialInfoV1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    layer_ = 0;
    if (has_area()) {
      if (area_ != NULL) area_->::MapDataVector2V1::Clear();
    }
    x_ = 0;
    id_ = 0;
    if (has_modelname()) {
      if (modelname_ != &::google::protobuf::internal::kEmptyString) {
        modelname_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapDataTerritorialInfoV1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint32 Layer = 1 [default = 0];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &layer_)));
          set_has_layer();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_Area;
        break;
      }

      // optional .MapDataVector2V1 Area = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_Area:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_area()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_X;
        break;
      }

      // optional float X = 3 [default = 0];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_X:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_ID;
        break;
      }

      // optional sint32 ID = 4 [default = 0];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_ID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_ModelName;
        break;
      }

      // optional string ModelName = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_ModelName:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_modelname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->modelname().data(), this->modelname().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapDataTerritorialInfoV1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional sint32 Layer = 1 [default = 0];
  if (has_layer()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(1, this->layer(), output);
  }

  // optional .MapDataVector2V1 Area = 2;
  if (has_area()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->area(), output);
  }

  // optional float X = 3 [default = 0];
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->x(), output);
  }

  // optional sint32 ID = 4 [default = 0];
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(4, this->id(), output);
  }

  // optional string ModelName = 5;
  if (has_modelname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->modelname().data(), this->modelname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->modelname(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapDataTerritorialInfoV1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional sint32 Layer = 1 [default = 0];
  if (has_layer()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(1, this->layer(), target);
  }

  // optional .MapDataVector2V1 Area = 2;
  if (has_area()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->area(), target);
  }

  // optional float X = 3 [default = 0];
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->x(), target);
  }

  // optional sint32 ID = 4 [default = 0];
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(4, this->id(), target);
  }

  // optional string ModelName = 5;
  if (has_modelname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->modelname().data(), this->modelname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->modelname(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapDataTerritorialInfoV1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional sint32 Layer = 1 [default = 0];
    if (has_layer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->layer());
    }

    // optional .MapDataVector2V1 Area = 2;
    if (has_area()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->area());
    }

    // optional float X = 3 [default = 0];
    if (has_x()) {
      total_size += 1 + 4;
    }

    // optional sint32 ID = 4 [default = 0];
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->id());
    }

    // optional string ModelName = 5;
    if (has_modelname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->modelname());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapDataTerritorialInfoV1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapDataTerritorialInfoV1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapDataTerritorialInfoV1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapDataTerritorialInfoV1::MergeFrom(const MapDataTerritorialInfoV1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_layer()) {
      set_layer(from.layer());
    }
    if (from.has_area()) {
      mutable_area()->::MapDataVector2V1::MergeFrom(from.area());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_modelname()) {
      set_modelname(from.modelname());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapDataTerritorialInfoV1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapDataTerritorialInfoV1::CopyFrom(const MapDataTerritorialInfoV1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapDataTerritorialInfoV1::IsInitialized() const {

  return true;
}

void MapDataTerritorialInfoV1::Swap(MapDataTerritorialInfoV1* other) {
  if (other != this) {
    std::swap(layer_, other->layer_);
    std::swap(area_, other->area_);
    std::swap(x_, other->x_);
    std::swap(id_, other->id_);
    std::swap(modelname_, other->modelname_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapDataTerritorialInfoV1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapDataTerritorialInfoV1_descriptor_;
  metadata.reflection = MapDataTerritorialInfoV1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapDataNodeMonsterInfoV1::kMonsterIdFieldNumber;
const int MapDataNodeMonsterInfoV1::kRandomWeightFieldNumber;
#endif  // !_MSC_VER

MapDataNodeMonsterInfoV1::MapDataNodeMonsterInfoV1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapDataNodeMonsterInfoV1::InitAsDefaultInstance() {
}

MapDataNodeMonsterInfoV1::MapDataNodeMonsterInfoV1(const MapDataNodeMonsterInfoV1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapDataNodeMonsterInfoV1::SharedCtor() {
  _cached_size_ = 0;
  monsterid_ = -1;
  randomweight_ = -1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapDataNodeMonsterInfoV1::~MapDataNodeMonsterInfoV1() {
  SharedDtor();
}

void MapDataNodeMonsterInfoV1::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapDataNodeMonsterInfoV1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapDataNodeMonsterInfoV1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapDataNodeMonsterInfoV1_descriptor_;
}

const MapDataNodeMonsterInfoV1& MapDataNodeMonsterInfoV1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapDataV1Data_2eproto();
  return *default_instance_;
}

MapDataNodeMonsterInfoV1* MapDataNodeMonsterInfoV1::default_instance_ = NULL;

MapDataNodeMonsterInfoV1* MapDataNodeMonsterInfoV1::New() const {
  return new MapDataNodeMonsterInfoV1;
}

void MapDataNodeMonsterInfoV1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    monsterid_ = -1;
    randomweight_ = -1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapDataNodeMonsterInfoV1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint32 MonsterId = 1 [default = -1];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &monsterid_)));
          set_has_monsterid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_RandomWeight;
        break;
      }

      // optional sint32 RandomWeight = 2 [default = -1];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_RandomWeight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &randomweight_)));
          set_has_randomweight();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapDataNodeMonsterInfoV1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional sint32 MonsterId = 1 [default = -1];
  if (has_monsterid()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(1, this->monsterid(), output);
  }

  // optional sint32 RandomWeight = 2 [default = -1];
  if (has_randomweight()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(2, this->randomweight(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapDataNodeMonsterInfoV1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional sint32 MonsterId = 1 [default = -1];
  if (has_monsterid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(1, this->monsterid(), target);
  }

  // optional sint32 RandomWeight = 2 [default = -1];
  if (has_randomweight()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(2, this->randomweight(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapDataNodeMonsterInfoV1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional sint32 MonsterId = 1 [default = -1];
    if (has_monsterid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->monsterid());
    }

    // optional sint32 RandomWeight = 2 [default = -1];
    if (has_randomweight()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->randomweight());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapDataNodeMonsterInfoV1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapDataNodeMonsterInfoV1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapDataNodeMonsterInfoV1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapDataNodeMonsterInfoV1::MergeFrom(const MapDataNodeMonsterInfoV1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_monsterid()) {
      set_monsterid(from.monsterid());
    }
    if (from.has_randomweight()) {
      set_randomweight(from.randomweight());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapDataNodeMonsterInfoV1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapDataNodeMonsterInfoV1::CopyFrom(const MapDataNodeMonsterInfoV1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapDataNodeMonsterInfoV1::IsInitialized() const {

  return true;
}

void MapDataNodeMonsterInfoV1::Swap(MapDataNodeMonsterInfoV1* other) {
  if (other != this) {
    std::swap(monsterid_, other->monsterid_);
    std::swap(randomweight_, other->randomweight_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapDataNodeMonsterInfoV1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapDataNodeMonsterInfoV1_descriptor_;
  metadata.reflection = MapDataNodeMonsterInfoV1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapDataBaseConfigV1::kMapTypeFieldNumber;
#endif  // !_MSC_VER

MapDataBaseConfigV1::MapDataBaseConfigV1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapDataBaseConfigV1::InitAsDefaultInstance() {
}

MapDataBaseConfigV1::MapDataBaseConfigV1(const MapDataBaseConfigV1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapDataBaseConfigV1::SharedCtor() {
  _cached_size_ = 0;
  maptype_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapDataBaseConfigV1::~MapDataBaseConfigV1() {
  SharedDtor();
}

void MapDataBaseConfigV1::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapDataBaseConfigV1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapDataBaseConfigV1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapDataBaseConfigV1_descriptor_;
}

const MapDataBaseConfigV1& MapDataBaseConfigV1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapDataV1Data_2eproto();
  return *default_instance_;
}

MapDataBaseConfigV1* MapDataBaseConfigV1::default_instance_ = NULL;

MapDataBaseConfigV1* MapDataBaseConfigV1::New() const {
  return new MapDataBaseConfigV1;
}

void MapDataBaseConfigV1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    maptype_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapDataBaseConfigV1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint32 MapType = 1 [default = 0];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &maptype_)));
          set_has_maptype();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapDataBaseConfigV1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional sint32 MapType = 1 [default = 0];
  if (has_maptype()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(1, this->maptype(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapDataBaseConfigV1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional sint32 MapType = 1 [default = 0];
  if (has_maptype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(1, this->maptype(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapDataBaseConfigV1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional sint32 MapType = 1 [default = 0];
    if (has_maptype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->maptype());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapDataBaseConfigV1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapDataBaseConfigV1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapDataBaseConfigV1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapDataBaseConfigV1::MergeFrom(const MapDataBaseConfigV1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_maptype()) {
      set_maptype(from.maptype());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapDataBaseConfigV1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapDataBaseConfigV1::CopyFrom(const MapDataBaseConfigV1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapDataBaseConfigV1::IsInitialized() const {

  return true;
}

void MapDataBaseConfigV1::Swap(MapDataBaseConfigV1* other) {
  if (other != this) {
    std::swap(maptype_, other->maptype_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapDataBaseConfigV1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapDataBaseConfigV1_descriptor_;
  metadata.reflection = MapDataBaseConfigV1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapDataGatherInfoV1::kGatherIdFieldNumber;
const int MapDataGatherInfoV1::kXFieldNumber;
const int MapDataGatherInfoV1::kLayerFieldNumber;
const int MapDataGatherInfoV1::kZFieldNumber;
const int MapDataGatherInfoV1::kDirectionFieldNumber;
#endif  // !_MSC_VER

MapDataGatherInfoV1::MapDataGatherInfoV1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapDataGatherInfoV1::InitAsDefaultInstance() {
}

MapDataGatherInfoV1::MapDataGatherInfoV1(const MapDataGatherInfoV1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapDataGatherInfoV1::SharedCtor() {
  _cached_size_ = 0;
  gatherid_ = 0;
  x_ = 0;
  layer_ = 0;
  z_ = 0;
  direction_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapDataGatherInfoV1::~MapDataGatherInfoV1() {
  SharedDtor();
}

void MapDataGatherInfoV1::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapDataGatherInfoV1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapDataGatherInfoV1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapDataGatherInfoV1_descriptor_;
}

const MapDataGatherInfoV1& MapDataGatherInfoV1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapDataV1Data_2eproto();
  return *default_instance_;
}

MapDataGatherInfoV1* MapDataGatherInfoV1::default_instance_ = NULL;

MapDataGatherInfoV1* MapDataGatherInfoV1::New() const {
  return new MapDataGatherInfoV1;
}

void MapDataGatherInfoV1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    gatherid_ = 0;
    x_ = 0;
    layer_ = 0;
    z_ = 0;
    direction_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapDataGatherInfoV1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional sint32 GatherId = 1 [default = 0];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &gatherid_)));
          set_has_gatherid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_X;
        break;
      }

      // optional float X = 2 [default = 0];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_X:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_Layer;
        break;
      }

      // optional sint32 Layer = 3 [default = 0];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Layer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &layer_)));
          set_has_layer();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_Z;
        break;
      }

      // optional float Z = 4 [default = 0];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_Z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_Direction;
        break;
      }

      // optional sint32 Direction = 5 [default = 1];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Direction:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &direction_)));
          set_has_direction();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapDataGatherInfoV1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional sint32 GatherId = 1 [default = 0];
  if (has_gatherid()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(1, this->gatherid(), output);
  }

  // optional float X = 2 [default = 0];
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->x(), output);
  }

  // optional sint32 Layer = 3 [default = 0];
  if (has_layer()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(3, this->layer(), output);
  }

  // optional float Z = 4 [default = 0];
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->z(), output);
  }

  // optional sint32 Direction = 5 [default = 1];
  if (has_direction()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(5, this->direction(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapDataGatherInfoV1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional sint32 GatherId = 1 [default = 0];
  if (has_gatherid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(1, this->gatherid(), target);
  }

  // optional float X = 2 [default = 0];
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->x(), target);
  }

  // optional sint32 Layer = 3 [default = 0];
  if (has_layer()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(3, this->layer(), target);
  }

  // optional float Z = 4 [default = 0];
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->z(), target);
  }

  // optional sint32 Direction = 5 [default = 1];
  if (has_direction()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(5, this->direction(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapDataGatherInfoV1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional sint32 GatherId = 1 [default = 0];
    if (has_gatherid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->gatherid());
    }

    // optional float X = 2 [default = 0];
    if (has_x()) {
      total_size += 1 + 4;
    }

    // optional sint32 Layer = 3 [default = 0];
    if (has_layer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->layer());
    }

    // optional float Z = 4 [default = 0];
    if (has_z()) {
      total_size += 1 + 4;
    }

    // optional sint32 Direction = 5 [default = 1];
    if (has_direction()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->direction());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapDataGatherInfoV1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapDataGatherInfoV1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapDataGatherInfoV1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapDataGatherInfoV1::MergeFrom(const MapDataGatherInfoV1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_gatherid()) {
      set_gatherid(from.gatherid());
    }
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_layer()) {
      set_layer(from.layer());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
    if (from.has_direction()) {
      set_direction(from.direction());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapDataGatherInfoV1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapDataGatherInfoV1::CopyFrom(const MapDataGatherInfoV1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapDataGatherInfoV1::IsInitialized() const {

  return true;
}

void MapDataGatherInfoV1::Swap(MapDataGatherInfoV1* other) {
  if (other != this) {
    std::swap(gatherid_, other->gatherid_);
    std::swap(x_, other->x_);
    std::swap(layer_, other->layer_);
    std::swap(z_, other->z_);
    std::swap(direction_, other->direction_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapDataGatherInfoV1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapDataGatherInfoV1_descriptor_;
  metadata.reflection = MapDataGatherInfoV1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapDataContourLineInfoV1::kYFieldNumber;
#endif  // !_MSC_VER

MapDataContourLineInfoV1::MapDataContourLineInfoV1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapDataContourLineInfoV1::InitAsDefaultInstance() {
}

MapDataContourLineInfoV1::MapDataContourLineInfoV1(const MapDataContourLineInfoV1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapDataContourLineInfoV1::SharedCtor() {
  _cached_size_ = 0;
  y_ = -1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapDataContourLineInfoV1::~MapDataContourLineInfoV1() {
  SharedDtor();
}

void MapDataContourLineInfoV1::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapDataContourLineInfoV1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapDataContourLineInfoV1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapDataContourLineInfoV1_descriptor_;
}

const MapDataContourLineInfoV1& MapDataContourLineInfoV1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapDataV1Data_2eproto();
  return *default_instance_;
}

MapDataContourLineInfoV1* MapDataContourLineInfoV1::default_instance_ = NULL;

MapDataContourLineInfoV1* MapDataContourLineInfoV1::New() const {
  return new MapDataContourLineInfoV1;
}

void MapDataContourLineInfoV1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    y_ = -1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapDataContourLineInfoV1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float Y = 1 [default = -1];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));
          set_has_y();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapDataContourLineInfoV1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float Y = 1 [default = -1];
  if (has_y()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->y(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapDataContourLineInfoV1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional float Y = 1 [default = -1];
  if (has_y()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->y(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapDataContourLineInfoV1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float Y = 1 [default = -1];
    if (has_y()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapDataContourLineInfoV1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapDataContourLineInfoV1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapDataContourLineInfoV1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapDataContourLineInfoV1::MergeFrom(const MapDataContourLineInfoV1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_y()) {
      set_y(from.y());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapDataContourLineInfoV1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapDataContourLineInfoV1::CopyFrom(const MapDataContourLineInfoV1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapDataContourLineInfoV1::IsInitialized() const {

  return true;
}

void MapDataContourLineInfoV1::Swap(MapDataContourLineInfoV1* other) {
  if (other != this) {
    std::swap(y_, other->y_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapDataContourLineInfoV1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapDataContourLineInfoV1_descriptor_;
  metadata.reflection = MapDataContourLineInfoV1_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int MapDataEventInfoV1::kX1FieldNumber;
const int MapDataEventInfoV1::kZ1FieldNumber;
const int MapDataEventInfoV1::kX2FieldNumber;
const int MapDataEventInfoV1::kZ2FieldNumber;
const int MapDataEventInfoV1::kTypeFieldNumber;
const int MapDataEventInfoV1::kEventIdFieldNumber;
const int MapDataEventInfoV1::kLayerFieldNumber;
#endif  // !_MSC_VER

MapDataEventInfoV1::MapDataEventInfoV1()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MapDataEventInfoV1::InitAsDefaultInstance() {
}

MapDataEventInfoV1::MapDataEventInfoV1(const MapDataEventInfoV1& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MapDataEventInfoV1::SharedCtor() {
  _cached_size_ = 0;
  x1_ = 0;
  z1_ = 0;
  x2_ = 0;
  z2_ = 0;
  type_ = 0;
  eventid_ = 0;
  layer_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MapDataEventInfoV1::~MapDataEventInfoV1() {
  SharedDtor();
}

void MapDataEventInfoV1::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MapDataEventInfoV1::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MapDataEventInfoV1::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MapDataEventInfoV1_descriptor_;
}

const MapDataEventInfoV1& MapDataEventInfoV1::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_MapDataV1Data_2eproto();
  return *default_instance_;
}

MapDataEventInfoV1* MapDataEventInfoV1::default_instance_ = NULL;

MapDataEventInfoV1* MapDataEventInfoV1::New() const {
  return new MapDataEventInfoV1;
}

void MapDataEventInfoV1::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x1_ = 0;
    z1_ = 0;
    x2_ = 0;
    z2_ = 0;
    type_ = 0;
    eventid_ = 0;
    layer_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MapDataEventInfoV1::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float X1 = 1 [default = 0];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x1_)));
          set_has_x1();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_Z1;
        break;
      }

      // optional float Z1 = 2 [default = 0];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_Z1:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z1_)));
          set_has_z1();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_X2;
        break;
      }

      // optional float X2 = 3 [default = 0];
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_X2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x2_)));
          set_has_x2();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_Z2;
        break;
      }

      // optional float Z2 = 4 [default = 0];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_Z2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z2_)));
          set_has_z2();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_Type;
        break;
      }

      // optional sint32 Type = 5 [default = 0];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_EventId;
        break;
      }

      // optional sint32 EventId = 6 [default = 0];
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_EventId:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &eventid_)));
          set_has_eventid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(56)) goto parse_Layer;
        break;
      }

      // optional sint32 Layer = 7 [default = 0];
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_Layer:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_SINT32>(
                 input, &layer_)));
          set_has_layer();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MapDataEventInfoV1::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float X1 = 1 [default = 0];
  if (has_x1()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x1(), output);
  }

  // optional float Z1 = 2 [default = 0];
  if (has_z1()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->z1(), output);
  }

  // optional float X2 = 3 [default = 0];
  if (has_x2()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->x2(), output);
  }

  // optional float Z2 = 4 [default = 0];
  if (has_z2()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->z2(), output);
  }

  // optional sint32 Type = 5 [default = 0];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(5, this->type(), output);
  }

  // optional sint32 EventId = 6 [default = 0];
  if (has_eventid()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(6, this->eventid(), output);
  }

  // optional sint32 Layer = 7 [default = 0];
  if (has_layer()) {
    ::google::protobuf::internal::WireFormatLite::WriteSInt32(7, this->layer(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MapDataEventInfoV1::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional float X1 = 1 [default = 0];
  if (has_x1()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x1(), target);
  }

  // optional float Z1 = 2 [default = 0];
  if (has_z1()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->z1(), target);
  }

  // optional float X2 = 3 [default = 0];
  if (has_x2()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->x2(), target);
  }

  // optional float Z2 = 4 [default = 0];
  if (has_z2()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->z2(), target);
  }

  // optional sint32 Type = 5 [default = 0];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(5, this->type(), target);
  }

  // optional sint32 EventId = 6 [default = 0];
  if (has_eventid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(6, this->eventid(), target);
  }

  // optional sint32 Layer = 7 [default = 0];
  if (has_layer()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteSInt32ToArray(7, this->layer(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MapDataEventInfoV1::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float X1 = 1 [default = 0];
    if (has_x1()) {
      total_size += 1 + 4;
    }

    // optional float Z1 = 2 [default = 0];
    if (has_z1()) {
      total_size += 1 + 4;
    }

    // optional float X2 = 3 [default = 0];
    if (has_x2()) {
      total_size += 1 + 4;
    }

    // optional float Z2 = 4 [default = 0];
    if (has_z2()) {
      total_size += 1 + 4;
    }

    // optional sint32 Type = 5 [default = 0];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->type());
    }

    // optional sint32 EventId = 6 [default = 0];
    if (has_eventid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->eventid());
    }

    // optional sint32 Layer = 7 [default = 0];
    if (has_layer()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::SInt32Size(
          this->layer());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MapDataEventInfoV1::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MapDataEventInfoV1* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MapDataEventInfoV1*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MapDataEventInfoV1::MergeFrom(const MapDataEventInfoV1& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x1()) {
      set_x1(from.x1());
    }
    if (from.has_z1()) {
      set_z1(from.z1());
    }
    if (from.has_x2()) {
      set_x2(from.x2());
    }
    if (from.has_z2()) {
      set_z2(from.z2());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_eventid()) {
      set_eventid(from.eventid());
    }
    if (from.has_layer()) {
      set_layer(from.layer());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MapDataEventInfoV1::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MapDataEventInfoV1::CopyFrom(const MapDataEventInfoV1& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MapDataEventInfoV1::IsInitialized() const {

  return true;
}

void MapDataEventInfoV1::Swap(MapDataEventInfoV1* other) {
  if (other != this) {
    std::swap(x1_, other->x1_);
    std::swap(z1_, other->z1_);
    std::swap(x2_, other->x2_);
    std::swap(z2_, other->z2_);
    std::swap(type_, other->type_);
    std::swap(eventid_, other->eventid_);
    std::swap(layer_, other->layer_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MapDataEventInfoV1::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MapDataEventInfoV1_descriptor_;
  metadata.reflection = MapDataEventInfoV1_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
