// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ActionV1Data.proto

#ifndef PROTOBUF_ActionV1Data_2eproto__INCLUDED
#define PROTOBUF_ActionV1Data_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "PublicStruct.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ActionV1Data_2eproto();
void protobuf_AssignDesc_ActionV1Data_2eproto();
void protobuf_ShutdownFile_ActionV1Data_2eproto();

class ActionSkillInfoV1;
class ActionCommandInfoV1;
class ActionUselessV1;
class ActionV2V1;
class ActionV3V1;
class ActionRangeV1;

// ===================================================================

class ActionSkillInfoV1 : public ::google::protobuf::Message {
 public:
  ActionSkillInfoV1();
  virtual ~ActionSkillInfoV1();

  ActionSkillInfoV1(const ActionSkillInfoV1& from);

  inline ActionSkillInfoV1& operator=(const ActionSkillInfoV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionSkillInfoV1& default_instance();

  void Swap(ActionSkillInfoV1* other);

  // implements Message ----------------------------------------------

  ActionSkillInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionSkillInfoV1& from);
  void MergeFrom(const ActionSkillInfoV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .ActionCommandInfoV1 CommandList = 2;
  inline int commandlist_size() const;
  inline void clear_commandlist();
  static const int kCommandListFieldNumber = 2;
  inline const ::ActionCommandInfoV1& commandlist(int index) const;
  inline ::ActionCommandInfoV1* mutable_commandlist(int index);
  inline ::ActionCommandInfoV1* add_commandlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ActionCommandInfoV1 >&
      commandlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ActionCommandInfoV1 >*
      mutable_commandlist();

  // optional float TotalTime = 3 [default = 0];
  inline bool has_totaltime() const;
  inline void clear_totaltime();
  static const int kTotalTimeFieldNumber = 3;
  inline float totaltime() const;
  inline void set_totaltime(float value);

  // optional bool IsSing = 4 [default = false];
  inline bool has_issing() const;
  inline void clear_issing();
  static const int kIsSingFieldNumber = 4;
  inline bool issing() const;
  inline void set_issing(bool value);

  // optional float SingTime = 5 [default = 0];
  inline bool has_singtime() const;
  inline void clear_singtime();
  static const int kSingTimeFieldNumber = 5;
  inline float singtime() const;
  inline void set_singtime(float value);

  // @@protoc_insertion_point(class_scope:ActionSkillInfoV1)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_totaltime();
  inline void clear_has_totaltime();
  inline void set_has_issing();
  inline void clear_has_issing();
  inline void set_has_singtime();
  inline void clear_has_singtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::ActionCommandInfoV1 > commandlist_;
  float totaltime_;
  bool issing_;
  float singtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_ActionV1Data_2eproto();
  friend void protobuf_AssignDesc_ActionV1Data_2eproto();
  friend void protobuf_ShutdownFile_ActionV1Data_2eproto();

  void InitAsDefaultInstance();
  static ActionSkillInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class ActionCommandInfoV1 : public ::google::protobuf::Message {
 public:
  ActionCommandInfoV1();
  virtual ~ActionCommandInfoV1();

  ActionCommandInfoV1(const ActionCommandInfoV1& from);

  inline ActionCommandInfoV1& operator=(const ActionCommandInfoV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionCommandInfoV1& default_instance();

  void Swap(ActionCommandInfoV1* other);

  // implements Message ----------------------------------------------

  ActionCommandInfoV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionCommandInfoV1& from);
  void MergeFrom(const ActionCommandInfoV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 CommandType = 2 [default = -1];
  inline bool has_commandtype() const;
  inline void clear_commandtype();
  static const int kCommandTypeFieldNumber = 2;
  inline ::google::protobuf::int32 commandtype() const;
  inline void set_commandtype(::google::protobuf::int32 value);

  // optional float StartTime = 3 [default = 0];
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 3;
  inline float starttime() const;
  inline void set_starttime(float value);

  // optional float DurationTime = 4 [default = 0];
  inline bool has_durationtime() const;
  inline void clear_durationtime();
  static const int kDurationTimeFieldNumber = 4;
  inline float durationtime() const;
  inline void set_durationtime(float value);

  // optional sint32 AnimationTriggerCondition = 5 [default = 0];
  inline bool has_animationtriggercondition() const;
  inline void clear_animationtriggercondition();
  static const int kAnimationTriggerConditionFieldNumber = 5;
  inline ::google::protobuf::int32 animationtriggercondition() const;
  inline void set_animationtriggercondition(::google::protobuf::int32 value);

  // optional string EffectName = 6;
  inline bool has_effectname() const;
  inline void clear_effectname();
  static const int kEffectNameFieldNumber = 6;
  inline const ::std::string& effectname() const;
  inline void set_effectname(const ::std::string& value);
  inline void set_effectname(const char* value);
  inline void set_effectname(const char* value, size_t size);
  inline ::std::string* mutable_effectname();
  inline ::std::string* release_effectname();
  inline void set_allocated_effectname(::std::string* effectname);

  // optional sint32 EffectBoneHook = 7 [default = 0];
  inline bool has_effectbonehook() const;
  inline void clear_effectbonehook();
  static const int kEffectBoneHookFieldNumber = 7;
  inline ::google::protobuf::int32 effectbonehook() const;
  inline void set_effectbonehook(::google::protobuf::int32 value);

  // optional .ActionV3V1 EffectPositionOffset = 8;
  inline bool has_effectpositionoffset() const;
  inline void clear_effectpositionoffset();
  static const int kEffectPositionOffsetFieldNumber = 8;
  inline const ::ActionV3V1& effectpositionoffset() const;
  inline ::ActionV3V1* mutable_effectpositionoffset();
  inline ::ActionV3V1* release_effectpositionoffset();
  inline void set_allocated_effectpositionoffset(::ActionV3V1* effectpositionoffset);

  // optional bool EffectStayInLocalSpace = 9 [default = false];
  inline bool has_effectstayinlocalspace() const;
  inline void clear_effectstayinlocalspace();
  static const int kEffectStayInLocalSpaceFieldNumber = 9;
  inline bool effectstayinlocalspace() const;
  inline void set_effectstayinlocalspace(bool value);

  // optional sint32 EffectControlObjectId = 10 [default = 0];
  inline bool has_effectcontrolobjectid() const;
  inline void clear_effectcontrolobjectid();
  static const int kEffectControlObjectIdFieldNumber = 10;
  inline ::google::protobuf::int32 effectcontrolobjectid() const;
  inline void set_effectcontrolobjectid(::google::protobuf::int32 value);

  // optional sint32 TranslateControlId = 11 [default = 0];
  inline bool has_translatecontrolid() const;
  inline void clear_translatecontrolid();
  static const int kTranslateControlIdFieldNumber = 11;
  inline ::google::protobuf::int32 translatecontrolid() const;
  inline void set_translatecontrolid(::google::protobuf::int32 value);

  // optional .ActionV3V1 TranslateOffset = 12;
  inline bool has_translateoffset() const;
  inline void clear_translateoffset();
  static const int kTranslateOffsetFieldNumber = 12;
  inline const ::ActionV3V1& translateoffset() const;
  inline ::ActionV3V1* mutable_translateoffset();
  inline ::ActionV3V1* release_translateoffset();
  inline void set_allocated_translateoffset(::ActionV3V1* translateoffset);

  // repeated sint32 ActorAttackPart = 13;
  inline int actorattackpart_size() const;
  inline void clear_actorattackpart();
  static const int kActorAttackPartFieldNumber = 13;
  inline ::google::protobuf::int32 actorattackpart(int index) const;
  inline void set_actorattackpart(int index, ::google::protobuf::int32 value);
  inline void add_actorattackpart(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      actorattackpart() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_actorattackpart();

  // optional sint32 TranslateEase = 14 [default = 1];
  inline bool has_translateease() const;
  inline void clear_translateease();
  static const int kTranslateEaseFieldNumber = 14;
  inline ::google::protobuf::int32 translateease() const;
  inline void set_translateease(::google::protobuf::int32 value);

  // optional bool AttackShowHitEffect = 15 [default = false];
  inline bool has_attackshowhiteffect() const;
  inline void clear_attackshowhiteffect();
  static const int kAttackShowHitEffectFieldNumber = 15;
  inline bool attackshowhiteffect() const;
  inline void set_attackshowhiteffect(bool value);

  // optional string AttackHitEffectName = 16;
  inline bool has_attackhiteffectname() const;
  inline void clear_attackhiteffectname();
  static const int kAttackHitEffectNameFieldNumber = 16;
  inline const ::std::string& attackhiteffectname() const;
  inline void set_attackhiteffectname(const ::std::string& value);
  inline void set_attackhiteffectname(const char* value);
  inline void set_attackhiteffectname(const char* value, size_t size);
  inline ::std::string* mutable_attackhiteffectname();
  inline ::std::string* release_attackhiteffectname();
  inline void set_allocated_attackhiteffectname(::std::string* attackhiteffectname);

  // optional float AttackHitEffectDuration = 17 [default = 1.6];
  inline bool has_attackhiteffectduration() const;
  inline void clear_attackhiteffectduration();
  static const int kAttackHitEffectDurationFieldNumber = 17;
  inline float attackhiteffectduration() const;
  inline void set_attackhiteffectduration(float value);

  // optional sint32 AttackFragmentCount = 18 [default = 1];
  inline bool has_attackfragmentcount() const;
  inline void clear_attackfragmentcount();
  static const int kAttackFragmentCountFieldNumber = 18;
  inline ::google::protobuf::int32 attackfragmentcount() const;
  inline void set_attackfragmentcount(::google::protobuf::int32 value);

  // optional float AttackFragmentIntervalTime = 19 [default = 0];
  inline bool has_attackfragmentintervaltime() const;
  inline void clear_attackfragmentintervaltime();
  static const int kAttackFragmentIntervalTimeFieldNumber = 19;
  inline float attackfragmentintervaltime() const;
  inline void set_attackfragmentintervaltime(float value);

  // optional float AttackDamageRadio = 20 [default = 1];
  inline bool has_attackdamageradio() const;
  inline void clear_attackdamageradio();
  static const int kAttackDamageRadioFieldNumber = 20;
  inline float attackdamageradio() const;
  inline void set_attackdamageradio(float value);

  // optional bool BuffSelfActive = 21 [default = false];
  inline bool has_buffselfactive() const;
  inline void clear_buffselfactive();
  static const int kBuffSelfActiveFieldNumber = 21;
  inline bool buffselfactive() const;
  inline void set_buffselfactive(bool value);

  // optional bool BuffTargetActive = 22 [default = false];
  inline bool has_bufftargetactive() const;
  inline void clear_bufftargetactive();
  static const int kBuffTargetActiveFieldNumber = 22;
  inline bool bufftargetactive() const;
  inline void set_bufftargetactive(bool value);

  // optional float AttackBehaviourBackDistance = 24 [default = 0];
  inline bool has_attackbehaviourbackdistance() const;
  inline void clear_attackbehaviourbackdistance();
  static const int kAttackBehaviourBackDistanceFieldNumber = 24;
  inline float attackbehaviourbackdistance() const;
  inline void set_attackbehaviourbackdistance(float value);

  // optional float AttackBehaviourAirHeight = 25 [default = 0];
  inline bool has_attackbehaviourairheight() const;
  inline void clear_attackbehaviourairheight();
  static const int kAttackBehaviourAirHeightFieldNumber = 25;
  inline float attackbehaviourairheight() const;
  inline void set_attackbehaviourairheight(float value);

  // optional .ActionV3V1 EffectRotationOffset = 27;
  inline bool has_effectrotationoffset() const;
  inline void clear_effectrotationoffset();
  static const int kEffectRotationOffsetFieldNumber = 27;
  inline const ::ActionV3V1& effectrotationoffset() const;
  inline ::ActionV3V1* mutable_effectrotationoffset();
  inline ::ActionV3V1* release_effectrotationoffset();
  inline void set_allocated_effectrotationoffset(::ActionV3V1* effectrotationoffset);

  // optional sint32 FlashControlObjectId = 28 [default = 0];
  inline bool has_flashcontrolobjectid() const;
  inline void clear_flashcontrolobjectid();
  static const int kFlashControlObjectIdFieldNumber = 28;
  inline ::google::protobuf::int32 flashcontrolobjectid() const;
  inline void set_flashcontrolobjectid(::google::protobuf::int32 value);

  // optional float AttackStiffTime = 29 [default = 0];
  inline bool has_attackstifftime() const;
  inline void clear_attackstifftime();
  static const int kAttackStiffTimeFieldNumber = 29;
  inline float attackstifftime() const;
  inline void set_attackstifftime(float value);

  // optional bool AttackShake = 30 [default = false];
  inline bool has_attackshake() const;
  inline void clear_attackshake();
  static const int kAttackShakeFieldNumber = 30;
  inline bool attackshake() const;
  inline void set_attackshake(bool value);

  // optional bool AttackFlash = 31 [default = false];
  inline bool has_attackflash() const;
  inline void clear_attackflash();
  static const int kAttackFlashFieldNumber = 31;
  inline bool attackflash() const;
  inline void set_attackflash(bool value);

  // optional float AttackBehaviourBackSpeed = 32 [default = 1];
  inline bool has_attackbehaviourbackspeed() const;
  inline void clear_attackbehaviourbackspeed();
  static const int kAttackBehaviourBackSpeedFieldNumber = 32;
  inline float attackbehaviourbackspeed() const;
  inline void set_attackbehaviourbackspeed(float value);

  // optional float AttackBehaviourAirSpeed = 33 [default = 1];
  inline bool has_attackbehaviourairspeed() const;
  inline void clear_attackbehaviourairspeed();
  static const int kAttackBehaviourAirSpeedFieldNumber = 33;
  inline float attackbehaviourairspeed() const;
  inline void set_attackbehaviourairspeed(float value);

  // optional bool AttackBehaviourBack = 35 [default = false];
  inline bool has_attackbehaviourback() const;
  inline void clear_attackbehaviourback();
  static const int kAttackBehaviourBackFieldNumber = 35;
  inline bool attackbehaviourback() const;
  inline void set_attackbehaviourback(bool value);

  // optional bool AttackBehaviourAir = 36 [default = false];
  inline bool has_attackbehaviourair() const;
  inline void clear_attackbehaviourair();
  static const int kAttackBehaviourAirFieldNumber = 36;
  inline bool attackbehaviourair() const;
  inline void set_attackbehaviourair(bool value);

  // optional bool AttackBehaviourZoom = 37 [default = false];
  inline bool has_attackbehaviourzoom() const;
  inline void clear_attackbehaviourzoom();
  static const int kAttackBehaviourZoomFieldNumber = 37;
  inline bool attackbehaviourzoom() const;
  inline void set_attackbehaviourzoom(bool value);

  // optional string SoundName = 38;
  inline bool has_soundname() const;
  inline void clear_soundname();
  static const int kSoundNameFieldNumber = 38;
  inline const ::std::string& soundname() const;
  inline void set_soundname(const ::std::string& value);
  inline void set_soundname(const char* value);
  inline void set_soundname(const char* value, size_t size);
  inline ::std::string* mutable_soundname();
  inline ::std::string* release_soundname();
  inline void set_allocated_soundname(::std::string* soundname);

  // optional bool Trigger = 39 [default = false];
  inline bool has_trigger() const;
  inline void clear_trigger();
  static const int kTriggerFieldNumber = 39;
  inline bool trigger() const;
  inline void set_trigger(bool value);

  // optional sint32 TriggerIndex = 40 [default = 1];
  inline bool has_triggerindex() const;
  inline void clear_triggerindex();
  static const int kTriggerIndexFieldNumber = 40;
  inline ::google::protobuf::int32 triggerindex() const;
  inline void set_triggerindex(::google::protobuf::int32 value);

  // optional sint32 AttackHitDummy = 41 [default = 0];
  inline bool has_attackhitdummy() const;
  inline void clear_attackhitdummy();
  static const int kAttackHitDummyFieldNumber = 41;
  inline ::google::protobuf::int32 attackhitdummy() const;
  inline void set_attackhitdummy(::google::protobuf::int32 value);

  // optional string AttackHitSound = 42;
  inline bool has_attackhitsound() const;
  inline void clear_attackhitsound();
  static const int kAttackHitSoundFieldNumber = 42;
  inline const ::std::string& attackhitsound() const;
  inline void set_attackhitsound(const ::std::string& value);
  inline void set_attackhitsound(const char* value);
  inline void set_attackhitsound(const char* value, size_t size);
  inline ::std::string* mutable_attackhitsound();
  inline ::std::string* release_attackhitsound();
  inline void set_allocated_attackhitsound(::std::string* attackhitsound);

  // optional float HitShakeCameraXRange = 44 [default = 0];
  inline bool has_hitshakecameraxrange() const;
  inline void clear_hitshakecameraxrange();
  static const int kHitShakeCameraXRangeFieldNumber = 44;
  inline float hitshakecameraxrange() const;
  inline void set_hitshakecameraxrange(float value);

  // optional float HitShakeCameraYRange = 45 [default = 0];
  inline bool has_hitshakecamerayrange() const;
  inline void clear_hitshakecamerayrange();
  static const int kHitShakeCameraYRangeFieldNumber = 45;
  inline float hitshakecamerayrange() const;
  inline void set_hitshakecamerayrange(float value);

  // optional sint32 HitShakeCameraCount = 46 [default = 1];
  inline bool has_hitshakecameracount() const;
  inline void clear_hitshakecameracount();
  static const int kHitShakeCameraCountFieldNumber = 46;
  inline ::google::protobuf::int32 hitshakecameracount() const;
  inline void set_hitshakecameracount(::google::protobuf::int32 value);

  // optional float HitShakeCameraDurationTime = 47 [default = 0.1];
  inline bool has_hitshakecameradurationtime() const;
  inline void clear_hitshakecameradurationtime();
  static const int kHitShakeCameraDurationTimeFieldNumber = 47;
  inline float hitshakecameradurationtime() const;
  inline void set_hitshakecameradurationtime(float value);

  // optional sint32 HiddenWeaponMode = 50 [default = 0];
  inline bool has_hiddenweaponmode() const;
  inline void clear_hiddenweaponmode();
  static const int kHiddenWeaponModeFieldNumber = 50;
  inline ::google::protobuf::int32 hiddenweaponmode() const;
  inline void set_hiddenweaponmode(::google::protobuf::int32 value);

  // optional string NextActionName = 51;
  inline bool has_nextactionname() const;
  inline void clear_nextactionname();
  static const int kNextActionNameFieldNumber = 51;
  inline const ::std::string& nextactionname() const;
  inline void set_nextactionname(const ::std::string& value);
  inline void set_nextactionname(const char* value);
  inline void set_nextactionname(const char* value, size_t size);
  inline ::std::string* mutable_nextactionname();
  inline ::std::string* release_nextactionname();
  inline void set_allocated_nextactionname(::std::string* nextactionname);

  // optional sint32 TranslateWrapMode = 52 [default = 0];
  inline bool has_translatewrapmode() const;
  inline void clear_translatewrapmode();
  static const int kTranslateWrapModeFieldNumber = 52;
  inline ::google::protobuf::int32 translatewrapmode() const;
  inline void set_translatewrapmode(::google::protobuf::int32 value);

  // optional bool IsTriggerSecondAttack = 53 [default = false];
  inline bool has_istriggersecondattack() const;
  inline void clear_istriggersecondattack();
  static const int kIsTriggerSecondAttackFieldNumber = 53;
  inline bool istriggersecondattack() const;
  inline void set_istriggersecondattack(bool value);

  // optional bool IsHitGround = 54 [default = false];
  inline bool has_ishitground() const;
  inline void clear_ishitground();
  static const int kIsHitGroundFieldNumber = 54;
  inline bool ishitground() const;
  inline void set_ishitground(bool value);

  // optional string SkillActionName = 55;
  inline bool has_skillactionname() const;
  inline void clear_skillactionname();
  static const int kSkillActionNameFieldNumber = 55;
  inline const ::std::string& skillactionname() const;
  inline void set_skillactionname(const ::std::string& value);
  inline void set_skillactionname(const char* value);
  inline void set_skillactionname(const char* value, size_t size);
  inline ::std::string* mutable_skillactionname();
  inline ::std::string* release_skillactionname();
  inline void set_allocated_skillactionname(::std::string* skillactionname);

  // optional string WarningRes1 = 56;
  inline bool has_warningres1() const;
  inline void clear_warningres1();
  static const int kWarningRes1FieldNumber = 56;
  inline const ::std::string& warningres1() const;
  inline void set_warningres1(const ::std::string& value);
  inline void set_warningres1(const char* value);
  inline void set_warningres1(const char* value, size_t size);
  inline ::std::string* mutable_warningres1();
  inline ::std::string* release_warningres1();
  inline void set_allocated_warningres1(::std::string* warningres1);

  // optional string WarningRes2 = 57;
  inline bool has_warningres2() const;
  inline void clear_warningres2();
  static const int kWarningRes2FieldNumber = 57;
  inline const ::std::string& warningres2() const;
  inline void set_warningres2(const ::std::string& value);
  inline void set_warningres2(const char* value);
  inline void set_warningres2(const char* value, size_t size);
  inline ::std::string* mutable_warningres2();
  inline ::std::string* release_warningres2();
  inline void set_allocated_warningres2(::std::string* warningres2);

  // optional .ActionV3V1 WarningMaxScale = 58;
  inline bool has_warningmaxscale() const;
  inline void clear_warningmaxscale();
  static const int kWarningMaxScaleFieldNumber = 58;
  inline const ::ActionV3V1& warningmaxscale() const;
  inline ::ActionV3V1* mutable_warningmaxscale();
  inline ::ActionV3V1* release_warningmaxscale();
  inline void set_allocated_warningmaxscale(::ActionV3V1* warningmaxscale);

  // optional sint32 WarningScaleMode = 59 [default = 0];
  inline bool has_warningscalemode() const;
  inline void clear_warningscalemode();
  static const int kWarningScaleModeFieldNumber = 59;
  inline ::google::protobuf::int32 warningscalemode() const;
  inline void set_warningscalemode(::google::protobuf::int32 value);

  // optional sint32 WarningLockAxle = 60 [default = 0];
  inline bool has_warninglockaxle() const;
  inline void clear_warninglockaxle();
  static const int kWarningLockAxleFieldNumber = 60;
  inline ::google::protobuf::int32 warninglockaxle() const;
  inline void set_warninglockaxle(::google::protobuf::int32 value);

  // optional .ActionV3V1 WarningPositionOffset = 61;
  inline bool has_warningpositionoffset() const;
  inline void clear_warningpositionoffset();
  static const int kWarningPositionOffsetFieldNumber = 61;
  inline const ::ActionV3V1& warningpositionoffset() const;
  inline ::ActionV3V1* mutable_warningpositionoffset();
  inline ::ActionV3V1* release_warningpositionoffset();
  inline void set_allocated_warningpositionoffset(::ActionV3V1* warningpositionoffset);

  // optional bool IsEffectFollow = 62 [default = false];
  inline bool has_iseffectfollow() const;
  inline void clear_iseffectfollow();
  static const int kIsEffectFollowFieldNumber = 62;
  inline bool iseffectfollow() const;
  inline void set_iseffectfollow(bool value);

  // optional bool IsWarningTarget = 63 [default = false];
  inline bool has_iswarningtarget() const;
  inline void clear_iswarningtarget();
  static const int kIsWarningTargetFieldNumber = 63;
  inline bool iswarningtarget() const;
  inline void set_iswarningtarget(bool value);

  // optional float AttackBehaviourAirDurationTime = 64 [default = 0];
  inline bool has_attackbehaviourairdurationtime() const;
  inline void clear_attackbehaviourairdurationtime();
  static const int kAttackBehaviourAirDurationTimeFieldNumber = 64;
  inline float attackbehaviourairdurationtime() const;
  inline void set_attackbehaviourairdurationtime(float value);

  // optional bool IsColliderDestroy = 66 [default = false];
  inline bool has_iscolliderdestroy() const;
  inline void clear_iscolliderdestroy();
  static const int kIsColliderDestroyFieldNumber = 66;
  inline bool iscolliderdestroy() const;
  inline void set_iscolliderdestroy(bool value);

  // optional bool IsAttackRangeFollow = 70 [default = false];
  inline bool has_isattackrangefollow() const;
  inline void clear_isattackrangefollow();
  static const int kIsAttackRangeFollowFieldNumber = 70;
  inline bool isattackrangefollow() const;
  inline void set_isattackrangefollow(bool value);

  // optional bool IsAnimationLoop = 71 [default = false];
  inline bool has_isanimationloop() const;
  inline void clear_isanimationloop();
  static const int kIsAnimationLoopFieldNumber = 71;
  inline bool isanimationloop() const;
  inline void set_isanimationloop(bool value);

  // optional float TranslateAngle = 72 [default = 0];
  inline bool has_translateangle() const;
  inline void clear_translateangle();
  static const int kTranslateAngleFieldNumber = 72;
  inline float translateangle() const;
  inline void set_translateangle(float value);

  // optional bool IsAttackRangeShade = 73 [default = false];
  inline bool has_isattackrangeshade() const;
  inline void clear_isattackrangeshade();
  static const int kIsAttackRangeShadeFieldNumber = 73;
  inline bool isattackrangeshade() const;
  inline void set_isattackrangeshade(bool value);

  // optional float AttackInterval = 75 [default = 0];
  inline bool has_attackinterval() const;
  inline void clear_attackinterval();
  static const int kAttackIntervalFieldNumber = 75;
  inline float attackinterval() const;
  inline void set_attackinterval(float value);

  // optional bool IsShowAttackRect = 76 [default = false];
  inline bool has_isshowattackrect() const;
  inline void clear_isshowattackrect();
  static const int kIsShowAttackRectFieldNumber = 76;
  inline bool isshowattackrect() const;
  inline void set_isshowattackrect(bool value);

  // optional float EffectBulletLaunchAngle = 78 [default = 0];
  inline bool has_effectbulletlaunchangle() const;
  inline void clear_effectbulletlaunchangle();
  static const int kEffectBulletLaunchAngleFieldNumber = 78;
  inline float effectbulletlaunchangle() const;
  inline void set_effectbulletlaunchangle(float value);

  // optional float EffectBulletSpeed = 79 [default = 0];
  inline bool has_effectbulletspeed() const;
  inline void clear_effectbulletspeed();
  static const int kEffectBulletSpeedFieldNumber = 79;
  inline float effectbulletspeed() const;
  inline void set_effectbulletspeed(float value);

  // optional .ActionRangeV1 EffectBulletLaunchTimeIntervalRange = 80;
  inline bool has_effectbulletlaunchtimeintervalrange() const;
  inline void clear_effectbulletlaunchtimeintervalrange();
  static const int kEffectBulletLaunchTimeIntervalRangeFieldNumber = 80;
  inline const ::ActionRangeV1& effectbulletlaunchtimeintervalrange() const;
  inline ::ActionRangeV1* mutable_effectbulletlaunchtimeintervalrange();
  inline ::ActionRangeV1* release_effectbulletlaunchtimeintervalrange();
  inline void set_allocated_effectbulletlaunchtimeintervalrange(::ActionRangeV1* effectbulletlaunchtimeintervalrange);

  // optional sint32 EffectBulletMaxCout = 82 [default = 0];
  inline bool has_effectbulletmaxcout() const;
  inline void clear_effectbulletmaxcout();
  static const int kEffectBulletMaxCoutFieldNumber = 82;
  inline ::google::protobuf::int32 effectbulletmaxcout() const;
  inline void set_effectbulletmaxcout(::google::protobuf::int32 value);

  // optional .ActionRangeV1 EffectBulletLifeTimeInteralRange = 83;
  inline bool has_effectbulletlifetimeinteralrange() const;
  inline void clear_effectbulletlifetimeinteralrange();
  static const int kEffectBulletLifeTimeInteralRangeFieldNumber = 83;
  inline const ::ActionRangeV1& effectbulletlifetimeinteralrange() const;
  inline ::ActionRangeV1* mutable_effectbulletlifetimeinteralrange();
  inline ::ActionRangeV1* release_effectbulletlifetimeinteralrange();
  inline void set_allocated_effectbulletlifetimeinteralrange(::ActionRangeV1* effectbulletlifetimeinteralrange);

  // optional sint32 EffectBulletType = 84 [default = 0];
  inline bool has_effectbullettype() const;
  inline void clear_effectbullettype();
  static const int kEffectBulletTypeFieldNumber = 84;
  inline ::google::protobuf::int32 effectbullettype() const;
  inline void set_effectbullettype(::google::protobuf::int32 value);

  // repeated .ActionV3V1 EffectBulletInitPosList = 85;
  inline int effectbulletinitposlist_size() const;
  inline void clear_effectbulletinitposlist();
  static const int kEffectBulletInitPosListFieldNumber = 85;
  inline const ::ActionV3V1& effectbulletinitposlist(int index) const;
  inline ::ActionV3V1* mutable_effectbulletinitposlist(int index);
  inline ::ActionV3V1* add_effectbulletinitposlist();
  inline const ::google::protobuf::RepeatedPtrField< ::ActionV3V1 >&
      effectbulletinitposlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::ActionV3V1 >*
      mutable_effectbulletinitposlist();

  // optional sint32 EffectBulletLaunchMaxCount = 86 [default = 0];
  inline bool has_effectbulletlaunchmaxcount() const;
  inline void clear_effectbulletlaunchmaxcount();
  static const int kEffectBulletLaunchMaxCountFieldNumber = 86;
  inline ::google::protobuf::int32 effectbulletlaunchmaxcount() const;
  inline void set_effectbulletlaunchmaxcount(::google::protobuf::int32 value);

  // optional bool EffectBulletIsFollow = 88 [default = false];
  inline bool has_effectbulletisfollow() const;
  inline void clear_effectbulletisfollow();
  static const int kEffectBulletIsFollowFieldNumber = 88;
  inline bool effectbulletisfollow() const;
  inline void set_effectbulletisfollow(bool value);

  // optional float AttackBehaviourAirDownSpeed = 89 [default = 0];
  inline bool has_attackbehaviourairdownspeed() const;
  inline void clear_attackbehaviourairdownspeed();
  static const int kAttackBehaviourAirDownSpeedFieldNumber = 89;
  inline float attackbehaviourairdownspeed() const;
  inline void set_attackbehaviourairdownspeed(float value);

  // optional sint32 EffectDirectionLockType = 90 [default = 0];
  inline bool has_effectdirectionlocktype() const;
  inline void clear_effectdirectionlocktype();
  static const int kEffectDirectionLockTypeFieldNumber = 90;
  inline ::google::protobuf::int32 effectdirectionlocktype() const;
  inline void set_effectdirectionlocktype(::google::protobuf::int32 value);

  // optional bool IsIrregularityEffect = 91 [default = false];
  inline bool has_isirregularityeffect() const;
  inline void clear_isirregularityeffect();
  static const int kIsIrregularityEffectFieldNumber = 91;
  inline bool isirregularityeffect() const;
  inline void set_isirregularityeffect(bool value);

  // optional .ActionV3V1 EffectSize = 92;
  inline bool has_effectsize() const;
  inline void clear_effectsize();
  static const int kEffectSizeFieldNumber = 92;
  inline const ::ActionV3V1& effectsize() const;
  inline ::ActionV3V1* mutable_effectsize();
  inline ::ActionV3V1* release_effectsize();
  inline void set_allocated_effectsize(::ActionV3V1* effectsize);

  // optional .ActionV3V1 AttackRangePostion = 93;
  inline bool has_attackrangepostion() const;
  inline void clear_attackrangepostion();
  static const int kAttackRangePostionFieldNumber = 93;
  inline const ::ActionV3V1& attackrangepostion() const;
  inline ::ActionV3V1* mutable_attackrangepostion();
  inline ::ActionV3V1* release_attackrangepostion();
  inline void set_allocated_attackrangepostion(::ActionV3V1* attackrangepostion);

  // optional .ActionV3V1 AttackRangeSize = 94;
  inline bool has_attackrangesize() const;
  inline void clear_attackrangesize();
  static const int kAttackRangeSizeFieldNumber = 94;
  inline const ::ActionV3V1& attackrangesize() const;
  inline ::ActionV3V1* mutable_attackrangesize();
  inline ::ActionV3V1* release_attackrangesize();
  inline void set_allocated_attackrangesize(::ActionV3V1* attackrangesize);

  // optional sint32 AttackShape = 95 [default = 0];
  inline bool has_attackshape() const;
  inline void clear_attackshape();
  static const int kAttackShapeFieldNumber = 95;
  inline ::google::protobuf::int32 attackshape() const;
  inline void set_attackshape(::google::protobuf::int32 value);

  // optional .ActionV3V1 AttackCircleOrigin = 96;
  inline bool has_attackcircleorigin() const;
  inline void clear_attackcircleorigin();
  static const int kAttackCircleOriginFieldNumber = 96;
  inline const ::ActionV3V1& attackcircleorigin() const;
  inline ::ActionV3V1* mutable_attackcircleorigin();
  inline ::ActionV3V1* release_attackcircleorigin();
  inline void set_allocated_attackcircleorigin(::ActionV3V1* attackcircleorigin);

  // optional float AttackCircleRadius = 97 [default = 0];
  inline bool has_attackcircleradius() const;
  inline void clear_attackcircleradius();
  static const int kAttackCircleRadiusFieldNumber = 97;
  inline float attackcircleradius() const;
  inline void set_attackcircleradius(float value);

  // optional float AttackCircleAngle = 98 [default = 0];
  inline bool has_attackcircleangle() const;
  inline void clear_attackcircleangle();
  static const int kAttackCircleAngleFieldNumber = 98;
  inline float attackcircleangle() const;
  inline void set_attackcircleangle(float value);

  // @@protoc_insertion_point(class_scope:ActionCommandInfoV1)
 private:
  inline void set_has_commandtype();
  inline void clear_has_commandtype();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_durationtime();
  inline void clear_has_durationtime();
  inline void set_has_animationtriggercondition();
  inline void clear_has_animationtriggercondition();
  inline void set_has_effectname();
  inline void clear_has_effectname();
  inline void set_has_effectbonehook();
  inline void clear_has_effectbonehook();
  inline void set_has_effectpositionoffset();
  inline void clear_has_effectpositionoffset();
  inline void set_has_effectstayinlocalspace();
  inline void clear_has_effectstayinlocalspace();
  inline void set_has_effectcontrolobjectid();
  inline void clear_has_effectcontrolobjectid();
  inline void set_has_translatecontrolid();
  inline void clear_has_translatecontrolid();
  inline void set_has_translateoffset();
  inline void clear_has_translateoffset();
  inline void set_has_translateease();
  inline void clear_has_translateease();
  inline void set_has_attackshowhiteffect();
  inline void clear_has_attackshowhiteffect();
  inline void set_has_attackhiteffectname();
  inline void clear_has_attackhiteffectname();
  inline void set_has_attackhiteffectduration();
  inline void clear_has_attackhiteffectduration();
  inline void set_has_attackfragmentcount();
  inline void clear_has_attackfragmentcount();
  inline void set_has_attackfragmentintervaltime();
  inline void clear_has_attackfragmentintervaltime();
  inline void set_has_attackdamageradio();
  inline void clear_has_attackdamageradio();
  inline void set_has_buffselfactive();
  inline void clear_has_buffselfactive();
  inline void set_has_bufftargetactive();
  inline void clear_has_bufftargetactive();
  inline void set_has_attackbehaviourbackdistance();
  inline void clear_has_attackbehaviourbackdistance();
  inline void set_has_attackbehaviourairheight();
  inline void clear_has_attackbehaviourairheight();
  inline void set_has_effectrotationoffset();
  inline void clear_has_effectrotationoffset();
  inline void set_has_flashcontrolobjectid();
  inline void clear_has_flashcontrolobjectid();
  inline void set_has_attackstifftime();
  inline void clear_has_attackstifftime();
  inline void set_has_attackshake();
  inline void clear_has_attackshake();
  inline void set_has_attackflash();
  inline void clear_has_attackflash();
  inline void set_has_attackbehaviourbackspeed();
  inline void clear_has_attackbehaviourbackspeed();
  inline void set_has_attackbehaviourairspeed();
  inline void clear_has_attackbehaviourairspeed();
  inline void set_has_attackbehaviourback();
  inline void clear_has_attackbehaviourback();
  inline void set_has_attackbehaviourair();
  inline void clear_has_attackbehaviourair();
  inline void set_has_attackbehaviourzoom();
  inline void clear_has_attackbehaviourzoom();
  inline void set_has_soundname();
  inline void clear_has_soundname();
  inline void set_has_trigger();
  inline void clear_has_trigger();
  inline void set_has_triggerindex();
  inline void clear_has_triggerindex();
  inline void set_has_attackhitdummy();
  inline void clear_has_attackhitdummy();
  inline void set_has_attackhitsound();
  inline void clear_has_attackhitsound();
  inline void set_has_hitshakecameraxrange();
  inline void clear_has_hitshakecameraxrange();
  inline void set_has_hitshakecamerayrange();
  inline void clear_has_hitshakecamerayrange();
  inline void set_has_hitshakecameracount();
  inline void clear_has_hitshakecameracount();
  inline void set_has_hitshakecameradurationtime();
  inline void clear_has_hitshakecameradurationtime();
  inline void set_has_hiddenweaponmode();
  inline void clear_has_hiddenweaponmode();
  inline void set_has_nextactionname();
  inline void clear_has_nextactionname();
  inline void set_has_translatewrapmode();
  inline void clear_has_translatewrapmode();
  inline void set_has_istriggersecondattack();
  inline void clear_has_istriggersecondattack();
  inline void set_has_ishitground();
  inline void clear_has_ishitground();
  inline void set_has_skillactionname();
  inline void clear_has_skillactionname();
  inline void set_has_warningres1();
  inline void clear_has_warningres1();
  inline void set_has_warningres2();
  inline void clear_has_warningres2();
  inline void set_has_warningmaxscale();
  inline void clear_has_warningmaxscale();
  inline void set_has_warningscalemode();
  inline void clear_has_warningscalemode();
  inline void set_has_warninglockaxle();
  inline void clear_has_warninglockaxle();
  inline void set_has_warningpositionoffset();
  inline void clear_has_warningpositionoffset();
  inline void set_has_iseffectfollow();
  inline void clear_has_iseffectfollow();
  inline void set_has_iswarningtarget();
  inline void clear_has_iswarningtarget();
  inline void set_has_attackbehaviourairdurationtime();
  inline void clear_has_attackbehaviourairdurationtime();
  inline void set_has_iscolliderdestroy();
  inline void clear_has_iscolliderdestroy();
  inline void set_has_isattackrangefollow();
  inline void clear_has_isattackrangefollow();
  inline void set_has_isanimationloop();
  inline void clear_has_isanimationloop();
  inline void set_has_translateangle();
  inline void clear_has_translateangle();
  inline void set_has_isattackrangeshade();
  inline void clear_has_isattackrangeshade();
  inline void set_has_attackinterval();
  inline void clear_has_attackinterval();
  inline void set_has_isshowattackrect();
  inline void clear_has_isshowattackrect();
  inline void set_has_effectbulletlaunchangle();
  inline void clear_has_effectbulletlaunchangle();
  inline void set_has_effectbulletspeed();
  inline void clear_has_effectbulletspeed();
  inline void set_has_effectbulletlaunchtimeintervalrange();
  inline void clear_has_effectbulletlaunchtimeintervalrange();
  inline void set_has_effectbulletmaxcout();
  inline void clear_has_effectbulletmaxcout();
  inline void set_has_effectbulletlifetimeinteralrange();
  inline void clear_has_effectbulletlifetimeinteralrange();
  inline void set_has_effectbullettype();
  inline void clear_has_effectbullettype();
  inline void set_has_effectbulletlaunchmaxcount();
  inline void clear_has_effectbulletlaunchmaxcount();
  inline void set_has_effectbulletisfollow();
  inline void clear_has_effectbulletisfollow();
  inline void set_has_attackbehaviourairdownspeed();
  inline void clear_has_attackbehaviourairdownspeed();
  inline void set_has_effectdirectionlocktype();
  inline void clear_has_effectdirectionlocktype();
  inline void set_has_isirregularityeffect();
  inline void clear_has_isirregularityeffect();
  inline void set_has_effectsize();
  inline void clear_has_effectsize();
  inline void set_has_attackrangepostion();
  inline void clear_has_attackrangepostion();
  inline void set_has_attackrangesize();
  inline void clear_has_attackrangesize();
  inline void set_has_attackshape();
  inline void clear_has_attackshape();
  inline void set_has_attackcircleorigin();
  inline void clear_has_attackcircleorigin();
  inline void set_has_attackcircleradius();
  inline void clear_has_attackcircleradius();
  inline void set_has_attackcircleangle();
  inline void clear_has_attackcircleangle();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 commandtype_;
  float starttime_;
  float durationtime_;
  ::google::protobuf::int32 animationtriggercondition_;
  ::std::string* effectname_;
  ::ActionV3V1* effectpositionoffset_;
  ::google::protobuf::int32 effectbonehook_;
  ::google::protobuf::int32 effectcontrolobjectid_;
  ::ActionV3V1* translateoffset_;
  ::google::protobuf::int32 translatecontrolid_;
  ::google::protobuf::int32 translateease_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > actorattackpart_;
  ::std::string* attackhiteffectname_;
  bool effectstayinlocalspace_;
  bool attackshowhiteffect_;
  bool buffselfactive_;
  bool bufftargetactive_;
  float attackhiteffectduration_;
  ::google::protobuf::int32 attackfragmentcount_;
  float attackfragmentintervaltime_;
  float attackdamageradio_;
  float attackbehaviourbackdistance_;
  ::ActionV3V1* effectrotationoffset_;
  float attackbehaviourairheight_;
  ::google::protobuf::int32 flashcontrolobjectid_;
  float attackstifftime_;
  float attackbehaviourbackspeed_;
  bool attackshake_;
  bool attackflash_;
  bool attackbehaviourback_;
  bool attackbehaviourair_;
  float attackbehaviourairspeed_;
  ::std::string* soundname_;
  ::google::protobuf::int32 triggerindex_;
  ::google::protobuf::int32 attackhitdummy_;
  ::std::string* attackhitsound_;
  float hitshakecameraxrange_;
  float hitshakecamerayrange_;
  bool attackbehaviourzoom_;
  bool trigger_;
  bool istriggersecondattack_;
  bool ishitground_;
  ::google::protobuf::int32 hitshakecameracount_;
  float hitshakecameradurationtime_;
  ::google::protobuf::int32 hiddenweaponmode_;
  ::std::string* nextactionname_;
  ::std::string* skillactionname_;
  ::google::protobuf::int32 translatewrapmode_;
  ::google::protobuf::int32 warningscalemode_;
  ::std::string* warningres1_;
  ::std::string* warningres2_;
  ::ActionV3V1* warningmaxscale_;
  ::ActionV3V1* warningpositionoffset_;
  ::google::protobuf::int32 warninglockaxle_;
  float attackbehaviourairdurationtime_;
  bool iseffectfollow_;
  bool iswarningtarget_;
  bool iscolliderdestroy_;
  bool isattackrangefollow_;
  float translateangle_;
  float attackinterval_;
  bool isanimationloop_;
  bool isattackrangeshade_;
  bool isshowattackrect_;
  bool effectbulletisfollow_;
  float effectbulletlaunchangle_;
  float effectbulletspeed_;
  ::ActionRangeV1* effectbulletlaunchtimeintervalrange_;
  ::ActionRangeV1* effectbulletlifetimeinteralrange_;
  ::google::protobuf::int32 effectbulletmaxcout_;
  ::google::protobuf::int32 effectbullettype_;
  ::google::protobuf::RepeatedPtrField< ::ActionV3V1 > effectbulletinitposlist_;
  ::google::protobuf::int32 effectbulletlaunchmaxcount_;
  float attackbehaviourairdownspeed_;
  ::google::protobuf::int32 effectdirectionlocktype_;
  bool isirregularityeffect_;
  ::ActionV3V1* effectsize_;
  ::ActionV3V1* attackrangepostion_;
  ::ActionV3V1* attackrangesize_;
  ::ActionV3V1* attackcircleorigin_;
  ::google::protobuf::int32 attackshape_;
  float attackcircleradius_;
  float attackcircleangle_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(83 + 31) / 32];

  friend void  protobuf_AddDesc_ActionV1Data_2eproto();
  friend void protobuf_AssignDesc_ActionV1Data_2eproto();
  friend void protobuf_ShutdownFile_ActionV1Data_2eproto();

  void InitAsDefaultInstance();
  static ActionCommandInfoV1* default_instance_;
};
// -------------------------------------------------------------------

class ActionUselessV1 : public ::google::protobuf::Message {
 public:
  ActionUselessV1();
  virtual ~ActionUselessV1();

  ActionUselessV1(const ActionUselessV1& from);

  inline ActionUselessV1& operator=(const ActionUselessV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionUselessV1& default_instance();

  void Swap(ActionUselessV1* other);

  // implements Message ----------------------------------------------

  ActionUselessV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionUselessV1& from);
  void MergeFrom(const ActionUselessV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ActionUselessV1)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_ActionV1Data_2eproto();
  friend void protobuf_AssignDesc_ActionV1Data_2eproto();
  friend void protobuf_ShutdownFile_ActionV1Data_2eproto();

  void InitAsDefaultInstance();
  static ActionUselessV1* default_instance_;
};
// -------------------------------------------------------------------

class ActionV2V1 : public ::google::protobuf::Message {
 public:
  ActionV2V1();
  virtual ~ActionV2V1();

  ActionV2V1(const ActionV2V1& from);

  inline ActionV2V1& operator=(const ActionV2V1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionV2V1& default_instance();

  void Swap(ActionV2V1* other);

  // implements Message ----------------------------------------------

  ActionV2V1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionV2V1& from);
  void MergeFrom(const ActionV2V1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float X = 1 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float Y = 2 [default = 0];
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // @@protoc_insertion_point(class_scope:ActionV2V1)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ActionV1Data_2eproto();
  friend void protobuf_AssignDesc_ActionV1Data_2eproto();
  friend void protobuf_ShutdownFile_ActionV1Data_2eproto();

  void InitAsDefaultInstance();
  static ActionV2V1* default_instance_;
};
// -------------------------------------------------------------------

class ActionV3V1 : public ::google::protobuf::Message {
 public:
  ActionV3V1();
  virtual ~ActionV3V1();

  ActionV3V1(const ActionV3V1& from);

  inline ActionV3V1& operator=(const ActionV3V1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionV3V1& default_instance();

  void Swap(ActionV3V1* other);

  // implements Message ----------------------------------------------

  ActionV3V1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionV3V1& from);
  void MergeFrom(const ActionV3V1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float X = 1 [default = 0];
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float Y = 2 [default = 0];
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional float Z = 3 [default = 0];
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:ActionV3V1)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float x_;
  float y_;
  float z_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_ActionV1Data_2eproto();
  friend void protobuf_AssignDesc_ActionV1Data_2eproto();
  friend void protobuf_ShutdownFile_ActionV1Data_2eproto();

  void InitAsDefaultInstance();
  static ActionV3V1* default_instance_;
};
// -------------------------------------------------------------------

class ActionRangeV1 : public ::google::protobuf::Message {
 public:
  ActionRangeV1();
  virtual ~ActionRangeV1();

  ActionRangeV1(const ActionRangeV1& from);

  inline ActionRangeV1& operator=(const ActionRangeV1& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActionRangeV1& default_instance();

  void Swap(ActionRangeV1* other);

  // implements Message ----------------------------------------------

  ActionRangeV1* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ActionRangeV1& from);
  void MergeFrom(const ActionRangeV1& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float MinValue = 3 [default = 0];
  inline bool has_minvalue() const;
  inline void clear_minvalue();
  static const int kMinValueFieldNumber = 3;
  inline float minvalue() const;
  inline void set_minvalue(float value);

  // optional float MaxValue = 5 [default = 0];
  inline bool has_maxvalue() const;
  inline void clear_maxvalue();
  static const int kMaxValueFieldNumber = 5;
  inline float maxvalue() const;
  inline void set_maxvalue(float value);

  // @@protoc_insertion_point(class_scope:ActionRangeV1)
 private:
  inline void set_has_minvalue();
  inline void clear_has_minvalue();
  inline void set_has_maxvalue();
  inline void clear_has_maxvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  float minvalue_;
  float maxvalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_ActionV1Data_2eproto();
  friend void protobuf_AssignDesc_ActionV1Data_2eproto();
  friend void protobuf_ShutdownFile_ActionV1Data_2eproto();

  void InitAsDefaultInstance();
  static ActionRangeV1* default_instance_;
};
// ===================================================================


// ===================================================================

// ActionSkillInfoV1

// optional string Name = 1;
inline bool ActionSkillInfoV1::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionSkillInfoV1::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionSkillInfoV1::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionSkillInfoV1::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ActionSkillInfoV1::name() const {
  return *name_;
}
inline void ActionSkillInfoV1::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ActionSkillInfoV1::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ActionSkillInfoV1::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActionSkillInfoV1::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ActionSkillInfoV1::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActionSkillInfoV1::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .ActionCommandInfoV1 CommandList = 2;
inline int ActionSkillInfoV1::commandlist_size() const {
  return commandlist_.size();
}
inline void ActionSkillInfoV1::clear_commandlist() {
  commandlist_.Clear();
}
inline const ::ActionCommandInfoV1& ActionSkillInfoV1::commandlist(int index) const {
  return commandlist_.Get(index);
}
inline ::ActionCommandInfoV1* ActionSkillInfoV1::mutable_commandlist(int index) {
  return commandlist_.Mutable(index);
}
inline ::ActionCommandInfoV1* ActionSkillInfoV1::add_commandlist() {
  return commandlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ActionCommandInfoV1 >&
ActionSkillInfoV1::commandlist() const {
  return commandlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ActionCommandInfoV1 >*
ActionSkillInfoV1::mutable_commandlist() {
  return &commandlist_;
}

// optional float TotalTime = 3 [default = 0];
inline bool ActionSkillInfoV1::has_totaltime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActionSkillInfoV1::set_has_totaltime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActionSkillInfoV1::clear_has_totaltime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActionSkillInfoV1::clear_totaltime() {
  totaltime_ = 0;
  clear_has_totaltime();
}
inline float ActionSkillInfoV1::totaltime() const {
  return totaltime_;
}
inline void ActionSkillInfoV1::set_totaltime(float value) {
  set_has_totaltime();
  totaltime_ = value;
}

// optional bool IsSing = 4 [default = false];
inline bool ActionSkillInfoV1::has_issing() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActionSkillInfoV1::set_has_issing() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActionSkillInfoV1::clear_has_issing() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActionSkillInfoV1::clear_issing() {
  issing_ = false;
  clear_has_issing();
}
inline bool ActionSkillInfoV1::issing() const {
  return issing_;
}
inline void ActionSkillInfoV1::set_issing(bool value) {
  set_has_issing();
  issing_ = value;
}

// optional float SingTime = 5 [default = 0];
inline bool ActionSkillInfoV1::has_singtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActionSkillInfoV1::set_has_singtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActionSkillInfoV1::clear_has_singtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActionSkillInfoV1::clear_singtime() {
  singtime_ = 0;
  clear_has_singtime();
}
inline float ActionSkillInfoV1::singtime() const {
  return singtime_;
}
inline void ActionSkillInfoV1::set_singtime(float value) {
  set_has_singtime();
  singtime_ = value;
}

// -------------------------------------------------------------------

// ActionCommandInfoV1

// optional sint32 CommandType = 2 [default = -1];
inline bool ActionCommandInfoV1::has_commandtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionCommandInfoV1::set_has_commandtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionCommandInfoV1::clear_has_commandtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionCommandInfoV1::clear_commandtype() {
  commandtype_ = -1;
  clear_has_commandtype();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::commandtype() const {
  return commandtype_;
}
inline void ActionCommandInfoV1::set_commandtype(::google::protobuf::int32 value) {
  set_has_commandtype();
  commandtype_ = value;
}

// optional float StartTime = 3 [default = 0];
inline bool ActionCommandInfoV1::has_starttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionCommandInfoV1::set_has_starttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionCommandInfoV1::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionCommandInfoV1::clear_starttime() {
  starttime_ = 0;
  clear_has_starttime();
}
inline float ActionCommandInfoV1::starttime() const {
  return starttime_;
}
inline void ActionCommandInfoV1::set_starttime(float value) {
  set_has_starttime();
  starttime_ = value;
}

// optional float DurationTime = 4 [default = 0];
inline bool ActionCommandInfoV1::has_durationtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActionCommandInfoV1::set_has_durationtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActionCommandInfoV1::clear_has_durationtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActionCommandInfoV1::clear_durationtime() {
  durationtime_ = 0;
  clear_has_durationtime();
}
inline float ActionCommandInfoV1::durationtime() const {
  return durationtime_;
}
inline void ActionCommandInfoV1::set_durationtime(float value) {
  set_has_durationtime();
  durationtime_ = value;
}

// optional sint32 AnimationTriggerCondition = 5 [default = 0];
inline bool ActionCommandInfoV1::has_animationtriggercondition() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActionCommandInfoV1::set_has_animationtriggercondition() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActionCommandInfoV1::clear_has_animationtriggercondition() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActionCommandInfoV1::clear_animationtriggercondition() {
  animationtriggercondition_ = 0;
  clear_has_animationtriggercondition();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::animationtriggercondition() const {
  return animationtriggercondition_;
}
inline void ActionCommandInfoV1::set_animationtriggercondition(::google::protobuf::int32 value) {
  set_has_animationtriggercondition();
  animationtriggercondition_ = value;
}

// optional string EffectName = 6;
inline bool ActionCommandInfoV1::has_effectname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActionCommandInfoV1::set_has_effectname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActionCommandInfoV1::clear_has_effectname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActionCommandInfoV1::clear_effectname() {
  if (effectname_ != &::google::protobuf::internal::kEmptyString) {
    effectname_->clear();
  }
  clear_has_effectname();
}
inline const ::std::string& ActionCommandInfoV1::effectname() const {
  return *effectname_;
}
inline void ActionCommandInfoV1::set_effectname(const ::std::string& value) {
  set_has_effectname();
  if (effectname_ == &::google::protobuf::internal::kEmptyString) {
    effectname_ = new ::std::string;
  }
  effectname_->assign(value);
}
inline void ActionCommandInfoV1::set_effectname(const char* value) {
  set_has_effectname();
  if (effectname_ == &::google::protobuf::internal::kEmptyString) {
    effectname_ = new ::std::string;
  }
  effectname_->assign(value);
}
inline void ActionCommandInfoV1::set_effectname(const char* value, size_t size) {
  set_has_effectname();
  if (effectname_ == &::google::protobuf::internal::kEmptyString) {
    effectname_ = new ::std::string;
  }
  effectname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActionCommandInfoV1::mutable_effectname() {
  set_has_effectname();
  if (effectname_ == &::google::protobuf::internal::kEmptyString) {
    effectname_ = new ::std::string;
  }
  return effectname_;
}
inline ::std::string* ActionCommandInfoV1::release_effectname() {
  clear_has_effectname();
  if (effectname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = effectname_;
    effectname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActionCommandInfoV1::set_allocated_effectname(::std::string* effectname) {
  if (effectname_ != &::google::protobuf::internal::kEmptyString) {
    delete effectname_;
  }
  if (effectname) {
    set_has_effectname();
    effectname_ = effectname;
  } else {
    clear_has_effectname();
    effectname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint32 EffectBoneHook = 7 [default = 0];
inline bool ActionCommandInfoV1::has_effectbonehook() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ActionCommandInfoV1::set_has_effectbonehook() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ActionCommandInfoV1::clear_has_effectbonehook() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ActionCommandInfoV1::clear_effectbonehook() {
  effectbonehook_ = 0;
  clear_has_effectbonehook();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::effectbonehook() const {
  return effectbonehook_;
}
inline void ActionCommandInfoV1::set_effectbonehook(::google::protobuf::int32 value) {
  set_has_effectbonehook();
  effectbonehook_ = value;
}

// optional .ActionV3V1 EffectPositionOffset = 8;
inline bool ActionCommandInfoV1::has_effectpositionoffset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ActionCommandInfoV1::set_has_effectpositionoffset() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ActionCommandInfoV1::clear_has_effectpositionoffset() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ActionCommandInfoV1::clear_effectpositionoffset() {
  if (effectpositionoffset_ != NULL) effectpositionoffset_->::ActionV3V1::Clear();
  clear_has_effectpositionoffset();
}
inline const ::ActionV3V1& ActionCommandInfoV1::effectpositionoffset() const {
  return effectpositionoffset_ != NULL ? *effectpositionoffset_ : *default_instance_->effectpositionoffset_;
}
inline ::ActionV3V1* ActionCommandInfoV1::mutable_effectpositionoffset() {
  set_has_effectpositionoffset();
  if (effectpositionoffset_ == NULL) effectpositionoffset_ = new ::ActionV3V1;
  return effectpositionoffset_;
}
inline ::ActionV3V1* ActionCommandInfoV1::release_effectpositionoffset() {
  clear_has_effectpositionoffset();
  ::ActionV3V1* temp = effectpositionoffset_;
  effectpositionoffset_ = NULL;
  return temp;
}
inline void ActionCommandInfoV1::set_allocated_effectpositionoffset(::ActionV3V1* effectpositionoffset) {
  delete effectpositionoffset_;
  effectpositionoffset_ = effectpositionoffset;
  if (effectpositionoffset) {
    set_has_effectpositionoffset();
  } else {
    clear_has_effectpositionoffset();
  }
}

// optional bool EffectStayInLocalSpace = 9 [default = false];
inline bool ActionCommandInfoV1::has_effectstayinlocalspace() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ActionCommandInfoV1::set_has_effectstayinlocalspace() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ActionCommandInfoV1::clear_has_effectstayinlocalspace() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ActionCommandInfoV1::clear_effectstayinlocalspace() {
  effectstayinlocalspace_ = false;
  clear_has_effectstayinlocalspace();
}
inline bool ActionCommandInfoV1::effectstayinlocalspace() const {
  return effectstayinlocalspace_;
}
inline void ActionCommandInfoV1::set_effectstayinlocalspace(bool value) {
  set_has_effectstayinlocalspace();
  effectstayinlocalspace_ = value;
}

// optional sint32 EffectControlObjectId = 10 [default = 0];
inline bool ActionCommandInfoV1::has_effectcontrolobjectid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ActionCommandInfoV1::set_has_effectcontrolobjectid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ActionCommandInfoV1::clear_has_effectcontrolobjectid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ActionCommandInfoV1::clear_effectcontrolobjectid() {
  effectcontrolobjectid_ = 0;
  clear_has_effectcontrolobjectid();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::effectcontrolobjectid() const {
  return effectcontrolobjectid_;
}
inline void ActionCommandInfoV1::set_effectcontrolobjectid(::google::protobuf::int32 value) {
  set_has_effectcontrolobjectid();
  effectcontrolobjectid_ = value;
}

// optional sint32 TranslateControlId = 11 [default = 0];
inline bool ActionCommandInfoV1::has_translatecontrolid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ActionCommandInfoV1::set_has_translatecontrolid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ActionCommandInfoV1::clear_has_translatecontrolid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ActionCommandInfoV1::clear_translatecontrolid() {
  translatecontrolid_ = 0;
  clear_has_translatecontrolid();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::translatecontrolid() const {
  return translatecontrolid_;
}
inline void ActionCommandInfoV1::set_translatecontrolid(::google::protobuf::int32 value) {
  set_has_translatecontrolid();
  translatecontrolid_ = value;
}

// optional .ActionV3V1 TranslateOffset = 12;
inline bool ActionCommandInfoV1::has_translateoffset() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ActionCommandInfoV1::set_has_translateoffset() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ActionCommandInfoV1::clear_has_translateoffset() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ActionCommandInfoV1::clear_translateoffset() {
  if (translateoffset_ != NULL) translateoffset_->::ActionV3V1::Clear();
  clear_has_translateoffset();
}
inline const ::ActionV3V1& ActionCommandInfoV1::translateoffset() const {
  return translateoffset_ != NULL ? *translateoffset_ : *default_instance_->translateoffset_;
}
inline ::ActionV3V1* ActionCommandInfoV1::mutable_translateoffset() {
  set_has_translateoffset();
  if (translateoffset_ == NULL) translateoffset_ = new ::ActionV3V1;
  return translateoffset_;
}
inline ::ActionV3V1* ActionCommandInfoV1::release_translateoffset() {
  clear_has_translateoffset();
  ::ActionV3V1* temp = translateoffset_;
  translateoffset_ = NULL;
  return temp;
}
inline void ActionCommandInfoV1::set_allocated_translateoffset(::ActionV3V1* translateoffset) {
  delete translateoffset_;
  translateoffset_ = translateoffset;
  if (translateoffset) {
    set_has_translateoffset();
  } else {
    clear_has_translateoffset();
  }
}

// repeated sint32 ActorAttackPart = 13;
inline int ActionCommandInfoV1::actorattackpart_size() const {
  return actorattackpart_.size();
}
inline void ActionCommandInfoV1::clear_actorattackpart() {
  actorattackpart_.Clear();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::actorattackpart(int index) const {
  return actorattackpart_.Get(index);
}
inline void ActionCommandInfoV1::set_actorattackpart(int index, ::google::protobuf::int32 value) {
  actorattackpart_.Set(index, value);
}
inline void ActionCommandInfoV1::add_actorattackpart(::google::protobuf::int32 value) {
  actorattackpart_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ActionCommandInfoV1::actorattackpart() const {
  return actorattackpart_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ActionCommandInfoV1::mutable_actorattackpart() {
  return &actorattackpart_;
}

// optional sint32 TranslateEase = 14 [default = 1];
inline bool ActionCommandInfoV1::has_translateease() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ActionCommandInfoV1::set_has_translateease() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ActionCommandInfoV1::clear_has_translateease() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ActionCommandInfoV1::clear_translateease() {
  translateease_ = 1;
  clear_has_translateease();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::translateease() const {
  return translateease_;
}
inline void ActionCommandInfoV1::set_translateease(::google::protobuf::int32 value) {
  set_has_translateease();
  translateease_ = value;
}

// optional bool AttackShowHitEffect = 15 [default = false];
inline bool ActionCommandInfoV1::has_attackshowhiteffect() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackshowhiteffect() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ActionCommandInfoV1::clear_has_attackshowhiteffect() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ActionCommandInfoV1::clear_attackshowhiteffect() {
  attackshowhiteffect_ = false;
  clear_has_attackshowhiteffect();
}
inline bool ActionCommandInfoV1::attackshowhiteffect() const {
  return attackshowhiteffect_;
}
inline void ActionCommandInfoV1::set_attackshowhiteffect(bool value) {
  set_has_attackshowhiteffect();
  attackshowhiteffect_ = value;
}

// optional string AttackHitEffectName = 16;
inline bool ActionCommandInfoV1::has_attackhiteffectname() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackhiteffectname() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ActionCommandInfoV1::clear_has_attackhiteffectname() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ActionCommandInfoV1::clear_attackhiteffectname() {
  if (attackhiteffectname_ != &::google::protobuf::internal::kEmptyString) {
    attackhiteffectname_->clear();
  }
  clear_has_attackhiteffectname();
}
inline const ::std::string& ActionCommandInfoV1::attackhiteffectname() const {
  return *attackhiteffectname_;
}
inline void ActionCommandInfoV1::set_attackhiteffectname(const ::std::string& value) {
  set_has_attackhiteffectname();
  if (attackhiteffectname_ == &::google::protobuf::internal::kEmptyString) {
    attackhiteffectname_ = new ::std::string;
  }
  attackhiteffectname_->assign(value);
}
inline void ActionCommandInfoV1::set_attackhiteffectname(const char* value) {
  set_has_attackhiteffectname();
  if (attackhiteffectname_ == &::google::protobuf::internal::kEmptyString) {
    attackhiteffectname_ = new ::std::string;
  }
  attackhiteffectname_->assign(value);
}
inline void ActionCommandInfoV1::set_attackhiteffectname(const char* value, size_t size) {
  set_has_attackhiteffectname();
  if (attackhiteffectname_ == &::google::protobuf::internal::kEmptyString) {
    attackhiteffectname_ = new ::std::string;
  }
  attackhiteffectname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActionCommandInfoV1::mutable_attackhiteffectname() {
  set_has_attackhiteffectname();
  if (attackhiteffectname_ == &::google::protobuf::internal::kEmptyString) {
    attackhiteffectname_ = new ::std::string;
  }
  return attackhiteffectname_;
}
inline ::std::string* ActionCommandInfoV1::release_attackhiteffectname() {
  clear_has_attackhiteffectname();
  if (attackhiteffectname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attackhiteffectname_;
    attackhiteffectname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActionCommandInfoV1::set_allocated_attackhiteffectname(::std::string* attackhiteffectname) {
  if (attackhiteffectname_ != &::google::protobuf::internal::kEmptyString) {
    delete attackhiteffectname_;
  }
  if (attackhiteffectname) {
    set_has_attackhiteffectname();
    attackhiteffectname_ = attackhiteffectname;
  } else {
    clear_has_attackhiteffectname();
    attackhiteffectname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float AttackHitEffectDuration = 17 [default = 1.6];
inline bool ActionCommandInfoV1::has_attackhiteffectduration() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackhiteffectduration() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ActionCommandInfoV1::clear_has_attackhiteffectduration() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ActionCommandInfoV1::clear_attackhiteffectduration() {
  attackhiteffectduration_ = 1.6f;
  clear_has_attackhiteffectduration();
}
inline float ActionCommandInfoV1::attackhiteffectduration() const {
  return attackhiteffectduration_;
}
inline void ActionCommandInfoV1::set_attackhiteffectduration(float value) {
  set_has_attackhiteffectduration();
  attackhiteffectduration_ = value;
}

// optional sint32 AttackFragmentCount = 18 [default = 1];
inline bool ActionCommandInfoV1::has_attackfragmentcount() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackfragmentcount() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ActionCommandInfoV1::clear_has_attackfragmentcount() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ActionCommandInfoV1::clear_attackfragmentcount() {
  attackfragmentcount_ = 1;
  clear_has_attackfragmentcount();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::attackfragmentcount() const {
  return attackfragmentcount_;
}
inline void ActionCommandInfoV1::set_attackfragmentcount(::google::protobuf::int32 value) {
  set_has_attackfragmentcount();
  attackfragmentcount_ = value;
}

// optional float AttackFragmentIntervalTime = 19 [default = 0];
inline bool ActionCommandInfoV1::has_attackfragmentintervaltime() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackfragmentintervaltime() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ActionCommandInfoV1::clear_has_attackfragmentintervaltime() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ActionCommandInfoV1::clear_attackfragmentintervaltime() {
  attackfragmentintervaltime_ = 0;
  clear_has_attackfragmentintervaltime();
}
inline float ActionCommandInfoV1::attackfragmentintervaltime() const {
  return attackfragmentintervaltime_;
}
inline void ActionCommandInfoV1::set_attackfragmentintervaltime(float value) {
  set_has_attackfragmentintervaltime();
  attackfragmentintervaltime_ = value;
}

// optional float AttackDamageRadio = 20 [default = 1];
inline bool ActionCommandInfoV1::has_attackdamageradio() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackdamageradio() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ActionCommandInfoV1::clear_has_attackdamageradio() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ActionCommandInfoV1::clear_attackdamageradio() {
  attackdamageradio_ = 1;
  clear_has_attackdamageradio();
}
inline float ActionCommandInfoV1::attackdamageradio() const {
  return attackdamageradio_;
}
inline void ActionCommandInfoV1::set_attackdamageradio(float value) {
  set_has_attackdamageradio();
  attackdamageradio_ = value;
}

// optional bool BuffSelfActive = 21 [default = false];
inline bool ActionCommandInfoV1::has_buffselfactive() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ActionCommandInfoV1::set_has_buffselfactive() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ActionCommandInfoV1::clear_has_buffselfactive() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ActionCommandInfoV1::clear_buffselfactive() {
  buffselfactive_ = false;
  clear_has_buffselfactive();
}
inline bool ActionCommandInfoV1::buffselfactive() const {
  return buffselfactive_;
}
inline void ActionCommandInfoV1::set_buffselfactive(bool value) {
  set_has_buffselfactive();
  buffselfactive_ = value;
}

// optional bool BuffTargetActive = 22 [default = false];
inline bool ActionCommandInfoV1::has_bufftargetactive() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ActionCommandInfoV1::set_has_bufftargetactive() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ActionCommandInfoV1::clear_has_bufftargetactive() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ActionCommandInfoV1::clear_bufftargetactive() {
  bufftargetactive_ = false;
  clear_has_bufftargetactive();
}
inline bool ActionCommandInfoV1::bufftargetactive() const {
  return bufftargetactive_;
}
inline void ActionCommandInfoV1::set_bufftargetactive(bool value) {
  set_has_bufftargetactive();
  bufftargetactive_ = value;
}

// optional float AttackBehaviourBackDistance = 24 [default = 0];
inline bool ActionCommandInfoV1::has_attackbehaviourbackdistance() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackbehaviourbackdistance() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ActionCommandInfoV1::clear_has_attackbehaviourbackdistance() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ActionCommandInfoV1::clear_attackbehaviourbackdistance() {
  attackbehaviourbackdistance_ = 0;
  clear_has_attackbehaviourbackdistance();
}
inline float ActionCommandInfoV1::attackbehaviourbackdistance() const {
  return attackbehaviourbackdistance_;
}
inline void ActionCommandInfoV1::set_attackbehaviourbackdistance(float value) {
  set_has_attackbehaviourbackdistance();
  attackbehaviourbackdistance_ = value;
}

// optional float AttackBehaviourAirHeight = 25 [default = 0];
inline bool ActionCommandInfoV1::has_attackbehaviourairheight() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackbehaviourairheight() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ActionCommandInfoV1::clear_has_attackbehaviourairheight() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ActionCommandInfoV1::clear_attackbehaviourairheight() {
  attackbehaviourairheight_ = 0;
  clear_has_attackbehaviourairheight();
}
inline float ActionCommandInfoV1::attackbehaviourairheight() const {
  return attackbehaviourairheight_;
}
inline void ActionCommandInfoV1::set_attackbehaviourairheight(float value) {
  set_has_attackbehaviourairheight();
  attackbehaviourairheight_ = value;
}

// optional .ActionV3V1 EffectRotationOffset = 27;
inline bool ActionCommandInfoV1::has_effectrotationoffset() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ActionCommandInfoV1::set_has_effectrotationoffset() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ActionCommandInfoV1::clear_has_effectrotationoffset() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ActionCommandInfoV1::clear_effectrotationoffset() {
  if (effectrotationoffset_ != NULL) effectrotationoffset_->::ActionV3V1::Clear();
  clear_has_effectrotationoffset();
}
inline const ::ActionV3V1& ActionCommandInfoV1::effectrotationoffset() const {
  return effectrotationoffset_ != NULL ? *effectrotationoffset_ : *default_instance_->effectrotationoffset_;
}
inline ::ActionV3V1* ActionCommandInfoV1::mutable_effectrotationoffset() {
  set_has_effectrotationoffset();
  if (effectrotationoffset_ == NULL) effectrotationoffset_ = new ::ActionV3V1;
  return effectrotationoffset_;
}
inline ::ActionV3V1* ActionCommandInfoV1::release_effectrotationoffset() {
  clear_has_effectrotationoffset();
  ::ActionV3V1* temp = effectrotationoffset_;
  effectrotationoffset_ = NULL;
  return temp;
}
inline void ActionCommandInfoV1::set_allocated_effectrotationoffset(::ActionV3V1* effectrotationoffset) {
  delete effectrotationoffset_;
  effectrotationoffset_ = effectrotationoffset;
  if (effectrotationoffset) {
    set_has_effectrotationoffset();
  } else {
    clear_has_effectrotationoffset();
  }
}

// optional sint32 FlashControlObjectId = 28 [default = 0];
inline bool ActionCommandInfoV1::has_flashcontrolobjectid() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ActionCommandInfoV1::set_has_flashcontrolobjectid() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ActionCommandInfoV1::clear_has_flashcontrolobjectid() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ActionCommandInfoV1::clear_flashcontrolobjectid() {
  flashcontrolobjectid_ = 0;
  clear_has_flashcontrolobjectid();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::flashcontrolobjectid() const {
  return flashcontrolobjectid_;
}
inline void ActionCommandInfoV1::set_flashcontrolobjectid(::google::protobuf::int32 value) {
  set_has_flashcontrolobjectid();
  flashcontrolobjectid_ = value;
}

// optional float AttackStiffTime = 29 [default = 0];
inline bool ActionCommandInfoV1::has_attackstifftime() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackstifftime() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ActionCommandInfoV1::clear_has_attackstifftime() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ActionCommandInfoV1::clear_attackstifftime() {
  attackstifftime_ = 0;
  clear_has_attackstifftime();
}
inline float ActionCommandInfoV1::attackstifftime() const {
  return attackstifftime_;
}
inline void ActionCommandInfoV1::set_attackstifftime(float value) {
  set_has_attackstifftime();
  attackstifftime_ = value;
}

// optional bool AttackShake = 30 [default = false];
inline bool ActionCommandInfoV1::has_attackshake() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackshake() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ActionCommandInfoV1::clear_has_attackshake() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ActionCommandInfoV1::clear_attackshake() {
  attackshake_ = false;
  clear_has_attackshake();
}
inline bool ActionCommandInfoV1::attackshake() const {
  return attackshake_;
}
inline void ActionCommandInfoV1::set_attackshake(bool value) {
  set_has_attackshake();
  attackshake_ = value;
}

// optional bool AttackFlash = 31 [default = false];
inline bool ActionCommandInfoV1::has_attackflash() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackflash() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ActionCommandInfoV1::clear_has_attackflash() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ActionCommandInfoV1::clear_attackflash() {
  attackflash_ = false;
  clear_has_attackflash();
}
inline bool ActionCommandInfoV1::attackflash() const {
  return attackflash_;
}
inline void ActionCommandInfoV1::set_attackflash(bool value) {
  set_has_attackflash();
  attackflash_ = value;
}

// optional float AttackBehaviourBackSpeed = 32 [default = 1];
inline bool ActionCommandInfoV1::has_attackbehaviourbackspeed() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackbehaviourbackspeed() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ActionCommandInfoV1::clear_has_attackbehaviourbackspeed() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ActionCommandInfoV1::clear_attackbehaviourbackspeed() {
  attackbehaviourbackspeed_ = 1;
  clear_has_attackbehaviourbackspeed();
}
inline float ActionCommandInfoV1::attackbehaviourbackspeed() const {
  return attackbehaviourbackspeed_;
}
inline void ActionCommandInfoV1::set_attackbehaviourbackspeed(float value) {
  set_has_attackbehaviourbackspeed();
  attackbehaviourbackspeed_ = value;
}

// optional float AttackBehaviourAirSpeed = 33 [default = 1];
inline bool ActionCommandInfoV1::has_attackbehaviourairspeed() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackbehaviourairspeed() {
  _has_bits_[0] |= 0x20000000u;
}
inline void ActionCommandInfoV1::clear_has_attackbehaviourairspeed() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void ActionCommandInfoV1::clear_attackbehaviourairspeed() {
  attackbehaviourairspeed_ = 1;
  clear_has_attackbehaviourairspeed();
}
inline float ActionCommandInfoV1::attackbehaviourairspeed() const {
  return attackbehaviourairspeed_;
}
inline void ActionCommandInfoV1::set_attackbehaviourairspeed(float value) {
  set_has_attackbehaviourairspeed();
  attackbehaviourairspeed_ = value;
}

// optional bool AttackBehaviourBack = 35 [default = false];
inline bool ActionCommandInfoV1::has_attackbehaviourback() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackbehaviourback() {
  _has_bits_[0] |= 0x40000000u;
}
inline void ActionCommandInfoV1::clear_has_attackbehaviourback() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void ActionCommandInfoV1::clear_attackbehaviourback() {
  attackbehaviourback_ = false;
  clear_has_attackbehaviourback();
}
inline bool ActionCommandInfoV1::attackbehaviourback() const {
  return attackbehaviourback_;
}
inline void ActionCommandInfoV1::set_attackbehaviourback(bool value) {
  set_has_attackbehaviourback();
  attackbehaviourback_ = value;
}

// optional bool AttackBehaviourAir = 36 [default = false];
inline bool ActionCommandInfoV1::has_attackbehaviourair() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackbehaviourair() {
  _has_bits_[0] |= 0x80000000u;
}
inline void ActionCommandInfoV1::clear_has_attackbehaviourair() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void ActionCommandInfoV1::clear_attackbehaviourair() {
  attackbehaviourair_ = false;
  clear_has_attackbehaviourair();
}
inline bool ActionCommandInfoV1::attackbehaviourair() const {
  return attackbehaviourair_;
}
inline void ActionCommandInfoV1::set_attackbehaviourair(bool value) {
  set_has_attackbehaviourair();
  attackbehaviourair_ = value;
}

// optional bool AttackBehaviourZoom = 37 [default = false];
inline bool ActionCommandInfoV1::has_attackbehaviourzoom() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackbehaviourzoom() {
  _has_bits_[1] |= 0x00000001u;
}
inline void ActionCommandInfoV1::clear_has_attackbehaviourzoom() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void ActionCommandInfoV1::clear_attackbehaviourzoom() {
  attackbehaviourzoom_ = false;
  clear_has_attackbehaviourzoom();
}
inline bool ActionCommandInfoV1::attackbehaviourzoom() const {
  return attackbehaviourzoom_;
}
inline void ActionCommandInfoV1::set_attackbehaviourzoom(bool value) {
  set_has_attackbehaviourzoom();
  attackbehaviourzoom_ = value;
}

// optional string SoundName = 38;
inline bool ActionCommandInfoV1::has_soundname() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void ActionCommandInfoV1::set_has_soundname() {
  _has_bits_[1] |= 0x00000002u;
}
inline void ActionCommandInfoV1::clear_has_soundname() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void ActionCommandInfoV1::clear_soundname() {
  if (soundname_ != &::google::protobuf::internal::kEmptyString) {
    soundname_->clear();
  }
  clear_has_soundname();
}
inline const ::std::string& ActionCommandInfoV1::soundname() const {
  return *soundname_;
}
inline void ActionCommandInfoV1::set_soundname(const ::std::string& value) {
  set_has_soundname();
  if (soundname_ == &::google::protobuf::internal::kEmptyString) {
    soundname_ = new ::std::string;
  }
  soundname_->assign(value);
}
inline void ActionCommandInfoV1::set_soundname(const char* value) {
  set_has_soundname();
  if (soundname_ == &::google::protobuf::internal::kEmptyString) {
    soundname_ = new ::std::string;
  }
  soundname_->assign(value);
}
inline void ActionCommandInfoV1::set_soundname(const char* value, size_t size) {
  set_has_soundname();
  if (soundname_ == &::google::protobuf::internal::kEmptyString) {
    soundname_ = new ::std::string;
  }
  soundname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActionCommandInfoV1::mutable_soundname() {
  set_has_soundname();
  if (soundname_ == &::google::protobuf::internal::kEmptyString) {
    soundname_ = new ::std::string;
  }
  return soundname_;
}
inline ::std::string* ActionCommandInfoV1::release_soundname() {
  clear_has_soundname();
  if (soundname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = soundname_;
    soundname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActionCommandInfoV1::set_allocated_soundname(::std::string* soundname) {
  if (soundname_ != &::google::protobuf::internal::kEmptyString) {
    delete soundname_;
  }
  if (soundname) {
    set_has_soundname();
    soundname_ = soundname;
  } else {
    clear_has_soundname();
    soundname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool Trigger = 39 [default = false];
inline bool ActionCommandInfoV1::has_trigger() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void ActionCommandInfoV1::set_has_trigger() {
  _has_bits_[1] |= 0x00000004u;
}
inline void ActionCommandInfoV1::clear_has_trigger() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void ActionCommandInfoV1::clear_trigger() {
  trigger_ = false;
  clear_has_trigger();
}
inline bool ActionCommandInfoV1::trigger() const {
  return trigger_;
}
inline void ActionCommandInfoV1::set_trigger(bool value) {
  set_has_trigger();
  trigger_ = value;
}

// optional sint32 TriggerIndex = 40 [default = 1];
inline bool ActionCommandInfoV1::has_triggerindex() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void ActionCommandInfoV1::set_has_triggerindex() {
  _has_bits_[1] |= 0x00000008u;
}
inline void ActionCommandInfoV1::clear_has_triggerindex() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void ActionCommandInfoV1::clear_triggerindex() {
  triggerindex_ = 1;
  clear_has_triggerindex();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::triggerindex() const {
  return triggerindex_;
}
inline void ActionCommandInfoV1::set_triggerindex(::google::protobuf::int32 value) {
  set_has_triggerindex();
  triggerindex_ = value;
}

// optional sint32 AttackHitDummy = 41 [default = 0];
inline bool ActionCommandInfoV1::has_attackhitdummy() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackhitdummy() {
  _has_bits_[1] |= 0x00000010u;
}
inline void ActionCommandInfoV1::clear_has_attackhitdummy() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void ActionCommandInfoV1::clear_attackhitdummy() {
  attackhitdummy_ = 0;
  clear_has_attackhitdummy();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::attackhitdummy() const {
  return attackhitdummy_;
}
inline void ActionCommandInfoV1::set_attackhitdummy(::google::protobuf::int32 value) {
  set_has_attackhitdummy();
  attackhitdummy_ = value;
}

// optional string AttackHitSound = 42;
inline bool ActionCommandInfoV1::has_attackhitsound() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackhitsound() {
  _has_bits_[1] |= 0x00000020u;
}
inline void ActionCommandInfoV1::clear_has_attackhitsound() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void ActionCommandInfoV1::clear_attackhitsound() {
  if (attackhitsound_ != &::google::protobuf::internal::kEmptyString) {
    attackhitsound_->clear();
  }
  clear_has_attackhitsound();
}
inline const ::std::string& ActionCommandInfoV1::attackhitsound() const {
  return *attackhitsound_;
}
inline void ActionCommandInfoV1::set_attackhitsound(const ::std::string& value) {
  set_has_attackhitsound();
  if (attackhitsound_ == &::google::protobuf::internal::kEmptyString) {
    attackhitsound_ = new ::std::string;
  }
  attackhitsound_->assign(value);
}
inline void ActionCommandInfoV1::set_attackhitsound(const char* value) {
  set_has_attackhitsound();
  if (attackhitsound_ == &::google::protobuf::internal::kEmptyString) {
    attackhitsound_ = new ::std::string;
  }
  attackhitsound_->assign(value);
}
inline void ActionCommandInfoV1::set_attackhitsound(const char* value, size_t size) {
  set_has_attackhitsound();
  if (attackhitsound_ == &::google::protobuf::internal::kEmptyString) {
    attackhitsound_ = new ::std::string;
  }
  attackhitsound_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActionCommandInfoV1::mutable_attackhitsound() {
  set_has_attackhitsound();
  if (attackhitsound_ == &::google::protobuf::internal::kEmptyString) {
    attackhitsound_ = new ::std::string;
  }
  return attackhitsound_;
}
inline ::std::string* ActionCommandInfoV1::release_attackhitsound() {
  clear_has_attackhitsound();
  if (attackhitsound_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = attackhitsound_;
    attackhitsound_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActionCommandInfoV1::set_allocated_attackhitsound(::std::string* attackhitsound) {
  if (attackhitsound_ != &::google::protobuf::internal::kEmptyString) {
    delete attackhitsound_;
  }
  if (attackhitsound) {
    set_has_attackhitsound();
    attackhitsound_ = attackhitsound;
  } else {
    clear_has_attackhitsound();
    attackhitsound_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float HitShakeCameraXRange = 44 [default = 0];
inline bool ActionCommandInfoV1::has_hitshakecameraxrange() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void ActionCommandInfoV1::set_has_hitshakecameraxrange() {
  _has_bits_[1] |= 0x00000040u;
}
inline void ActionCommandInfoV1::clear_has_hitshakecameraxrange() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void ActionCommandInfoV1::clear_hitshakecameraxrange() {
  hitshakecameraxrange_ = 0;
  clear_has_hitshakecameraxrange();
}
inline float ActionCommandInfoV1::hitshakecameraxrange() const {
  return hitshakecameraxrange_;
}
inline void ActionCommandInfoV1::set_hitshakecameraxrange(float value) {
  set_has_hitshakecameraxrange();
  hitshakecameraxrange_ = value;
}

// optional float HitShakeCameraYRange = 45 [default = 0];
inline bool ActionCommandInfoV1::has_hitshakecamerayrange() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void ActionCommandInfoV1::set_has_hitshakecamerayrange() {
  _has_bits_[1] |= 0x00000080u;
}
inline void ActionCommandInfoV1::clear_has_hitshakecamerayrange() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void ActionCommandInfoV1::clear_hitshakecamerayrange() {
  hitshakecamerayrange_ = 0;
  clear_has_hitshakecamerayrange();
}
inline float ActionCommandInfoV1::hitshakecamerayrange() const {
  return hitshakecamerayrange_;
}
inline void ActionCommandInfoV1::set_hitshakecamerayrange(float value) {
  set_has_hitshakecamerayrange();
  hitshakecamerayrange_ = value;
}

// optional sint32 HitShakeCameraCount = 46 [default = 1];
inline bool ActionCommandInfoV1::has_hitshakecameracount() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void ActionCommandInfoV1::set_has_hitshakecameracount() {
  _has_bits_[1] |= 0x00000100u;
}
inline void ActionCommandInfoV1::clear_has_hitshakecameracount() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void ActionCommandInfoV1::clear_hitshakecameracount() {
  hitshakecameracount_ = 1;
  clear_has_hitshakecameracount();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::hitshakecameracount() const {
  return hitshakecameracount_;
}
inline void ActionCommandInfoV1::set_hitshakecameracount(::google::protobuf::int32 value) {
  set_has_hitshakecameracount();
  hitshakecameracount_ = value;
}

// optional float HitShakeCameraDurationTime = 47 [default = 0.1];
inline bool ActionCommandInfoV1::has_hitshakecameradurationtime() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void ActionCommandInfoV1::set_has_hitshakecameradurationtime() {
  _has_bits_[1] |= 0x00000200u;
}
inline void ActionCommandInfoV1::clear_has_hitshakecameradurationtime() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void ActionCommandInfoV1::clear_hitshakecameradurationtime() {
  hitshakecameradurationtime_ = 0.1f;
  clear_has_hitshakecameradurationtime();
}
inline float ActionCommandInfoV1::hitshakecameradurationtime() const {
  return hitshakecameradurationtime_;
}
inline void ActionCommandInfoV1::set_hitshakecameradurationtime(float value) {
  set_has_hitshakecameradurationtime();
  hitshakecameradurationtime_ = value;
}

// optional sint32 HiddenWeaponMode = 50 [default = 0];
inline bool ActionCommandInfoV1::has_hiddenweaponmode() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void ActionCommandInfoV1::set_has_hiddenweaponmode() {
  _has_bits_[1] |= 0x00000400u;
}
inline void ActionCommandInfoV1::clear_has_hiddenweaponmode() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void ActionCommandInfoV1::clear_hiddenweaponmode() {
  hiddenweaponmode_ = 0;
  clear_has_hiddenweaponmode();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::hiddenweaponmode() const {
  return hiddenweaponmode_;
}
inline void ActionCommandInfoV1::set_hiddenweaponmode(::google::protobuf::int32 value) {
  set_has_hiddenweaponmode();
  hiddenweaponmode_ = value;
}

// optional string NextActionName = 51;
inline bool ActionCommandInfoV1::has_nextactionname() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void ActionCommandInfoV1::set_has_nextactionname() {
  _has_bits_[1] |= 0x00000800u;
}
inline void ActionCommandInfoV1::clear_has_nextactionname() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void ActionCommandInfoV1::clear_nextactionname() {
  if (nextactionname_ != &::google::protobuf::internal::kEmptyString) {
    nextactionname_->clear();
  }
  clear_has_nextactionname();
}
inline const ::std::string& ActionCommandInfoV1::nextactionname() const {
  return *nextactionname_;
}
inline void ActionCommandInfoV1::set_nextactionname(const ::std::string& value) {
  set_has_nextactionname();
  if (nextactionname_ == &::google::protobuf::internal::kEmptyString) {
    nextactionname_ = new ::std::string;
  }
  nextactionname_->assign(value);
}
inline void ActionCommandInfoV1::set_nextactionname(const char* value) {
  set_has_nextactionname();
  if (nextactionname_ == &::google::protobuf::internal::kEmptyString) {
    nextactionname_ = new ::std::string;
  }
  nextactionname_->assign(value);
}
inline void ActionCommandInfoV1::set_nextactionname(const char* value, size_t size) {
  set_has_nextactionname();
  if (nextactionname_ == &::google::protobuf::internal::kEmptyString) {
    nextactionname_ = new ::std::string;
  }
  nextactionname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActionCommandInfoV1::mutable_nextactionname() {
  set_has_nextactionname();
  if (nextactionname_ == &::google::protobuf::internal::kEmptyString) {
    nextactionname_ = new ::std::string;
  }
  return nextactionname_;
}
inline ::std::string* ActionCommandInfoV1::release_nextactionname() {
  clear_has_nextactionname();
  if (nextactionname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nextactionname_;
    nextactionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActionCommandInfoV1::set_allocated_nextactionname(::std::string* nextactionname) {
  if (nextactionname_ != &::google::protobuf::internal::kEmptyString) {
    delete nextactionname_;
  }
  if (nextactionname) {
    set_has_nextactionname();
    nextactionname_ = nextactionname;
  } else {
    clear_has_nextactionname();
    nextactionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint32 TranslateWrapMode = 52 [default = 0];
inline bool ActionCommandInfoV1::has_translatewrapmode() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void ActionCommandInfoV1::set_has_translatewrapmode() {
  _has_bits_[1] |= 0x00001000u;
}
inline void ActionCommandInfoV1::clear_has_translatewrapmode() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void ActionCommandInfoV1::clear_translatewrapmode() {
  translatewrapmode_ = 0;
  clear_has_translatewrapmode();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::translatewrapmode() const {
  return translatewrapmode_;
}
inline void ActionCommandInfoV1::set_translatewrapmode(::google::protobuf::int32 value) {
  set_has_translatewrapmode();
  translatewrapmode_ = value;
}

// optional bool IsTriggerSecondAttack = 53 [default = false];
inline bool ActionCommandInfoV1::has_istriggersecondattack() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void ActionCommandInfoV1::set_has_istriggersecondattack() {
  _has_bits_[1] |= 0x00002000u;
}
inline void ActionCommandInfoV1::clear_has_istriggersecondattack() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void ActionCommandInfoV1::clear_istriggersecondattack() {
  istriggersecondattack_ = false;
  clear_has_istriggersecondattack();
}
inline bool ActionCommandInfoV1::istriggersecondattack() const {
  return istriggersecondattack_;
}
inline void ActionCommandInfoV1::set_istriggersecondattack(bool value) {
  set_has_istriggersecondattack();
  istriggersecondattack_ = value;
}

// optional bool IsHitGround = 54 [default = false];
inline bool ActionCommandInfoV1::has_ishitground() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void ActionCommandInfoV1::set_has_ishitground() {
  _has_bits_[1] |= 0x00004000u;
}
inline void ActionCommandInfoV1::clear_has_ishitground() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void ActionCommandInfoV1::clear_ishitground() {
  ishitground_ = false;
  clear_has_ishitground();
}
inline bool ActionCommandInfoV1::ishitground() const {
  return ishitground_;
}
inline void ActionCommandInfoV1::set_ishitground(bool value) {
  set_has_ishitground();
  ishitground_ = value;
}

// optional string SkillActionName = 55;
inline bool ActionCommandInfoV1::has_skillactionname() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void ActionCommandInfoV1::set_has_skillactionname() {
  _has_bits_[1] |= 0x00008000u;
}
inline void ActionCommandInfoV1::clear_has_skillactionname() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void ActionCommandInfoV1::clear_skillactionname() {
  if (skillactionname_ != &::google::protobuf::internal::kEmptyString) {
    skillactionname_->clear();
  }
  clear_has_skillactionname();
}
inline const ::std::string& ActionCommandInfoV1::skillactionname() const {
  return *skillactionname_;
}
inline void ActionCommandInfoV1::set_skillactionname(const ::std::string& value) {
  set_has_skillactionname();
  if (skillactionname_ == &::google::protobuf::internal::kEmptyString) {
    skillactionname_ = new ::std::string;
  }
  skillactionname_->assign(value);
}
inline void ActionCommandInfoV1::set_skillactionname(const char* value) {
  set_has_skillactionname();
  if (skillactionname_ == &::google::protobuf::internal::kEmptyString) {
    skillactionname_ = new ::std::string;
  }
  skillactionname_->assign(value);
}
inline void ActionCommandInfoV1::set_skillactionname(const char* value, size_t size) {
  set_has_skillactionname();
  if (skillactionname_ == &::google::protobuf::internal::kEmptyString) {
    skillactionname_ = new ::std::string;
  }
  skillactionname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActionCommandInfoV1::mutable_skillactionname() {
  set_has_skillactionname();
  if (skillactionname_ == &::google::protobuf::internal::kEmptyString) {
    skillactionname_ = new ::std::string;
  }
  return skillactionname_;
}
inline ::std::string* ActionCommandInfoV1::release_skillactionname() {
  clear_has_skillactionname();
  if (skillactionname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = skillactionname_;
    skillactionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActionCommandInfoV1::set_allocated_skillactionname(::std::string* skillactionname) {
  if (skillactionname_ != &::google::protobuf::internal::kEmptyString) {
    delete skillactionname_;
  }
  if (skillactionname) {
    set_has_skillactionname();
    skillactionname_ = skillactionname;
  } else {
    clear_has_skillactionname();
    skillactionname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string WarningRes1 = 56;
inline bool ActionCommandInfoV1::has_warningres1() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void ActionCommandInfoV1::set_has_warningres1() {
  _has_bits_[1] |= 0x00010000u;
}
inline void ActionCommandInfoV1::clear_has_warningres1() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void ActionCommandInfoV1::clear_warningres1() {
  if (warningres1_ != &::google::protobuf::internal::kEmptyString) {
    warningres1_->clear();
  }
  clear_has_warningres1();
}
inline const ::std::string& ActionCommandInfoV1::warningres1() const {
  return *warningres1_;
}
inline void ActionCommandInfoV1::set_warningres1(const ::std::string& value) {
  set_has_warningres1();
  if (warningres1_ == &::google::protobuf::internal::kEmptyString) {
    warningres1_ = new ::std::string;
  }
  warningres1_->assign(value);
}
inline void ActionCommandInfoV1::set_warningres1(const char* value) {
  set_has_warningres1();
  if (warningres1_ == &::google::protobuf::internal::kEmptyString) {
    warningres1_ = new ::std::string;
  }
  warningres1_->assign(value);
}
inline void ActionCommandInfoV1::set_warningres1(const char* value, size_t size) {
  set_has_warningres1();
  if (warningres1_ == &::google::protobuf::internal::kEmptyString) {
    warningres1_ = new ::std::string;
  }
  warningres1_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActionCommandInfoV1::mutable_warningres1() {
  set_has_warningres1();
  if (warningres1_ == &::google::protobuf::internal::kEmptyString) {
    warningres1_ = new ::std::string;
  }
  return warningres1_;
}
inline ::std::string* ActionCommandInfoV1::release_warningres1() {
  clear_has_warningres1();
  if (warningres1_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = warningres1_;
    warningres1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActionCommandInfoV1::set_allocated_warningres1(::std::string* warningres1) {
  if (warningres1_ != &::google::protobuf::internal::kEmptyString) {
    delete warningres1_;
  }
  if (warningres1) {
    set_has_warningres1();
    warningres1_ = warningres1;
  } else {
    clear_has_warningres1();
    warningres1_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string WarningRes2 = 57;
inline bool ActionCommandInfoV1::has_warningres2() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void ActionCommandInfoV1::set_has_warningres2() {
  _has_bits_[1] |= 0x00020000u;
}
inline void ActionCommandInfoV1::clear_has_warningres2() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void ActionCommandInfoV1::clear_warningres2() {
  if (warningres2_ != &::google::protobuf::internal::kEmptyString) {
    warningres2_->clear();
  }
  clear_has_warningres2();
}
inline const ::std::string& ActionCommandInfoV1::warningres2() const {
  return *warningres2_;
}
inline void ActionCommandInfoV1::set_warningres2(const ::std::string& value) {
  set_has_warningres2();
  if (warningres2_ == &::google::protobuf::internal::kEmptyString) {
    warningres2_ = new ::std::string;
  }
  warningres2_->assign(value);
}
inline void ActionCommandInfoV1::set_warningres2(const char* value) {
  set_has_warningres2();
  if (warningres2_ == &::google::protobuf::internal::kEmptyString) {
    warningres2_ = new ::std::string;
  }
  warningres2_->assign(value);
}
inline void ActionCommandInfoV1::set_warningres2(const char* value, size_t size) {
  set_has_warningres2();
  if (warningres2_ == &::google::protobuf::internal::kEmptyString) {
    warningres2_ = new ::std::string;
  }
  warningres2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActionCommandInfoV1::mutable_warningres2() {
  set_has_warningres2();
  if (warningres2_ == &::google::protobuf::internal::kEmptyString) {
    warningres2_ = new ::std::string;
  }
  return warningres2_;
}
inline ::std::string* ActionCommandInfoV1::release_warningres2() {
  clear_has_warningres2();
  if (warningres2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = warningres2_;
    warningres2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActionCommandInfoV1::set_allocated_warningres2(::std::string* warningres2) {
  if (warningres2_ != &::google::protobuf::internal::kEmptyString) {
    delete warningres2_;
  }
  if (warningres2) {
    set_has_warningres2();
    warningres2_ = warningres2;
  } else {
    clear_has_warningres2();
    warningres2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .ActionV3V1 WarningMaxScale = 58;
inline bool ActionCommandInfoV1::has_warningmaxscale() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void ActionCommandInfoV1::set_has_warningmaxscale() {
  _has_bits_[1] |= 0x00040000u;
}
inline void ActionCommandInfoV1::clear_has_warningmaxscale() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void ActionCommandInfoV1::clear_warningmaxscale() {
  if (warningmaxscale_ != NULL) warningmaxscale_->::ActionV3V1::Clear();
  clear_has_warningmaxscale();
}
inline const ::ActionV3V1& ActionCommandInfoV1::warningmaxscale() const {
  return warningmaxscale_ != NULL ? *warningmaxscale_ : *default_instance_->warningmaxscale_;
}
inline ::ActionV3V1* ActionCommandInfoV1::mutable_warningmaxscale() {
  set_has_warningmaxscale();
  if (warningmaxscale_ == NULL) warningmaxscale_ = new ::ActionV3V1;
  return warningmaxscale_;
}
inline ::ActionV3V1* ActionCommandInfoV1::release_warningmaxscale() {
  clear_has_warningmaxscale();
  ::ActionV3V1* temp = warningmaxscale_;
  warningmaxscale_ = NULL;
  return temp;
}
inline void ActionCommandInfoV1::set_allocated_warningmaxscale(::ActionV3V1* warningmaxscale) {
  delete warningmaxscale_;
  warningmaxscale_ = warningmaxscale;
  if (warningmaxscale) {
    set_has_warningmaxscale();
  } else {
    clear_has_warningmaxscale();
  }
}

// optional sint32 WarningScaleMode = 59 [default = 0];
inline bool ActionCommandInfoV1::has_warningscalemode() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void ActionCommandInfoV1::set_has_warningscalemode() {
  _has_bits_[1] |= 0x00080000u;
}
inline void ActionCommandInfoV1::clear_has_warningscalemode() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void ActionCommandInfoV1::clear_warningscalemode() {
  warningscalemode_ = 0;
  clear_has_warningscalemode();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::warningscalemode() const {
  return warningscalemode_;
}
inline void ActionCommandInfoV1::set_warningscalemode(::google::protobuf::int32 value) {
  set_has_warningscalemode();
  warningscalemode_ = value;
}

// optional sint32 WarningLockAxle = 60 [default = 0];
inline bool ActionCommandInfoV1::has_warninglockaxle() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void ActionCommandInfoV1::set_has_warninglockaxle() {
  _has_bits_[1] |= 0x00100000u;
}
inline void ActionCommandInfoV1::clear_has_warninglockaxle() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void ActionCommandInfoV1::clear_warninglockaxle() {
  warninglockaxle_ = 0;
  clear_has_warninglockaxle();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::warninglockaxle() const {
  return warninglockaxle_;
}
inline void ActionCommandInfoV1::set_warninglockaxle(::google::protobuf::int32 value) {
  set_has_warninglockaxle();
  warninglockaxle_ = value;
}

// optional .ActionV3V1 WarningPositionOffset = 61;
inline bool ActionCommandInfoV1::has_warningpositionoffset() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void ActionCommandInfoV1::set_has_warningpositionoffset() {
  _has_bits_[1] |= 0x00200000u;
}
inline void ActionCommandInfoV1::clear_has_warningpositionoffset() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void ActionCommandInfoV1::clear_warningpositionoffset() {
  if (warningpositionoffset_ != NULL) warningpositionoffset_->::ActionV3V1::Clear();
  clear_has_warningpositionoffset();
}
inline const ::ActionV3V1& ActionCommandInfoV1::warningpositionoffset() const {
  return warningpositionoffset_ != NULL ? *warningpositionoffset_ : *default_instance_->warningpositionoffset_;
}
inline ::ActionV3V1* ActionCommandInfoV1::mutable_warningpositionoffset() {
  set_has_warningpositionoffset();
  if (warningpositionoffset_ == NULL) warningpositionoffset_ = new ::ActionV3V1;
  return warningpositionoffset_;
}
inline ::ActionV3V1* ActionCommandInfoV1::release_warningpositionoffset() {
  clear_has_warningpositionoffset();
  ::ActionV3V1* temp = warningpositionoffset_;
  warningpositionoffset_ = NULL;
  return temp;
}
inline void ActionCommandInfoV1::set_allocated_warningpositionoffset(::ActionV3V1* warningpositionoffset) {
  delete warningpositionoffset_;
  warningpositionoffset_ = warningpositionoffset;
  if (warningpositionoffset) {
    set_has_warningpositionoffset();
  } else {
    clear_has_warningpositionoffset();
  }
}

// optional bool IsEffectFollow = 62 [default = false];
inline bool ActionCommandInfoV1::has_iseffectfollow() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void ActionCommandInfoV1::set_has_iseffectfollow() {
  _has_bits_[1] |= 0x00400000u;
}
inline void ActionCommandInfoV1::clear_has_iseffectfollow() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void ActionCommandInfoV1::clear_iseffectfollow() {
  iseffectfollow_ = false;
  clear_has_iseffectfollow();
}
inline bool ActionCommandInfoV1::iseffectfollow() const {
  return iseffectfollow_;
}
inline void ActionCommandInfoV1::set_iseffectfollow(bool value) {
  set_has_iseffectfollow();
  iseffectfollow_ = value;
}

// optional bool IsWarningTarget = 63 [default = false];
inline bool ActionCommandInfoV1::has_iswarningtarget() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void ActionCommandInfoV1::set_has_iswarningtarget() {
  _has_bits_[1] |= 0x00800000u;
}
inline void ActionCommandInfoV1::clear_has_iswarningtarget() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void ActionCommandInfoV1::clear_iswarningtarget() {
  iswarningtarget_ = false;
  clear_has_iswarningtarget();
}
inline bool ActionCommandInfoV1::iswarningtarget() const {
  return iswarningtarget_;
}
inline void ActionCommandInfoV1::set_iswarningtarget(bool value) {
  set_has_iswarningtarget();
  iswarningtarget_ = value;
}

// optional float AttackBehaviourAirDurationTime = 64 [default = 0];
inline bool ActionCommandInfoV1::has_attackbehaviourairdurationtime() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackbehaviourairdurationtime() {
  _has_bits_[1] |= 0x01000000u;
}
inline void ActionCommandInfoV1::clear_has_attackbehaviourairdurationtime() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void ActionCommandInfoV1::clear_attackbehaviourairdurationtime() {
  attackbehaviourairdurationtime_ = 0;
  clear_has_attackbehaviourairdurationtime();
}
inline float ActionCommandInfoV1::attackbehaviourairdurationtime() const {
  return attackbehaviourairdurationtime_;
}
inline void ActionCommandInfoV1::set_attackbehaviourairdurationtime(float value) {
  set_has_attackbehaviourairdurationtime();
  attackbehaviourairdurationtime_ = value;
}

// optional bool IsColliderDestroy = 66 [default = false];
inline bool ActionCommandInfoV1::has_iscolliderdestroy() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void ActionCommandInfoV1::set_has_iscolliderdestroy() {
  _has_bits_[1] |= 0x02000000u;
}
inline void ActionCommandInfoV1::clear_has_iscolliderdestroy() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void ActionCommandInfoV1::clear_iscolliderdestroy() {
  iscolliderdestroy_ = false;
  clear_has_iscolliderdestroy();
}
inline bool ActionCommandInfoV1::iscolliderdestroy() const {
  return iscolliderdestroy_;
}
inline void ActionCommandInfoV1::set_iscolliderdestroy(bool value) {
  set_has_iscolliderdestroy();
  iscolliderdestroy_ = value;
}

// optional bool IsAttackRangeFollow = 70 [default = false];
inline bool ActionCommandInfoV1::has_isattackrangefollow() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void ActionCommandInfoV1::set_has_isattackrangefollow() {
  _has_bits_[1] |= 0x04000000u;
}
inline void ActionCommandInfoV1::clear_has_isattackrangefollow() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void ActionCommandInfoV1::clear_isattackrangefollow() {
  isattackrangefollow_ = false;
  clear_has_isattackrangefollow();
}
inline bool ActionCommandInfoV1::isattackrangefollow() const {
  return isattackrangefollow_;
}
inline void ActionCommandInfoV1::set_isattackrangefollow(bool value) {
  set_has_isattackrangefollow();
  isattackrangefollow_ = value;
}

// optional bool IsAnimationLoop = 71 [default = false];
inline bool ActionCommandInfoV1::has_isanimationloop() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void ActionCommandInfoV1::set_has_isanimationloop() {
  _has_bits_[1] |= 0x08000000u;
}
inline void ActionCommandInfoV1::clear_has_isanimationloop() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void ActionCommandInfoV1::clear_isanimationloop() {
  isanimationloop_ = false;
  clear_has_isanimationloop();
}
inline bool ActionCommandInfoV1::isanimationloop() const {
  return isanimationloop_;
}
inline void ActionCommandInfoV1::set_isanimationloop(bool value) {
  set_has_isanimationloop();
  isanimationloop_ = value;
}

// optional float TranslateAngle = 72 [default = 0];
inline bool ActionCommandInfoV1::has_translateangle() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void ActionCommandInfoV1::set_has_translateangle() {
  _has_bits_[1] |= 0x10000000u;
}
inline void ActionCommandInfoV1::clear_has_translateangle() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void ActionCommandInfoV1::clear_translateangle() {
  translateangle_ = 0;
  clear_has_translateangle();
}
inline float ActionCommandInfoV1::translateangle() const {
  return translateangle_;
}
inline void ActionCommandInfoV1::set_translateangle(float value) {
  set_has_translateangle();
  translateangle_ = value;
}

// optional bool IsAttackRangeShade = 73 [default = false];
inline bool ActionCommandInfoV1::has_isattackrangeshade() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void ActionCommandInfoV1::set_has_isattackrangeshade() {
  _has_bits_[1] |= 0x20000000u;
}
inline void ActionCommandInfoV1::clear_has_isattackrangeshade() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void ActionCommandInfoV1::clear_isattackrangeshade() {
  isattackrangeshade_ = false;
  clear_has_isattackrangeshade();
}
inline bool ActionCommandInfoV1::isattackrangeshade() const {
  return isattackrangeshade_;
}
inline void ActionCommandInfoV1::set_isattackrangeshade(bool value) {
  set_has_isattackrangeshade();
  isattackrangeshade_ = value;
}

// optional float AttackInterval = 75 [default = 0];
inline bool ActionCommandInfoV1::has_attackinterval() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackinterval() {
  _has_bits_[1] |= 0x40000000u;
}
inline void ActionCommandInfoV1::clear_has_attackinterval() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void ActionCommandInfoV1::clear_attackinterval() {
  attackinterval_ = 0;
  clear_has_attackinterval();
}
inline float ActionCommandInfoV1::attackinterval() const {
  return attackinterval_;
}
inline void ActionCommandInfoV1::set_attackinterval(float value) {
  set_has_attackinterval();
  attackinterval_ = value;
}

// optional bool IsShowAttackRect = 76 [default = false];
inline bool ActionCommandInfoV1::has_isshowattackrect() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void ActionCommandInfoV1::set_has_isshowattackrect() {
  _has_bits_[1] |= 0x80000000u;
}
inline void ActionCommandInfoV1::clear_has_isshowattackrect() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void ActionCommandInfoV1::clear_isshowattackrect() {
  isshowattackrect_ = false;
  clear_has_isshowattackrect();
}
inline bool ActionCommandInfoV1::isshowattackrect() const {
  return isshowattackrect_;
}
inline void ActionCommandInfoV1::set_isshowattackrect(bool value) {
  set_has_isshowattackrect();
  isshowattackrect_ = value;
}

// optional float EffectBulletLaunchAngle = 78 [default = 0];
inline bool ActionCommandInfoV1::has_effectbulletlaunchangle() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void ActionCommandInfoV1::set_has_effectbulletlaunchangle() {
  _has_bits_[2] |= 0x00000001u;
}
inline void ActionCommandInfoV1::clear_has_effectbulletlaunchangle() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void ActionCommandInfoV1::clear_effectbulletlaunchangle() {
  effectbulletlaunchangle_ = 0;
  clear_has_effectbulletlaunchangle();
}
inline float ActionCommandInfoV1::effectbulletlaunchangle() const {
  return effectbulletlaunchangle_;
}
inline void ActionCommandInfoV1::set_effectbulletlaunchangle(float value) {
  set_has_effectbulletlaunchangle();
  effectbulletlaunchangle_ = value;
}

// optional float EffectBulletSpeed = 79 [default = 0];
inline bool ActionCommandInfoV1::has_effectbulletspeed() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void ActionCommandInfoV1::set_has_effectbulletspeed() {
  _has_bits_[2] |= 0x00000002u;
}
inline void ActionCommandInfoV1::clear_has_effectbulletspeed() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void ActionCommandInfoV1::clear_effectbulletspeed() {
  effectbulletspeed_ = 0;
  clear_has_effectbulletspeed();
}
inline float ActionCommandInfoV1::effectbulletspeed() const {
  return effectbulletspeed_;
}
inline void ActionCommandInfoV1::set_effectbulletspeed(float value) {
  set_has_effectbulletspeed();
  effectbulletspeed_ = value;
}

// optional .ActionRangeV1 EffectBulletLaunchTimeIntervalRange = 80;
inline bool ActionCommandInfoV1::has_effectbulletlaunchtimeintervalrange() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void ActionCommandInfoV1::set_has_effectbulletlaunchtimeintervalrange() {
  _has_bits_[2] |= 0x00000004u;
}
inline void ActionCommandInfoV1::clear_has_effectbulletlaunchtimeintervalrange() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void ActionCommandInfoV1::clear_effectbulletlaunchtimeintervalrange() {
  if (effectbulletlaunchtimeintervalrange_ != NULL) effectbulletlaunchtimeintervalrange_->::ActionRangeV1::Clear();
  clear_has_effectbulletlaunchtimeintervalrange();
}
inline const ::ActionRangeV1& ActionCommandInfoV1::effectbulletlaunchtimeintervalrange() const {
  return effectbulletlaunchtimeintervalrange_ != NULL ? *effectbulletlaunchtimeintervalrange_ : *default_instance_->effectbulletlaunchtimeintervalrange_;
}
inline ::ActionRangeV1* ActionCommandInfoV1::mutable_effectbulletlaunchtimeintervalrange() {
  set_has_effectbulletlaunchtimeintervalrange();
  if (effectbulletlaunchtimeintervalrange_ == NULL) effectbulletlaunchtimeintervalrange_ = new ::ActionRangeV1;
  return effectbulletlaunchtimeintervalrange_;
}
inline ::ActionRangeV1* ActionCommandInfoV1::release_effectbulletlaunchtimeintervalrange() {
  clear_has_effectbulletlaunchtimeintervalrange();
  ::ActionRangeV1* temp = effectbulletlaunchtimeintervalrange_;
  effectbulletlaunchtimeintervalrange_ = NULL;
  return temp;
}
inline void ActionCommandInfoV1::set_allocated_effectbulletlaunchtimeintervalrange(::ActionRangeV1* effectbulletlaunchtimeintervalrange) {
  delete effectbulletlaunchtimeintervalrange_;
  effectbulletlaunchtimeintervalrange_ = effectbulletlaunchtimeintervalrange;
  if (effectbulletlaunchtimeintervalrange) {
    set_has_effectbulletlaunchtimeintervalrange();
  } else {
    clear_has_effectbulletlaunchtimeintervalrange();
  }
}

// optional sint32 EffectBulletMaxCout = 82 [default = 0];
inline bool ActionCommandInfoV1::has_effectbulletmaxcout() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void ActionCommandInfoV1::set_has_effectbulletmaxcout() {
  _has_bits_[2] |= 0x00000008u;
}
inline void ActionCommandInfoV1::clear_has_effectbulletmaxcout() {
  _has_bits_[2] &= ~0x00000008u;
}
inline void ActionCommandInfoV1::clear_effectbulletmaxcout() {
  effectbulletmaxcout_ = 0;
  clear_has_effectbulletmaxcout();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::effectbulletmaxcout() const {
  return effectbulletmaxcout_;
}
inline void ActionCommandInfoV1::set_effectbulletmaxcout(::google::protobuf::int32 value) {
  set_has_effectbulletmaxcout();
  effectbulletmaxcout_ = value;
}

// optional .ActionRangeV1 EffectBulletLifeTimeInteralRange = 83;
inline bool ActionCommandInfoV1::has_effectbulletlifetimeinteralrange() const {
  return (_has_bits_[2] & 0x00000010u) != 0;
}
inline void ActionCommandInfoV1::set_has_effectbulletlifetimeinteralrange() {
  _has_bits_[2] |= 0x00000010u;
}
inline void ActionCommandInfoV1::clear_has_effectbulletlifetimeinteralrange() {
  _has_bits_[2] &= ~0x00000010u;
}
inline void ActionCommandInfoV1::clear_effectbulletlifetimeinteralrange() {
  if (effectbulletlifetimeinteralrange_ != NULL) effectbulletlifetimeinteralrange_->::ActionRangeV1::Clear();
  clear_has_effectbulletlifetimeinteralrange();
}
inline const ::ActionRangeV1& ActionCommandInfoV1::effectbulletlifetimeinteralrange() const {
  return effectbulletlifetimeinteralrange_ != NULL ? *effectbulletlifetimeinteralrange_ : *default_instance_->effectbulletlifetimeinteralrange_;
}
inline ::ActionRangeV1* ActionCommandInfoV1::mutable_effectbulletlifetimeinteralrange() {
  set_has_effectbulletlifetimeinteralrange();
  if (effectbulletlifetimeinteralrange_ == NULL) effectbulletlifetimeinteralrange_ = new ::ActionRangeV1;
  return effectbulletlifetimeinteralrange_;
}
inline ::ActionRangeV1* ActionCommandInfoV1::release_effectbulletlifetimeinteralrange() {
  clear_has_effectbulletlifetimeinteralrange();
  ::ActionRangeV1* temp = effectbulletlifetimeinteralrange_;
  effectbulletlifetimeinteralrange_ = NULL;
  return temp;
}
inline void ActionCommandInfoV1::set_allocated_effectbulletlifetimeinteralrange(::ActionRangeV1* effectbulletlifetimeinteralrange) {
  delete effectbulletlifetimeinteralrange_;
  effectbulletlifetimeinteralrange_ = effectbulletlifetimeinteralrange;
  if (effectbulletlifetimeinteralrange) {
    set_has_effectbulletlifetimeinteralrange();
  } else {
    clear_has_effectbulletlifetimeinteralrange();
  }
}

// optional sint32 EffectBulletType = 84 [default = 0];
inline bool ActionCommandInfoV1::has_effectbullettype() const {
  return (_has_bits_[2] & 0x00000020u) != 0;
}
inline void ActionCommandInfoV1::set_has_effectbullettype() {
  _has_bits_[2] |= 0x00000020u;
}
inline void ActionCommandInfoV1::clear_has_effectbullettype() {
  _has_bits_[2] &= ~0x00000020u;
}
inline void ActionCommandInfoV1::clear_effectbullettype() {
  effectbullettype_ = 0;
  clear_has_effectbullettype();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::effectbullettype() const {
  return effectbullettype_;
}
inline void ActionCommandInfoV1::set_effectbullettype(::google::protobuf::int32 value) {
  set_has_effectbullettype();
  effectbullettype_ = value;
}

// repeated .ActionV3V1 EffectBulletInitPosList = 85;
inline int ActionCommandInfoV1::effectbulletinitposlist_size() const {
  return effectbulletinitposlist_.size();
}
inline void ActionCommandInfoV1::clear_effectbulletinitposlist() {
  effectbulletinitposlist_.Clear();
}
inline const ::ActionV3V1& ActionCommandInfoV1::effectbulletinitposlist(int index) const {
  return effectbulletinitposlist_.Get(index);
}
inline ::ActionV3V1* ActionCommandInfoV1::mutable_effectbulletinitposlist(int index) {
  return effectbulletinitposlist_.Mutable(index);
}
inline ::ActionV3V1* ActionCommandInfoV1::add_effectbulletinitposlist() {
  return effectbulletinitposlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ActionV3V1 >&
ActionCommandInfoV1::effectbulletinitposlist() const {
  return effectbulletinitposlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::ActionV3V1 >*
ActionCommandInfoV1::mutable_effectbulletinitposlist() {
  return &effectbulletinitposlist_;
}

// optional sint32 EffectBulletLaunchMaxCount = 86 [default = 0];
inline bool ActionCommandInfoV1::has_effectbulletlaunchmaxcount() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void ActionCommandInfoV1::set_has_effectbulletlaunchmaxcount() {
  _has_bits_[2] |= 0x00000080u;
}
inline void ActionCommandInfoV1::clear_has_effectbulletlaunchmaxcount() {
  _has_bits_[2] &= ~0x00000080u;
}
inline void ActionCommandInfoV1::clear_effectbulletlaunchmaxcount() {
  effectbulletlaunchmaxcount_ = 0;
  clear_has_effectbulletlaunchmaxcount();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::effectbulletlaunchmaxcount() const {
  return effectbulletlaunchmaxcount_;
}
inline void ActionCommandInfoV1::set_effectbulletlaunchmaxcount(::google::protobuf::int32 value) {
  set_has_effectbulletlaunchmaxcount();
  effectbulletlaunchmaxcount_ = value;
}

// optional bool EffectBulletIsFollow = 88 [default = false];
inline bool ActionCommandInfoV1::has_effectbulletisfollow() const {
  return (_has_bits_[2] & 0x00000100u) != 0;
}
inline void ActionCommandInfoV1::set_has_effectbulletisfollow() {
  _has_bits_[2] |= 0x00000100u;
}
inline void ActionCommandInfoV1::clear_has_effectbulletisfollow() {
  _has_bits_[2] &= ~0x00000100u;
}
inline void ActionCommandInfoV1::clear_effectbulletisfollow() {
  effectbulletisfollow_ = false;
  clear_has_effectbulletisfollow();
}
inline bool ActionCommandInfoV1::effectbulletisfollow() const {
  return effectbulletisfollow_;
}
inline void ActionCommandInfoV1::set_effectbulletisfollow(bool value) {
  set_has_effectbulletisfollow();
  effectbulletisfollow_ = value;
}

// optional float AttackBehaviourAirDownSpeed = 89 [default = 0];
inline bool ActionCommandInfoV1::has_attackbehaviourairdownspeed() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackbehaviourairdownspeed() {
  _has_bits_[2] |= 0x00000200u;
}
inline void ActionCommandInfoV1::clear_has_attackbehaviourairdownspeed() {
  _has_bits_[2] &= ~0x00000200u;
}
inline void ActionCommandInfoV1::clear_attackbehaviourairdownspeed() {
  attackbehaviourairdownspeed_ = 0;
  clear_has_attackbehaviourairdownspeed();
}
inline float ActionCommandInfoV1::attackbehaviourairdownspeed() const {
  return attackbehaviourairdownspeed_;
}
inline void ActionCommandInfoV1::set_attackbehaviourairdownspeed(float value) {
  set_has_attackbehaviourairdownspeed();
  attackbehaviourairdownspeed_ = value;
}

// optional sint32 EffectDirectionLockType = 90 [default = 0];
inline bool ActionCommandInfoV1::has_effectdirectionlocktype() const {
  return (_has_bits_[2] & 0x00000400u) != 0;
}
inline void ActionCommandInfoV1::set_has_effectdirectionlocktype() {
  _has_bits_[2] |= 0x00000400u;
}
inline void ActionCommandInfoV1::clear_has_effectdirectionlocktype() {
  _has_bits_[2] &= ~0x00000400u;
}
inline void ActionCommandInfoV1::clear_effectdirectionlocktype() {
  effectdirectionlocktype_ = 0;
  clear_has_effectdirectionlocktype();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::effectdirectionlocktype() const {
  return effectdirectionlocktype_;
}
inline void ActionCommandInfoV1::set_effectdirectionlocktype(::google::protobuf::int32 value) {
  set_has_effectdirectionlocktype();
  effectdirectionlocktype_ = value;
}

// optional bool IsIrregularityEffect = 91 [default = false];
inline bool ActionCommandInfoV1::has_isirregularityeffect() const {
  return (_has_bits_[2] & 0x00000800u) != 0;
}
inline void ActionCommandInfoV1::set_has_isirregularityeffect() {
  _has_bits_[2] |= 0x00000800u;
}
inline void ActionCommandInfoV1::clear_has_isirregularityeffect() {
  _has_bits_[2] &= ~0x00000800u;
}
inline void ActionCommandInfoV1::clear_isirregularityeffect() {
  isirregularityeffect_ = false;
  clear_has_isirregularityeffect();
}
inline bool ActionCommandInfoV1::isirregularityeffect() const {
  return isirregularityeffect_;
}
inline void ActionCommandInfoV1::set_isirregularityeffect(bool value) {
  set_has_isirregularityeffect();
  isirregularityeffect_ = value;
}

// optional .ActionV3V1 EffectSize = 92;
inline bool ActionCommandInfoV1::has_effectsize() const {
  return (_has_bits_[2] & 0x00001000u) != 0;
}
inline void ActionCommandInfoV1::set_has_effectsize() {
  _has_bits_[2] |= 0x00001000u;
}
inline void ActionCommandInfoV1::clear_has_effectsize() {
  _has_bits_[2] &= ~0x00001000u;
}
inline void ActionCommandInfoV1::clear_effectsize() {
  if (effectsize_ != NULL) effectsize_->::ActionV3V1::Clear();
  clear_has_effectsize();
}
inline const ::ActionV3V1& ActionCommandInfoV1::effectsize() const {
  return effectsize_ != NULL ? *effectsize_ : *default_instance_->effectsize_;
}
inline ::ActionV3V1* ActionCommandInfoV1::mutable_effectsize() {
  set_has_effectsize();
  if (effectsize_ == NULL) effectsize_ = new ::ActionV3V1;
  return effectsize_;
}
inline ::ActionV3V1* ActionCommandInfoV1::release_effectsize() {
  clear_has_effectsize();
  ::ActionV3V1* temp = effectsize_;
  effectsize_ = NULL;
  return temp;
}
inline void ActionCommandInfoV1::set_allocated_effectsize(::ActionV3V1* effectsize) {
  delete effectsize_;
  effectsize_ = effectsize;
  if (effectsize) {
    set_has_effectsize();
  } else {
    clear_has_effectsize();
  }
}

// optional .ActionV3V1 AttackRangePostion = 93;
inline bool ActionCommandInfoV1::has_attackrangepostion() const {
  return (_has_bits_[2] & 0x00002000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackrangepostion() {
  _has_bits_[2] |= 0x00002000u;
}
inline void ActionCommandInfoV1::clear_has_attackrangepostion() {
  _has_bits_[2] &= ~0x00002000u;
}
inline void ActionCommandInfoV1::clear_attackrangepostion() {
  if (attackrangepostion_ != NULL) attackrangepostion_->::ActionV3V1::Clear();
  clear_has_attackrangepostion();
}
inline const ::ActionV3V1& ActionCommandInfoV1::attackrangepostion() const {
  return attackrangepostion_ != NULL ? *attackrangepostion_ : *default_instance_->attackrangepostion_;
}
inline ::ActionV3V1* ActionCommandInfoV1::mutable_attackrangepostion() {
  set_has_attackrangepostion();
  if (attackrangepostion_ == NULL) attackrangepostion_ = new ::ActionV3V1;
  return attackrangepostion_;
}
inline ::ActionV3V1* ActionCommandInfoV1::release_attackrangepostion() {
  clear_has_attackrangepostion();
  ::ActionV3V1* temp = attackrangepostion_;
  attackrangepostion_ = NULL;
  return temp;
}
inline void ActionCommandInfoV1::set_allocated_attackrangepostion(::ActionV3V1* attackrangepostion) {
  delete attackrangepostion_;
  attackrangepostion_ = attackrangepostion;
  if (attackrangepostion) {
    set_has_attackrangepostion();
  } else {
    clear_has_attackrangepostion();
  }
}

// optional .ActionV3V1 AttackRangeSize = 94;
inline bool ActionCommandInfoV1::has_attackrangesize() const {
  return (_has_bits_[2] & 0x00004000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackrangesize() {
  _has_bits_[2] |= 0x00004000u;
}
inline void ActionCommandInfoV1::clear_has_attackrangesize() {
  _has_bits_[2] &= ~0x00004000u;
}
inline void ActionCommandInfoV1::clear_attackrangesize() {
  if (attackrangesize_ != NULL) attackrangesize_->::ActionV3V1::Clear();
  clear_has_attackrangesize();
}
inline const ::ActionV3V1& ActionCommandInfoV1::attackrangesize() const {
  return attackrangesize_ != NULL ? *attackrangesize_ : *default_instance_->attackrangesize_;
}
inline ::ActionV3V1* ActionCommandInfoV1::mutable_attackrangesize() {
  set_has_attackrangesize();
  if (attackrangesize_ == NULL) attackrangesize_ = new ::ActionV3V1;
  return attackrangesize_;
}
inline ::ActionV3V1* ActionCommandInfoV1::release_attackrangesize() {
  clear_has_attackrangesize();
  ::ActionV3V1* temp = attackrangesize_;
  attackrangesize_ = NULL;
  return temp;
}
inline void ActionCommandInfoV1::set_allocated_attackrangesize(::ActionV3V1* attackrangesize) {
  delete attackrangesize_;
  attackrangesize_ = attackrangesize;
  if (attackrangesize) {
    set_has_attackrangesize();
  } else {
    clear_has_attackrangesize();
  }
}

// optional sint32 AttackShape = 95 [default = 0];
inline bool ActionCommandInfoV1::has_attackshape() const {
  return (_has_bits_[2] & 0x00008000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackshape() {
  _has_bits_[2] |= 0x00008000u;
}
inline void ActionCommandInfoV1::clear_has_attackshape() {
  _has_bits_[2] &= ~0x00008000u;
}
inline void ActionCommandInfoV1::clear_attackshape() {
  attackshape_ = 0;
  clear_has_attackshape();
}
inline ::google::protobuf::int32 ActionCommandInfoV1::attackshape() const {
  return attackshape_;
}
inline void ActionCommandInfoV1::set_attackshape(::google::protobuf::int32 value) {
  set_has_attackshape();
  attackshape_ = value;
}

// optional .ActionV3V1 AttackCircleOrigin = 96;
inline bool ActionCommandInfoV1::has_attackcircleorigin() const {
  return (_has_bits_[2] & 0x00010000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackcircleorigin() {
  _has_bits_[2] |= 0x00010000u;
}
inline void ActionCommandInfoV1::clear_has_attackcircleorigin() {
  _has_bits_[2] &= ~0x00010000u;
}
inline void ActionCommandInfoV1::clear_attackcircleorigin() {
  if (attackcircleorigin_ != NULL) attackcircleorigin_->::ActionV3V1::Clear();
  clear_has_attackcircleorigin();
}
inline const ::ActionV3V1& ActionCommandInfoV1::attackcircleorigin() const {
  return attackcircleorigin_ != NULL ? *attackcircleorigin_ : *default_instance_->attackcircleorigin_;
}
inline ::ActionV3V1* ActionCommandInfoV1::mutable_attackcircleorigin() {
  set_has_attackcircleorigin();
  if (attackcircleorigin_ == NULL) attackcircleorigin_ = new ::ActionV3V1;
  return attackcircleorigin_;
}
inline ::ActionV3V1* ActionCommandInfoV1::release_attackcircleorigin() {
  clear_has_attackcircleorigin();
  ::ActionV3V1* temp = attackcircleorigin_;
  attackcircleorigin_ = NULL;
  return temp;
}
inline void ActionCommandInfoV1::set_allocated_attackcircleorigin(::ActionV3V1* attackcircleorigin) {
  delete attackcircleorigin_;
  attackcircleorigin_ = attackcircleorigin;
  if (attackcircleorigin) {
    set_has_attackcircleorigin();
  } else {
    clear_has_attackcircleorigin();
  }
}

// optional float AttackCircleRadius = 97 [default = 0];
inline bool ActionCommandInfoV1::has_attackcircleradius() const {
  return (_has_bits_[2] & 0x00020000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackcircleradius() {
  _has_bits_[2] |= 0x00020000u;
}
inline void ActionCommandInfoV1::clear_has_attackcircleradius() {
  _has_bits_[2] &= ~0x00020000u;
}
inline void ActionCommandInfoV1::clear_attackcircleradius() {
  attackcircleradius_ = 0;
  clear_has_attackcircleradius();
}
inline float ActionCommandInfoV1::attackcircleradius() const {
  return attackcircleradius_;
}
inline void ActionCommandInfoV1::set_attackcircleradius(float value) {
  set_has_attackcircleradius();
  attackcircleradius_ = value;
}

// optional float AttackCircleAngle = 98 [default = 0];
inline bool ActionCommandInfoV1::has_attackcircleangle() const {
  return (_has_bits_[2] & 0x00040000u) != 0;
}
inline void ActionCommandInfoV1::set_has_attackcircleangle() {
  _has_bits_[2] |= 0x00040000u;
}
inline void ActionCommandInfoV1::clear_has_attackcircleangle() {
  _has_bits_[2] &= ~0x00040000u;
}
inline void ActionCommandInfoV1::clear_attackcircleangle() {
  attackcircleangle_ = 0;
  clear_has_attackcircleangle();
}
inline float ActionCommandInfoV1::attackcircleangle() const {
  return attackcircleangle_;
}
inline void ActionCommandInfoV1::set_attackcircleangle(float value) {
  set_has_attackcircleangle();
  attackcircleangle_ = value;
}

// -------------------------------------------------------------------

// ActionUselessV1

// -------------------------------------------------------------------

// ActionV2V1

// optional float X = 1 [default = 0];
inline bool ActionV2V1::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionV2V1::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionV2V1::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionV2V1::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float ActionV2V1::x() const {
  return x_;
}
inline void ActionV2V1::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float Y = 2 [default = 0];
inline bool ActionV2V1::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionV2V1::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionV2V1::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionV2V1::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float ActionV2V1::y() const {
  return y_;
}
inline void ActionV2V1::set_y(float value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// ActionV3V1

// optional float X = 1 [default = 0];
inline bool ActionV3V1::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionV3V1::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionV3V1::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionV3V1::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float ActionV3V1::x() const {
  return x_;
}
inline void ActionV3V1::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float Y = 2 [default = 0];
inline bool ActionV3V1::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionV3V1::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionV3V1::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionV3V1::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float ActionV3V1::y() const {
  return y_;
}
inline void ActionV3V1::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional float Z = 3 [default = 0];
inline bool ActionV3V1::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActionV3V1::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActionV3V1::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActionV3V1::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float ActionV3V1::z() const {
  return z_;
}
inline void ActionV3V1::set_z(float value) {
  set_has_z();
  z_ = value;
}

// -------------------------------------------------------------------

// ActionRangeV1

// optional float MinValue = 3 [default = 0];
inline bool ActionRangeV1::has_minvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActionRangeV1::set_has_minvalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActionRangeV1::clear_has_minvalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActionRangeV1::clear_minvalue() {
  minvalue_ = 0;
  clear_has_minvalue();
}
inline float ActionRangeV1::minvalue() const {
  return minvalue_;
}
inline void ActionRangeV1::set_minvalue(float value) {
  set_has_minvalue();
  minvalue_ = value;
}

// optional float MaxValue = 5 [default = 0];
inline bool ActionRangeV1::has_maxvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActionRangeV1::set_has_maxvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActionRangeV1::clear_has_maxvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActionRangeV1::clear_maxvalue() {
  maxvalue_ = 0;
  clear_has_maxvalue();
}
inline float ActionRangeV1::maxvalue() const {
  return maxvalue_;
}
inline void ActionRangeV1::set_maxvalue(float value) {
  set_has_maxvalue();
  maxvalue_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ActionV1Data_2eproto__INCLUDED
